{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wsh-Shell","text":"<p>Wsh-Shell is a lightweight, portable, and fully static shell interpreter written in C, designed for embedded systems. It requires no dynamic memory allocation and is built to run in constrained environments like microcontrollers, either bare-metal or under RTOS (e.g., FreeRTOS).</p>"},{"location":"#features","title":"\ud83d\ude80 Features","text":"<ul> <li>Cross-platform, highly portable \u2014 only one header file to include  </li> <li>Single State Structure \u2014 all shell state contained in a single <code>WshShell_t</code> instance  </li> <li>Static Memory Only \u2014 no <code>malloc</code>, no heap; all buffers are statically allocated  </li> <li>Modular Design \u2014 ability to disable submodules for memory footprint optimization</li> <li>Command-line Editing \u2014 supports cursor movement, character deletion, and insert mode  </li> <li>Command Parsing &amp; Options:  <ul> <li>Supports short (<code>-h</code>) and long (<code>--help</code>) flags  </li> <li>Supports int, float, string and other option types</li> <li>Supports double-quoted strings  </li> </ul> </li> <li>Escape Sequence Handling:  <ul> <li>Parses VT100/ANSI sequences  </li> <li>Supports arrow keys, delete, backspace, sound alerts, etc.  </li> <li>Handles key combinations (Ctrl+C, Ctrl+D, etc.)  </li> </ul> </li> <li>Command History:  <ul> <li>Implemented as a circular buffer  </li> <li>Efficient with hash-based integrity checks  </li> <li>Navigable with arrow keys (\u2191, \u2193)  </li> </ul> </li> <li>Autocomplete:  <ul> <li>Tab / double-Tab completion for commands and flags  </li> </ul> </li> <li>Multi-User Support \u2014 groups, access rights, and more  </li> <li>Customizable PS1 Prompt \u2014 user-defined templates for prompt appearance  </li> </ul>"},{"location":"#memory-footprint","title":"\ud83d\udcbe Memory footprint","text":"<p>Used flags: <code>-O1</code>, <code>-mcpu=cortex-m3</code>, <code>-mfloat-abi=soft</code></p> Config FLASH RAM All features enabled 12 KB 1.5 KB + WSH_SHELL_HISTORY 6 KB 0.5 KB + WSH_SHELL_PS1_CUSTOM 6 KB 0.5 KB + WSH_SHELL_AUTOCOMPLETE 6 KB 0.5 KB + WSH_SHELL_PRINT_SYS_ENABLE 6 KB 0.5 KB + WSH_SHELL_PRINT_INFO_ENABLE 6 KB 0.5 KB + WSH_SHELL_PRINT_WARN_ENABLE 6 KB 0.5 KB + WSH_SHELL_PRINT_ERR_ENABLE 6 KB 0.5 KB + WSH_SHELL_PRINT_OPT_HELP_ENABLE 6 KB 0.5 KB"},{"location":"#code-counting","title":"\u2328\ufe0f Code counting","text":"<pre><code>===============================================================================\n Language            Files        Lines         Code     Comments       Blanks\n===============================================================================\n C                      11         1806         1385           52          369\n C Header               15         1856          660          970          226\n===============================================================================\n Total                  26         3662         2045         1022          595\n===============================================================================\n</code></pre>"},{"location":"#authors","title":"Authors","text":"<ul> <li>abalyberdin@whoosh.bike \u2014 initial MVP  </li> <li>vignatov@whoosh.bike \u2014 improvements, refactoring</li> <li>akrestinin@whoosh.bike \u2014 project separation (for submodule usage), main structure, PC/MCU examples  </li> <li>sh@whoosh.bike \u2014 UX improvements, extra features, documentation</li> <li>eshamaev@whoosh.bike  \u2014 CI/CD, docs deployment, high-level PC command app</li> </ul>"},{"location":"dev/architecture/","title":"Architecture","text":""},{"location":"dev/architecture/#core-principles","title":"Core Principles","text":"<ul> <li> <p>Single-Instance State </p> <ul> <li>All shell state is stored inside a single <code>WshShell_t</code> structure.  </li> <li>Multiple instances can be created independently if needed.</li> </ul> </li> <li> <p>Modular Design </p> <ul> <li>Each feature is implemented as an isolated module (<code>cmd</code>, <code>user</code>, <code>history</code>, <code>autocomplete</code>, etc).</li> <li>Modules can be enabled or disabled to reduce code size and RAM usage.</li> </ul> </li> <li> <p>Configurable at Compile-Time </p> <ul> <li>Main shell parameters (buffer sizes, enabled features, color schemes, etc.) are controlled via configuration macros, allowing customization without changing the source.</li> </ul> </li> <li> <p>Static Memory Only </p> <ul> <li>No dynamic allocation (<code>malloc</code>/<code>free</code>).</li> <li>All commands, users, callbacks, and other resources are passed into the shell from outside.</li> </ul> </li> <li> <p>Platform-Independent </p> <ul> <li>Runs on bare-metal systems and under RTOS.</li> <li>No dependencies on specific hardware or CPU architecture.</li> </ul> </li> <li> <p>Lightweight Integration </p> <ul> <li>The shell is provided as a git submodule and can be easily integrated into any project.</li> </ul> </li> </ul>"},{"location":"dev/architecture/#project-structure","title":"Project Structure","text":"Module / File Purpose wsh_shell_autocomplete.h Tab-completion logic wsh_shell_cfg_def.h Default and user-specific configuration macros wsh_shell_cmd_def.h Default command for shell internal usage wsh_shell.h Main shell engine (state machine, event loop) wsh_shell_esc.h Terminal escape sequence handling wsh_shell_history.h Circular buffer for command history wsh_shell_interact.h Command interactive mode handling wsh_shell_io.h Input/output abstraction layer wsh_shell_option.h Command-line option parsing helpers wsh_shell_promptwait.h Custom keys await processing wsh_shell_str.h Line editing, cursor movement, interactive editing wsh_shell_types.h Core data types and enums wsh_shell_user.h Multi-user access control and permissions wsh_shell_version.h Version string and build metadata wsh_shell.h Main shell engine (state machine, event loop)"},{"location":"dev/architecture/#repository-layout","title":"Repository Layout","text":"<pre><code>.\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 wsh_shell.c\n    \u251c\u2500\u2500 wsh_shell.h\n    \u251c\u2500\u2500 wsh_shell_autocomplete.c\n    \u251c\u2500\u2500 wsh_shell_autocomplete.h\n    \u251c\u2500\u2500 wsh_shell_cfg_def.h\n    \u251c\u2500\u2500 wsh_shell_cmd.c\n    \u251c\u2500\u2500 wsh_shell_cmd.h\n    \u251c\u2500\u2500 wsh_shell_cmd_def.c\n    \u251c\u2500\u2500 wsh_shell_cmd_def.h\n    \u251c\u2500\u2500 wsh_shell_esc.c\n    \u251c\u2500\u2500 wsh_shell_esc.h\n    \u251c\u2500\u2500 wsh_shell_history.c\n    \u251c\u2500\u2500 wsh_shell_history.h\n    \u251c\u2500\u2500 wsh_shell_interact.c\n    \u251c\u2500\u2500 wsh_shell_interact.h\n    \u251c\u2500\u2500 wsh_shell_io.c\n    \u251c\u2500\u2500 wsh_shell_io.h\n    \u251c\u2500\u2500 wsh_shell_option.h\n    \u251c\u2500\u2500 wsh_shell_promptwait.c\n    \u251c\u2500\u2500 wsh_shell_promptwait.h\n    \u251c\u2500\u2500 wsh_shell_str.c\n    \u251c\u2500\u2500 wsh_shell_str.h\n    \u251c\u2500\u2500 wsh_shell_types.h\n    \u251c\u2500\u2500 wsh_shell_user.c\n    \u251c\u2500\u2500 wsh_shell_user.h\n    \u2514\u2500\u2500 wsh_shell_version.h\n</code></pre>"},{"location":"dev/build/","title":"Build Guide","text":"<p>This guide explains how to build the Wsh-Shell library and run its example applications both on a PC and on embedded hardware.</p>"},{"location":"dev/build/#prerequisites","title":"Prerequisites","text":"<p>Ensure the required toolchain components are installed on your system:</p> <pre><code>make --version\ngcc --version # for PC builds\narm-none-eabi-gcc --version  # for MCU builds\nopenocd --version # for MCU flash burn\ndoxygen --version # for docs generation with `mkdocs serve` on local machine\n</code></pre> <p>\ud83d\udca1 You can also use <code>clang</code> instead of <code>gcc</code> for PC builds.</p> <p>For exra actions you should use python virtualenv with <code>requirements.txt</code>:</p> <pre><code>python3 -m venv .venv\nsource .venv/bin/activate\npip install --upgrade pip\npip install -r requirements.txt\n</code></pre>"},{"location":"dev/build/#changing-the-compiler","title":"Changing the Compiler","text":"<p>You can change the compiler in the project\u2019s Makefile:</p> <pre><code># ===== Toolchain =====\nCC := gcc\n# or\nCC := clang\n</code></pre>"},{"location":"dev/build/#main-build","title":"Main Build","text":"<p>To build the default library:</p> <pre><code>make\n</code></pre> <p>During the first build, the default configuration file <code>wsh_shell_cfg_def.h</code> will be copied to <code>wsh_shell_cfg.h</code>, which is used in the build process.</p> <p>By default, the project is built in Debug mode. To build with the Release preset:</p> <pre><code>make BUILD=Release\n</code></pre> <p>This works for all examples (e.g., <code>basic</code> and <code>blue_pill</code>).</p>"},{"location":"dev/build/#cleaning-the-build","title":"Cleaning the Build","text":"<p>To remove temporary build files while keeping your configuration:</p> <pre><code>make clean\n</code></pre> <p>\u26a0\ufe0f This does not delete <code>wsh_shell_cfg.h</code>. Remove it manually if you want to regenerate it from the default template.</p>"},{"location":"dev/build/#building-and-running-examples","title":"Building and Running Examples","text":""},{"location":"dev/build/#basic-example-pc","title":"Basic Example (PC)","text":"<p>This example runs locally on your machine:</p> <pre><code>make clean &amp;&amp; make basic\n./example/basic/build/basic\n</code></pre> <p>or</p> <pre><code>cd example/basic\nmake\n./build/basic\n</code></pre>"},{"location":"dev/build/#blue-pill-example-stm32-mcu","title":"Blue Pill Example (STM32 MCU)","text":"<p>This example builds for the STM32F103 \"Blue Pill\" board:</p> <pre><code>make clean &amp;&amp; make blue_pill\n</code></pre> <p>For vscode launch run <code>gen_launch.py</code> script for <code>launch.json</code> generation from <code>launch.template.json</code>:</p> <pre><code>python3 .vscode/gen_launch.py \n</code></pre> <p>But previously you should setup <code>.env</code> file with required variables:</p> <pre><code>MAKE_PATH=\"/opt/homebrew/opt/make/libexec/gnubin/make\"\nARM_NONE_EABI_PATH=\"/Users/katbert/my-utils/arm-gnu-toolchain-14.2.rel1-darwin-arm64-arm-none-eabi/bin\"\nGDB_PATH=\"/Users/katbert/my-utils/arm-gnu-toolchain-14.2.rel1-darwin-arm64-arm-none-eabi/bin/arm-none-eabi-gdb\"\nOPENOCD_PATH=\"/opt/homebrew/bin/openocd\"\n</code></pre> <p>Then flash the binary using OpenOCD:</p> <pre><code>openocd -f ./example/blue_pill/stlink.cfg \\\n        -f ./example/blue_pill/stm32f1x.cfg \\\n        -c \"program example/blue_pill/build/blue_pill.bin 0x08000000 verify reset exit\"\n</code></pre> <p>For the blue pill clones use <code>ch32f1x.cfg</code> config instead of <code>stm32f1x.cfg</code></p>"},{"location":"dev/build/#additional-notes","title":"Additional Notes","text":"<ul> <li>You can adjust build presets or flags in the Makefile (e.g., optimization level, debug symbols).</li> <li>If using Windows, please do all in WSL enviroment.</li> </ul>"},{"location":"dev/initial-requirements/","title":"Initial requirements","text":"<p>The Wsh-Shell module must satisfy two main categories of requirements: User Requirements (focused on usability) and Development Requirements (focused on integration and maintainability).</p>"},{"location":"dev/initial-requirements/#user-requirements","title":"User Requirements","text":"<ol> <li> <p>Command Flags Support </p> <ul> <li>Support both long (<code>--long-option</code>) and short (<code>-s</code>) flag names.  </li> <li>Commands follow the standard syntax:  </li> <li>Long flags may exist without a corresponding short form.</li> </ul> </li> <li> <p>Command Auto-Completion </p> <ul> <li>Pressing Tab should auto-complete the current command or suggest possible completions.</li> </ul> </li> <li> <p>Command History </p> <ul> <li>Store history of executed commands.  </li> <li>Navigation: \u2191 to recall the previous command, \u2193 to recall the next one.</li> </ul> </li> <li> <p>Line Editing &amp; Cursor Movement </p> <ul> <li>Move the cursor within the input line using \u2190 and \u2192 keys.  </li> <li>Support in-place character insertion and deletion using Backspace.</li> </ul> </li> <li> <p>Hotkey Combinations </p> <ul> <li>Recognize and handle standard key combinations (e.g., Ctrl + C, Ctrl + D).</li> </ul> </li> <li> <p>User Authorization </p> <ul> <li>Require user login with a password before executing commands.</li> </ul> </li> <li> <p>Interface Switching </p> <ul> <li>Allow switching between hardware interfaces (e.g., USB, UART) without reflashing the firmware.</li> </ul> </li> <li> <p>Sub-Shell Support </p> <ul> <li>Enable running a separate shell instance in a dedicated thread for interacting with external devices.</li> </ul> </li> <li> <p>Cross-Platform Operation </p> <ul> <li>Run on various platforms without modification.</li> </ul> </li> <li> <p>Multiple Hardware Interfaces </p> <ul> <li>Support different hardware I/O backends (USB, UART, etc.) transparently.</li> </ul> </li> </ol>"},{"location":"dev/initial-requirements/#development-requirements","title":"Development Requirements","text":"<ol> <li>Single Include Entry Point </li> <li> <p>Only one header file is required to integrate Wsh-Shell into a project.</p> </li> <li> <p>Modular Command Registration </p> </li> <li> <p>Developers can define and register module-specific commands directly within their module.</p> </li> <li> <p>Configurable Portability </p> </li> <li> <p>Cross-platform compatibility is achieved via a dedicated configuration file.</p> </li> <li> <p>Git Submodule Integration </p> </li> <li> <p>Wsh-Shell should be easy to integrate into any project as a Git submodule.</p> </li> <li> <p>Dedicated Sub-Shell Task </p> </li> <li> <p>In RTOS-based systems, run sub-Shell routines in a separate FreeRTOS task.</p> </li> <li> <p>Hot-Swappable Interfaces </p> </li> <li> <p>Switching between hardware interfaces must be possible at runtime.</p> </li> <li> <p>Feature Modularity </p> </li> <li> <p>Features such as history, autocomplete, and authorization must be implemented as independent submodules that can be disabled without breaking the core functionality.</p> </li> <li> <p>Mandatory Authorization </p> </li> <li> <p>Authorization is always required except in debug builds.</p> </li> <li> <p>Clear Input Parsing Model </p> </li> <li> <p>Input parsing should follow a clearly defined state machine.</p> </li> <li> <p>Sub-Shell I/O Redirection </p> <ul> <li>When launching a sub-Shell, redirect input/output processing to the child shell instance.</li> </ul> </li> <li> <p>Hotkey &amp; Combination Parsing </p> <ul> <li>Ability to detect and handle hotkey sequences and special symbol combinations.</li> </ul> </li> </ol>"},{"location":"dev/initial-requirements/#why-not-microrl-tinysh-linenoise","title":"Why not Microrl / tinysh / linenoise?","text":""},{"location":"dev/initial-requirements/#notes","title":"Notes","text":"<ul> <li>The above requirements define both what the user sees and how the developer integrates the Wsh-Shell.</li> <li>Future improvements might include scripting support, persistent command history storage, and remote shell capability.</li> </ul>"},{"location":"dev/todo/","title":"TODO / Roadmap","text":""},{"location":"dev/todo/#v10","title":"v1.0","text":"<ul> <li> Implement base string parsing flow</li> <li> Implement user authentication flow</li> <li> Implement history buffer support</li> <li> Implement autocomplete actions triggered by the Tab key</li> <li> Add basic and Blue Pill examples</li> <li> Add support for ESC sequences and other ASCII control commands</li> </ul>"},{"location":"dev/todo/#v20","title":"v2.0","text":"<ul> <li> Review approaches for using the shell module with multiple instances, if needed</li> <li> Optimize history handling \u2014 fix bugs, improve user experience, replace CRC32 with Jenkins hash, etc.</li> <li> Implement advanced autocomplete with flag suggestions</li> <li> Simplify configuration file structure</li> <li> Add a built-in default command for querying the shell interface</li> <li> Optimize options file structure</li> </ul>"},{"location":"dev/todo/#v21","title":"v2.1","text":"<ul> <li> Add USB CDC support for STM32F1 Blue Pill</li> <li> Change command table attachment from storing commands to storing pointers to commands</li> <li> Add an extra space (' ') on double-Tab during command autocompletion</li> <li> Implement input blocking while waiting for specific keys (Enter, Yes/No, etc.)</li> <li> Save previous symbol and handle different terminals setup (<code>\\r</code>, <code>\\n</code> or <code>\\r\\n</code>)</li> <li> Add string print with deAuth reason on deAuth event</li> <li> Automatically generate documentation on GitHub Pages</li> </ul>"},{"location":"dev/todo/#v22","title":"v2.2","text":"<ul> <li> Review default command behavior and provide more detailed output about it.</li> <li> Review groups, permissions, and access levels for commands, users, and options; document them. Add <code>reader</code> user for reference</li> <li> Review and fix <code>wsh_shell_cmd</code> in <code>WshShellCmd_GetOptValue</code> if necessary</li> </ul> <pre><code>if (valIdx &gt;= argc)\n    return WSH_SHELL_RET_STATE_ERR_OVERFLOW;  // FIXME\n</code></pre> <ul> <li> Fix fault on history read \u0438\u043b\u0438 write callbacks if history isn't inited</li> </ul>"},{"location":"dev/todo/#v30","title":"v3.0","text":"<ul> <li> Add support for storing passwords in encrypted(hashed?) form in memory</li> </ul>"},{"location":"dev/todo/#v31","title":"v3.1","text":"<ul> <li> Automate build and test runs via GitHub Actions</li> </ul>"},{"location":"usage/bare-metal/","title":"Bare-Metal Integration Example","text":""},{"location":"usage/rtos/","title":"RTOS Integration Example","text":""},{"location":"usage/rtos/#functions-example-for-data-transmitting-from-main-app-to-shell-task","title":"Functions example for data transmitting from main app to shell task","text":"<pre><code>static QueueHandle_t ShellSymbol_Queue;\nstatic SemaphoreHandle_t ShellCommand_Mutex;\n\nbool ShellRoot_SendChar(char ch, u32 waitTmo) {\n    if (xSemaphoreTake(ShellCommand_Mutex, waitTmo) != pdTRUE)\n        return false;  // Need mutex here in case of ShellRoot_SendCommand simultaneous using\n\n    bool ret = (bool)(xQueueSend(ShellSymbol_Queue, &amp;ch, waitTmo) == pdPASS);\n    xSemaphoreGive(ShellCommand_Mutex);\n\n    return ret;\n}\n\nbool ShellRoot_SendCharFromISR(char ch, BaseType_t* pWoken) {\n    if (xSemaphoreTakeFromISR(ShellCommand_Mutex, pWoken) != pdTRUE)\n        return false;  // Need mutex here in case of ShellRoot_SendCommand simultaneous using\n\n    bool ret = (bool)(xQueueSendFromISR(ShellSymbol_Queue, &amp;ch, pWoken) == pdPASS);\n    xSemaphoreGiveFromISR(ShellCommand_Mutex, pWoken);\n\n    return ret;\n}\n\nbool ShellRoot_SendCommand(char* pCmd, u32 waitTmo) {\n    ASSERT_CHECK(pCmd);\n\n    if (!pCmd)\n        return false;\n\n    if (!WshShell_IsAuth(&amp;ShellRoot))\n        return false;\n\n    if (xSemaphoreTake(ShellCommand_Mutex, waitTmo) != pdTRUE)\n        return false;\n\n    u32 cmdLen = strlen(pCmd);\n    if (cmdLen &gt;= Shell_Hardware_GetRxBuffLen()) {\n        xSemaphoreGive(ShellCommand_Mutex);\n        PANIC();\n        return false;\n    }\n\n    for (u32 i = 0; i &lt; cmdLen; i++) {\n        if (xQueueSend(ShellSymbol_Queue, &amp;pCmd[i], waitTmo) != pdTRUE) {\n            xSemaphoreGive(ShellCommand_Mutex);\n            PANIC();\n            return false;\n        }\n    }\n\n    // Send trailing '\\n' to simulate Enter key\n    char newLine = '\\n';\n    if (xQueueSend(ShellSymbol_Queue, &amp;newLine, waitTmo) != pdTRUE) {\n        xSemaphoreGive(ShellCommand_Mutex);\n        PANIC();\n        return false;\n    }\n\n    xSemaphoreGive(ShellCommand_Mutex);\n    return true;\n}\n</code></pre>"},{"location":"usage/rtos/#task-example-of-shell-data-processing","title":"Task example of shell data processing","text":"<pre><code>static void vTask_Shell_Process(void* pvParameters) {\n    vTaskDelay(2000);\n    while (!Shell_Hardware_IsInit())\n        vTaskDelay(100);\n\n    ShellRoot_Init();\n\n#if DEBUG_ENABLE\n    WshShell_Auth(&amp;ShellRoot, \"admin\", \"1234\");\n#endif /* DEBUG_ENABLE */\n\n    for (;;) {\n        char symbol = 0;\n        xQueueReceive(ShellSymbol_Queue, &amp;symbol, portMAX_DELAY);\n        WshShell_InsertChar(&amp;ShellRoot, symbol);\n\n        vTaskDelay(RTOS_MIN_TIMEOUT_MS);\n    }\n}\n</code></pre>"},{"location":"Wsh_Shell_API/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>struct WshShellCmd Descriptor for a shell command. </li> <li>struct WshShellCmd_Table_t Table of shell commands. </li> <li>struct WshShellEsc_Action_t Escape sequence to handler mapping. </li> <li>struct WshShellEsc_Storage_t Escape sequence input state tracker. </li> <li>struct WshShellHistory_Data_t Internal structure for storing command history buffer. </li> <li>struct WshShellHistory_IO_t Structure holding function pointers for history persistence I/O. </li> <li>struct WshShellHistory_t Shell history structure with integrity check. </li> <li>struct WshShellIO_CommandLine_t Structure representing the current user input interaction state. </li> <li>struct WshShellOption_Context_t Option usage context during parsing. </li> <li>struct WshShellOption_t Represents a shell command-line option. </li> <li>struct WshShellPromptWait Prompt-wait control structure. </li> <li>struct WshShellStr_PS1Data_t </li> <li>struct WshShellUser_Table_t Table of registered shell users. </li> <li>struct WshShellUser_t User object definition. </li> <li>struct WshShell_AuthContext_t Temporary authentication context for login input handling. </li> <li>struct WshShell_ExtCallbacks_t Optional external callbacks invoked on user session changes. </li> <li>struct WshShell_Interact_t Interactive command registration structure. </li> <li>struct WshShell_t Main shell structure containing state, configuration, user context, and subsystems. </li> </ul>"},{"location":"Wsh_Shell_API/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir src <ul> <li>file wsh_shell.c </li> <li>file wsh_shell.h Core shell interface for command parsing, user authentication, and terminal interaction. </li> <li>file wsh_shell_autocomplete.c </li> <li>file wsh_shell_autocomplete.h Command-line autocompletion for shell commands. </li> <li>file wsh_shell_cfg_def.h </li> <li>file wsh_shell_cmd.c </li> <li>file wsh_shell_cmd.h Shell command object definition and public API. </li> <li>file wsh_shell_cmd_def.c </li> <li>file wsh_shell_cmd_def.h Declaration of default shell commands and their option tables. </li> <li>file wsh_shell_esc.c </li> <li>file wsh_shell_esc.h Escape sequence handling logic for WSH shell. </li> <li>file wsh_shell_history.c </li> <li>file wsh_shell_history.h Shell history management API. </li> <li>file wsh_shell_interact.c </li> <li>file wsh_shell_interact.h Interactive command registration and line editing utilities for WshShell. </li> <li>file wsh_shell_io.c </li> <li>file wsh_shell_io.h Terminal input/output definitions and interaction buffer API for WshShell. </li> <li>file wsh_shell_option.h Definition of shell command-line option object and creation macros. </li> <li>file wsh_shell_promptwait.c </li> <li>file wsh_shell_promptwait.h One-time user input waiting mechanism for WshShell. </li> <li>file wsh_shell_str.c </li> <li>file wsh_shell_str.h Common string operations for user input processing. </li> <li>file wsh_shell_types.h Basic type definitions and return state enumeration for WshShell. </li> <li>file wsh_shell_user.c </li> <li>file wsh_shell_user.h Shell user management API. </li> <li>file wsh_shell_version.h </li> </ul> </li> </ul>"},{"location":"Wsh_Shell_API/structWshShellCmd/","title":"Struct WshShellCmd","text":"<p>ClassList &gt; WshShellCmd</p> <p>Descriptor for a shell command. </p> <ul> <li><code>#include &lt;wsh_shell_cmd.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShellCmd/#public-attributes","title":"Public Attributes","text":"Type Name const WshShell_Char_t * Descr WshShell_Size_t Groups WshShellCmdHandler_t Handler const WshShell_Char_t * Name WshShell_Size_t OptNum const WshShellOption_t * Options"},{"location":"Wsh_Shell_API/structWshShellCmd/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShellCmd/#variable-descr","title":"variable Descr","text":"<pre><code>const WshShell_Char_t* WshShellCmd::Descr;\n</code></pre> <p>Human-readable description of the command. </p>"},{"location":"Wsh_Shell_API/structWshShellCmd/#variable-groups","title":"variable Groups","text":"<pre><code>WshShell_Size_t WshShellCmd::Groups;\n</code></pre> <p>Command group bitmask for access control or categorization. </p>"},{"location":"Wsh_Shell_API/structWshShellCmd/#variable-handler","title":"variable Handler","text":"<pre><code>WshShellCmdHandler_t WshShellCmd::Handler;\n</code></pre> <p>Execution callback function. </p>"},{"location":"Wsh_Shell_API/structWshShellCmd/#variable-name","title":"variable Name","text":"<pre><code>const WshShell_Char_t* WshShellCmd::Name;\n</code></pre> <p>Command name (e.g., \"set\", \"info\"). </p>"},{"location":"Wsh_Shell_API/structWshShellCmd/#variable-optnum","title":"variable OptNum","text":"<pre><code>WshShell_Size_t WshShellCmd::OptNum;\n</code></pre> <p>Number of defined options. </p>"},{"location":"Wsh_Shell_API/structWshShellCmd/#variable-options","title":"variable Options","text":"<pre><code>const WshShellOption_t* WshShellCmd::Options;\n</code></pre> <p>Pointer to the command's options array. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_cmd.h</code></p>"},{"location":"Wsh_Shell_API/structWshShellCmd__Table__t/","title":"Struct WshShellCmd_Table_t","text":"<p>ClassList &gt; WshShellCmd_Table_t</p> <p>Table of shell commands. </p> <ul> <li><code>#include &lt;wsh_shell_cmd.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShellCmd__Table__t/#public-attributes","title":"Public Attributes","text":"Type Name const WshShellCmd_t ** List WshShell_Size_t Num"},{"location":"Wsh_Shell_API/structWshShellCmd__Table__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShellCmd__Table__t/#variable-list","title":"variable List","text":"<pre><code>const WshShellCmd_t** WshShellCmd_Table_t::List;\n</code></pre> <p>Pointer to the array of pointers to commands. </p>"},{"location":"Wsh_Shell_API/structWshShellCmd__Table__t/#variable-num","title":"variable Num","text":"<pre><code>WshShell_Size_t WshShellCmd_Table_t::Num;\n</code></pre> <p>Number of commands in the table. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_cmd.h</code></p>"},{"location":"Wsh_Shell_API/structWshShellEsc__Action__t/","title":"Struct WshShellEsc_Action_t","text":"<p>ClassList &gt; WshShellEsc_Action_t</p> <p>Escape sequence to handler mapping. </p> <ul> <li><code>#include &lt;wsh_shell_esc.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShellEsc__Action__t/#public-attributes","title":"Public Attributes","text":"Type Name WshShellEsc_Hadler_t Handler const WshShell_Char_t * Sequence"},{"location":"Wsh_Shell_API/structWshShellEsc__Action__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShellEsc__Action__t/#variable-handler","title":"variable Handler","text":"<pre><code>WshShellEsc_Hadler_t WshShellEsc_Action_t::Handler;\n</code></pre> <p>Associated handler function </p>"},{"location":"Wsh_Shell_API/structWshShellEsc__Action__t/#variable-sequence","title":"variable Sequence","text":"<pre><code>const WshShell_Char_t* WshShellEsc_Action_t::Sequence;\n</code></pre> <p>ANSI escape sequence </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_esc.h</code></p>"},{"location":"Wsh_Shell_API/structWshShellEsc__Storage__t/","title":"Struct WshShellEsc_Storage_t","text":"<p>ClassList &gt; WshShellEsc_Storage_t</p> <p>Escape sequence input state tracker. </p> <ul> <li><code>#include &lt;wsh_shell_esc.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShellEsc__Storage__t/#public-attributes","title":"Public Attributes","text":"Type Name WshShell_Char_t Buff WshShell_Size_t Cnt"},{"location":"Wsh_Shell_API/structWshShellEsc__Storage__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShellEsc__Storage__t/#variable-buff","title":"variable Buff","text":"<pre><code>WshShell_Char_t WshShellEsc_Storage_t::Buff[WSH_SHELL_ESC_BUFF_LEN];\n</code></pre> <p>Escape sequence buffer </p>"},{"location":"Wsh_Shell_API/structWshShellEsc__Storage__t/#variable-cnt","title":"variable Cnt","text":"<pre><code>WshShell_Size_t WshShellEsc_Storage_t::Cnt;\n</code></pre> <p>Current number of buffered characters </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_esc.h</code></p>"},{"location":"Wsh_Shell_API/structWshShellHistory__Data__t/","title":"Struct WshShellHistory_Data_t","text":"<p>ClassList &gt; WshShellHistory_Data_t</p> <p>Internal structure for storing command history buffer. More...</p> <ul> <li><code>#include &lt;wsh_shell_history.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShellHistory__Data__t/#public-attributes","title":"Public Attributes","text":"Type Name WshShell_Size_t HeadIdx WshShell_Size_t LastSavedCmdIdx WshShell_Bool_t LimitIsReached WSH_SHELL_HIST_CMD_DIR_t PrevDir WshShell_Char_t StorageBuff WshShell_Size_t TailIdx"},{"location":"Wsh_Shell_API/structWshShellHistory__Data__t/#detailed-description","title":"Detailed Description","text":"<p>This structure contains the command history as a raw character buffer and related metadata for navigation and storage management. </p>"},{"location":"Wsh_Shell_API/structWshShellHistory__Data__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShellHistory__Data__t/#variable-headidx","title":"variable HeadIdx","text":"<pre><code>WshShell_Size_t WshShellHistory_Data_t::HeadIdx;\n</code></pre> <p>Index of the buffer start. </p>"},{"location":"Wsh_Shell_API/structWshShellHistory__Data__t/#variable-lastsavedcmdidx","title":"variable LastSavedCmdIdx","text":"<pre><code>WshShell_Size_t WshShellHistory_Data_t::LastSavedCmdIdx;\n</code></pre> <p>Index of the last saved command. </p>"},{"location":"Wsh_Shell_API/structWshShellHistory__Data__t/#variable-limitisreached","title":"variable LimitIsReached","text":"<pre><code>WshShell_Bool_t WshShellHistory_Data_t::LimitIsReached;\n</code></pre> <p>Flag indicating buffer search boundary reached. </p>"},{"location":"Wsh_Shell_API/structWshShellHistory__Data__t/#variable-prevdir","title":"variable PrevDir","text":"<pre><code>WSH_SHELL_HIST_CMD_DIR_t WshShellHistory_Data_t::PrevDir;\n</code></pre> <p>Last direction of history navigation. </p>"},{"location":"Wsh_Shell_API/structWshShellHistory__Data__t/#variable-storagebuff","title":"variable StorageBuff","text":"<pre><code>WshShell_Char_t WshShellHistory_Data_t::StorageBuff[WSH_SHELL_HISTORY_BUFF_SIZE];\n</code></pre> <p>Circular buffer for commands. </p>"},{"location":"Wsh_Shell_API/structWshShellHistory__Data__t/#variable-tailidx","title":"variable TailIdx","text":"<pre><code>WshShell_Size_t WshShellHistory_Data_t::TailIdx;\n</code></pre> <p>Index of the buffer end. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_history.h</code></p>"},{"location":"Wsh_Shell_API/structWshShellHistory__IO__t/","title":"Struct WshShellHistory_IO_t","text":"<p>ClassList &gt; WshShellHistory_IO_t</p> <p>Structure holding function pointers for history persistence I/O. More...</p> <ul> <li><code>#include &lt;wsh_shell_history.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShellHistory__IO__t/#public-attributes","title":"Public Attributes","text":"Type Name WshShellHistory_ReadHandler_t Read WshShellHistory_WriteHandler_t Write"},{"location":"Wsh_Shell_API/structWshShellHistory__IO__t/#detailed-description","title":"Detailed Description","text":"<p>This allows the shell history system to remain storage-agnostic by delegating read/write responsibilities to external code (e.g., flash drivers, NVM emulation). </p>"},{"location":"Wsh_Shell_API/structWshShellHistory__IO__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShellHistory__IO__t/#variable-read","title":"variable Read","text":"<pre><code>WshShellHistory_ReadHandler_t WshShellHistory_IO_t::Read;\n</code></pre> <p>Callback for loading saved history. </p>"},{"location":"Wsh_Shell_API/structWshShellHistory__IO__t/#variable-write","title":"variable Write","text":"<pre><code>WshShellHistory_WriteHandler_t WshShellHistory_IO_t::Write;\n</code></pre> <p>Callback for saving current history. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_history.h</code></p>"},{"location":"Wsh_Shell_API/structWshShellHistory__t/","title":"Struct WshShellHistory_t","text":"<p>ClassList &gt; WshShellHistory_t</p> <p>Shell history structure with integrity check. More...</p> <ul> <li><code>#include &lt;wsh_shell_history.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShellHistory__t/#public-attributes","title":"Public Attributes","text":"Type Name WshShellHistory_Data_t Data WshShell_U32_t Hash"},{"location":"Wsh_Shell_API/structWshShellHistory__t/#detailed-description","title":"Detailed Description","text":"<p>This structure wraps the command history data along with a hash (CRC) for validation. </p>"},{"location":"Wsh_Shell_API/structWshShellHistory__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShellHistory__t/#variable-data","title":"variable Data","text":"<pre><code>WshShellHistory_Data_t WshShellHistory_t::Data;\n</code></pre> <p>Command history buffer. </p>"},{"location":"Wsh_Shell_API/structWshShellHistory__t/#variable-hash","title":"variable Hash","text":"<pre><code>WshShell_U32_t WshShellHistory_t::Hash;\n</code></pre> <p>Hash for integrity verification. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_history.h</code></p>"},{"location":"Wsh_Shell_API/structWshShellIO__CommandLine__t/","title":"Struct WshShellIO_CommandLine_t","text":"<p>ClassList &gt; WshShellIO_CommandLine_t</p> <p>Structure representing the current user input interaction state. </p> <ul> <li><code>#include &lt;wsh_shell_io.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShellIO__CommandLine__t/#public-attributes","title":"Public Attributes","text":"Type Name WshShell_Char_t Buff WshShell_Size_t CursorPos WshShell_Size_t Len"},{"location":"Wsh_Shell_API/structWshShellIO__CommandLine__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShellIO__CommandLine__t/#variable-buff","title":"variable Buff","text":"<pre><code>WshShell_Char_t WshShellIO_CommandLine_t::Buff[WSH_SHELL_INTR_BUFF_LEN];\n</code></pre> <p>Input buffer for interactive line. </p>"},{"location":"Wsh_Shell_API/structWshShellIO__CommandLine__t/#variable-cursorpos","title":"variable CursorPos","text":"<pre><code>WshShell_Size_t WshShellIO_CommandLine_t::CursorPos;\n</code></pre> <p>Current cursor position in the buffer. </p>"},{"location":"Wsh_Shell_API/structWshShellIO__CommandLine__t/#variable-len","title":"variable Len","text":"<pre><code>WshShell_Size_t WshShellIO_CommandLine_t::Len;\n</code></pre> <p>Current length of the buffer. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_io.h</code></p>"},{"location":"Wsh_Shell_API/structWshShellOption__Context__t/","title":"Struct WshShellOption_Context_t","text":"<p>ClassList &gt; WshShellOption_Context_t</p> <p>Option usage context during parsing. More...</p> <ul> <li><code>#include &lt;wsh_shell_option.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShellOption__Context__t/#public-attributes","title":"Public Attributes","text":"Type Name const WshShellOption_t * Option WshShell_Size_t TokenPos"},{"location":"Wsh_Shell_API/structWshShellOption__Context__t/#detailed-description","title":"Detailed Description","text":"<p>Used internally to reference which token matched which option. </p>"},{"location":"Wsh_Shell_API/structWshShellOption__Context__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShellOption__Context__t/#variable-option","title":"variable Option","text":"<pre><code>const WshShellOption_t* WshShellOption_Context_t::Option;\n</code></pre> <p>Pointer to matched option. </p>"},{"location":"Wsh_Shell_API/structWshShellOption__Context__t/#variable-tokenpos","title":"variable TokenPos","text":"<pre><code>WshShell_Size_t WshShellOption_Context_t::TokenPos;\n</code></pre> <p>Position of the matching token in command line. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_option.h</code></p>"},{"location":"Wsh_Shell_API/structWshShellOption__t/","title":"Struct WshShellOption_t","text":"<p>ClassList &gt; WshShellOption_t</p> <p>Represents a shell command-line option. More...</p> <ul> <li><code>#include &lt;wsh_shell_option.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShellOption__t/#public-attributes","title":"Public Attributes","text":"Type Name WshShell_Size_t Access WshShell_Size_t ArgNum const WshShell_Char_t * Descr WshShell_Size_t ID const WshShell_Char_t * LongName const WshShell_Char_t * ShortName WSH_SHELL_OPTION_TYPE_t Type"},{"location":"Wsh_Shell_API/structWshShellOption__t/#detailed-description","title":"Detailed Description","text":"<p>This structure describes a single command-line option used in a shell command. It contains type, access level, required arguments, and optional short/long flags and description. </p>"},{"location":"Wsh_Shell_API/structWshShellOption__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShellOption__t/#variable-access","title":"variable Access","text":"<pre><code>WshShell_Size_t WshShellOption_t::Access;\n</code></pre> <p>Access level required to use this option. </p>"},{"location":"Wsh_Shell_API/structWshShellOption__t/#variable-argnum","title":"variable ArgNum","text":"<pre><code>WshShell_Size_t WshShellOption_t::ArgNum;\n</code></pre> <p>Number of arguments expected by this option. </p>"},{"location":"Wsh_Shell_API/structWshShellOption__t/#variable-descr","title":"variable Descr","text":"<pre><code>const WshShell_Char_t* WshShellOption_t::Descr;\n</code></pre> <p>Optional help description. </p>"},{"location":"Wsh_Shell_API/structWshShellOption__t/#variable-id","title":"variable ID","text":"<pre><code>WshShell_Size_t WshShellOption_t::ID;\n</code></pre> <p>Option identifier (for internal use). </p>"},{"location":"Wsh_Shell_API/structWshShellOption__t/#variable-longname","title":"variable LongName","text":"<pre><code>const WshShell_Char_t* WshShellOption_t::LongName;\n</code></pre> <p>Long flag (e.g. <code>\"--verbose\"</code>) </p>"},{"location":"Wsh_Shell_API/structWshShellOption__t/#variable-shortname","title":"variable ShortName","text":"<pre><code>const WshShell_Char_t* WshShellOption_t::ShortName;\n</code></pre> <p>Short flag (e.g. <code>\"-v\"</code>) </p>"},{"location":"Wsh_Shell_API/structWshShellOption__t/#variable-type","title":"variable Type","text":"<pre><code>WSH_SHELL_OPTION_TYPE_t WshShellOption_t::Type;\n</code></pre> <p>Option type. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_option.h</code></p>"},{"location":"Wsh_Shell_API/structWshShellPromptWait/","title":"Struct WshShellPromptWait","text":"<p>ClassList &gt; WshShellPromptWait</p> <p>Prompt-wait control structure. More...</p> <ul> <li><code>#include &lt;wsh_shell_promptwait.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShellPromptWait/#public-attributes","title":"Public Attributes","text":"Type Name void * Ctx WshShellPromptWait_Handler_t Handler"},{"location":"Wsh_Shell_API/structWshShellPromptWait/#detailed-description","title":"Detailed Description","text":"<p>Holds the active handler and optional context pointer. If Handler is NULL, no prompt-wait is active. </p>"},{"location":"Wsh_Shell_API/structWshShellPromptWait/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShellPromptWait/#variable-ctx","title":"variable Ctx","text":"<pre><code>void* WshShellPromptWait::Ctx;\n</code></pre>"},{"location":"Wsh_Shell_API/structWshShellPromptWait/#variable-handler","title":"variable Handler","text":"<pre><code>WshShellPromptWait_Handler_t WshShellPromptWait::Handler;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_promptwait.h</code></p>"},{"location":"Wsh_Shell_API/structWshShellStr__PS1Data__t/","title":"Struct WshShellStr_PS1Data_t","text":"<p>ClassList &gt; WshShellStr_PS1Data_t</p>"},{"location":"Wsh_Shell_API/structWshShellStr__PS1Data__t/#public-attributes","title":"Public Attributes","text":"Type Name const WshShell_Char_t * DevName WshShell_Char_t * InterCmdName const WshShell_Char_t * UserName"},{"location":"Wsh_Shell_API/structWshShellStr__PS1Data__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShellStr__PS1Data__t/#variable-devname","title":"variable DevName","text":"<pre><code>const WshShell_Char_t* WshShellStr_PS1Data_t::DevName;\n</code></pre>"},{"location":"Wsh_Shell_API/structWshShellStr__PS1Data__t/#variable-intercmdname","title":"variable InterCmdName","text":"<pre><code>WshShell_Char_t* WshShellStr_PS1Data_t::InterCmdName;\n</code></pre>"},{"location":"Wsh_Shell_API/structWshShellStr__PS1Data__t/#variable-username","title":"variable UserName","text":"<pre><code>const WshShell_Char_t* WshShellStr_PS1Data_t::UserName;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_str.h</code></p>"},{"location":"Wsh_Shell_API/structWshShellUser__Table__t/","title":"Struct WshShellUser_Table_t","text":"<p>ClassList &gt; WshShellUser_Table_t</p> <p>Table of registered shell users. More...</p> <ul> <li><code>#include &lt;wsh_shell_user.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShellUser__Table__t/#public-attributes","title":"Public Attributes","text":"Type Name const WshShellUser_t * List WshShell_Size_t Num"},{"location":"Wsh_Shell_API/structWshShellUser__Table__t/#detailed-description","title":"Detailed Description","text":"<p>This structure contains a list of shell users and total count. </p>"},{"location":"Wsh_Shell_API/structWshShellUser__Table__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShellUser__Table__t/#variable-list","title":"variable List","text":"<pre><code>const WshShellUser_t* WshShellUser_Table_t::List;\n</code></pre> <p>Pointer to an array of user objects. </p>"},{"location":"Wsh_Shell_API/structWshShellUser__Table__t/#variable-num","title":"variable Num","text":"<pre><code>WshShell_Size_t WshShellUser_Table_t::Num;\n</code></pre> <p>Number of users in the list. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_user.h</code></p>"},{"location":"Wsh_Shell_API/structWshShellUser__t/","title":"Struct WshShellUser_t","text":"<p>ClassList &gt; WshShellUser_t</p> <p>User object definition. More...</p> <ul> <li><code>#include &lt;wsh_shell_user.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShellUser__t/#public-attributes","title":"Public Attributes","text":"Type Name WshShell_Size_t Groups const WshShell_Char_t * Login const WshShell_Char_t * Pass WshShell_Size_t Rights"},{"location":"Wsh_Shell_API/structWshShellUser__t/#detailed-description","title":"Detailed Description","text":"<p>This structure represents a shell user with login, password, and associated access groups and rights. </p>"},{"location":"Wsh_Shell_API/structWshShellUser__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShellUser__t/#variable-groups","title":"variable Groups","text":"<pre><code>WshShell_Size_t WshShellUser_t::Groups;\n</code></pre> <p>Bitmask of accessible command groups. </p>"},{"location":"Wsh_Shell_API/structWshShellUser__t/#variable-login","title":"variable Login","text":"<pre><code>const WshShell_Char_t* WshShellUser_t::Login;\n</code></pre> <p>Pointer to login string. </p>"},{"location":"Wsh_Shell_API/structWshShellUser__t/#variable-pass","title":"variable Pass","text":"<pre><code>const WshShell_Char_t* WshShellUser_t::Pass;\n</code></pre> <p>Pointer to password string. </p>"},{"location":"Wsh_Shell_API/structWshShellUser__t/#variable-rights","title":"variable Rights","text":"<pre><code>WshShell_Size_t WshShellUser_t::Rights;\n</code></pre> <p>Bitmask of execution rights. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_user.h</code></p>"},{"location":"Wsh_Shell_API/structWshShell__AuthContext__t/","title":"Struct WshShell_AuthContext_t","text":"<p>ClassList &gt; WshShell_AuthContext_t</p> <p>Temporary authentication context for login input handling. </p> <ul> <li><code>#include &lt;wsh_shell.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShell__AuthContext__t/#public-attributes","title":"Public Attributes","text":"Type Name WshShell_Char_t Login WshShell_Char_t Pass"},{"location":"Wsh_Shell_API/structWshShell__AuthContext__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShell__AuthContext__t/#variable-login","title":"variable Login","text":"<pre><code>WshShell_Char_t WshShell_AuthContext_t::Login[WSH_SHELL_LOGIN_LEN];\n</code></pre> <p>Input buffer for username. </p>"},{"location":"Wsh_Shell_API/structWshShell__AuthContext__t/#variable-pass","title":"variable Pass","text":"<pre><code>WshShell_Char_t WshShell_AuthContext_t::Pass[WSH_SHELL_PASS_LEN];\n</code></pre> <p>Input buffer for password. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell.h</code></p>"},{"location":"Wsh_Shell_API/structWshShell__ExtCallbacks__t/","title":"Struct WshShell_ExtCallbacks_t","text":"<p>ClassList &gt; WshShell_ExtCallbacks_t</p> <p>Optional external callbacks invoked on user session changes. </p> <ul> <li><code>#include &lt;wsh_shell.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShell__ExtCallbacks__t/#public-attributes","title":"Public Attributes","text":"Type Name WshShell_ExtClbk_t Auth WshShell_ExtClbk_t DeAuth WshShell_ExtClbk_t SymbolIn"},{"location":"Wsh_Shell_API/structWshShell__ExtCallbacks__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShell__ExtCallbacks__t/#variable-auth","title":"variable Auth","text":"<pre><code>WshShell_ExtClbk_t WshShell_ExtCallbacks_t::Auth;\n</code></pre> <p>Called when a user successfully authenticates. </p>"},{"location":"Wsh_Shell_API/structWshShell__ExtCallbacks__t/#variable-deauth","title":"variable DeAuth","text":"<pre><code>WshShell_ExtClbk_t WshShell_ExtCallbacks_t::DeAuth;\n</code></pre> <p>Called when a user is de-authenticated or logs out. </p>"},{"location":"Wsh_Shell_API/structWshShell__ExtCallbacks__t/#variable-symbolin","title":"variable SymbolIn","text":"<pre><code>WshShell_ExtClbk_t WshShell_ExtCallbacks_t::SymbolIn;\n</code></pre> <p>Called when a sybol was received and inserted </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell.h</code></p>"},{"location":"Wsh_Shell_API/structWshShell__Interact__t/","title":"Struct WshShell_Interact_t","text":"<p>ClassList &gt; WshShell_Interact_t</p> <p>Interactive command registration structure. More...</p> <ul> <li><code>#include &lt;wsh_shell_interact.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShell__Interact__t/#public-attributes","title":"Public Attributes","text":"Type Name WshShell_Char_t CmdName WshShellInteractive_CmdHandler_t Handler"},{"location":"Wsh_Shell_API/structWshShell__Interact__t/#detailed-description","title":"Detailed Description","text":"<p>Stores the name of the interactive command and the corresponding execution function. </p>"},{"location":"Wsh_Shell_API/structWshShell__Interact__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShell__Interact__t/#variable-cmdname","title":"variable CmdName","text":"<pre><code>WshShell_Char_t WshShell_Interact_t::CmdName[WSH_SHELL_CMD_NAME_LEN];\n</code></pre> <p>Name of the interactive command. </p>"},{"location":"Wsh_Shell_API/structWshShell__Interact__t/#variable-handler","title":"variable Handler","text":"<pre><code>WshShellInteractive_CmdHandler_t WshShell_Interact_t::Handler;\n</code></pre> <p>Function to be executed in interactive mode. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_interact.h</code></p>"},{"location":"Wsh_Shell_API/structWshShell__t/","title":"Struct WshShell_t","text":"<p>ClassList &gt; WshShell_t</p> <p>Main shell structure containing state, configuration, user context, and subsystems. </p> <ul> <li><code>#include &lt;wsh_shell.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/structWshShell__t/#public-attributes","title":"Public Attributes","text":"Type Name WshShellIO_CommandLine_t CommandLine WshShellCmd_Table_t Commands const WshShellUser_t * CurrUser WshShell_Char_t DeviceName WshShellEsc_Storage_t EscStorage WshShell_ExtCallbacks_t ExtCallbacks WshShellHistory_IO_t HistoryIO WshShell_Interact_t Interact WshShell_Char_t PS1 WshShell_Char_t PrevSym WshShellPromptWait_t PromptWait WshShell_AuthContext_t TmpAuth WshShellUser_Table_t Users WshShell_Char_t * Version"},{"location":"Wsh_Shell_API/structWshShell__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Wsh_Shell_API/structWshShell__t/#variable-commandline","title":"variable CommandLine","text":"<pre><code>WshShellIO_CommandLine_t WshShell_t::CommandLine;\n</code></pre> <p>Terminal input/output interface. </p>"},{"location":"Wsh_Shell_API/structWshShell__t/#variable-commands","title":"variable Commands","text":"<pre><code>WshShellCmd_Table_t WshShell_t::Commands;\n</code></pre> <p>Registered command table. </p>"},{"location":"Wsh_Shell_API/structWshShell__t/#variable-curruser","title":"variable CurrUser","text":"<pre><code>const WshShellUser_t* WshShell_t::CurrUser;\n</code></pre> <p>Currently authenticated user. </p>"},{"location":"Wsh_Shell_API/structWshShell__t/#variable-devicename","title":"variable DeviceName","text":"<pre><code>WshShell_Char_t WshShell_t::DeviceName[WSH_SHELL_DEV_NAME_LEN];\n</code></pre> <p>Device name (used in PS1 and more). </p>"},{"location":"Wsh_Shell_API/structWshShell__t/#variable-escstorage","title":"variable EscStorage","text":"<pre><code>WshShellEsc_Storage_t WshShell_t::EscStorage;\n</code></pre> <p>Escape sequence state storage. </p>"},{"location":"Wsh_Shell_API/structWshShell__t/#variable-extcallbacks","title":"variable ExtCallbacks","text":"<pre><code>WshShell_ExtCallbacks_t WshShell_t::ExtCallbacks;\n</code></pre> <p>Optional external auth callbacks. </p>"},{"location":"Wsh_Shell_API/structWshShell__t/#variable-historyio","title":"variable HistoryIO","text":"<pre><code>WshShellHistory_IO_t WshShell_t::HistoryIO;\n</code></pre> <p>Command history buffer and ops. </p>"},{"location":"Wsh_Shell_API/structWshShell__t/#variable-interact","title":"variable Interact","text":"<pre><code>WshShell_Interact_t WshShell_t::Interact;\n</code></pre> <p>Interactive command interface. </p>"},{"location":"Wsh_Shell_API/structWshShell__t/#variable-ps1","title":"variable PS1","text":"<pre><code>WshShell_Char_t WshShell_t::PS1[WSH_SHELL_PS1_MAX_LEN];\n</code></pre> <p>Cached PS1 string. </p>"},{"location":"Wsh_Shell_API/structWshShell__t/#variable-prevsym","title":"variable PrevSym","text":"<pre><code>WshShell_Char_t WshShell_t::PrevSym;\n</code></pre> <p>Previous symbol inserted in. </p>"},{"location":"Wsh_Shell_API/structWshShell__t/#variable-promptwait","title":"variable PromptWait","text":"<pre><code>WshShellPromptWait_t WshShell_t::PromptWait;\n</code></pre>"},{"location":"Wsh_Shell_API/structWshShell__t/#variable-tmpauth","title":"variable TmpAuth","text":"<pre><code>WshShell_AuthContext_t WshShell_t::TmpAuth;\n</code></pre> <p>Temporary auth input storage. </p>"},{"location":"Wsh_Shell_API/structWshShell__t/#variable-users","title":"variable Users","text":"<pre><code>WshShellUser_Table_t WshShell_t::Users;\n</code></pre> <p>Table of available users. </p>"},{"location":"Wsh_Shell_API/structWshShell__t/#variable-version","title":"variable Version","text":"<pre><code>WshShell_Char_t* WshShell_t::Version;\n</code></pre> <p>Version string. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell.h</code></p>"},{"location":"Wsh_Shell_API/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"Dir src","text":"<p>FileList &gt; src</p>"},{"location":"Wsh_Shell_API/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","title":"Files","text":"Type Name file wsh_shell.c file wsh_shell.h Core shell interface for command parsing, user authentication, and terminal interaction. file wsh_shell_autocomplete.c file wsh_shell_autocomplete.h Command-line autocompletion for shell commands. file wsh_shell_cfg_def.h file wsh_shell_cmd.c file wsh_shell_cmd.h Shell command object definition and public API. file wsh_shell_cmd_def.c file wsh_shell_cmd_def.h Declaration of default shell commands and their option tables. file wsh_shell_esc.c file wsh_shell_esc.h Escape sequence handling logic for WSH shell. file wsh_shell_history.c file wsh_shell_history.h Shell history management API. file wsh_shell_interact.c file wsh_shell_interact.h Interactive command registration and line editing utilities for WshShell. file wsh_shell_io.c file wsh_shell_io.h Terminal input/output definitions and interaction buffer API for WshShell. file wsh_shell_option.h Definition of shell command-line option object and creation macros. file wsh_shell_promptwait.c file wsh_shell_promptwait.h One-time user input waiting mechanism for WshShell. file wsh_shell_str.c file wsh_shell_str.h Common string operations for user input processing. file wsh_shell_types.h Basic type definitions and return state enumeration for WshShell. file wsh_shell_user.c file wsh_shell_user.h Shell user management API. file wsh_shell_version.h <p>The documentation for this class was generated from the following file <code>src/</code></p>"},{"location":"Wsh_Shell_API/wsh__shell_8c/","title":"File wsh_shell.c","text":"<p>FileList &gt; src &gt; wsh_shell.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"wsh_shell.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#public-functions","title":"Public Functions","text":"Type Name WshShell_Bool_t WshShell_Auth (WshShell_t * pShell, const WshShell_Char_t * pcLogin, const WshShell_Char_t * pcPass) Attempt to authenticate a user with given login credentials. void WshShell_DeAuth (WshShell_t * pShell, const WshShell_Char_t * pcReason) De-authenticate the currently logged-in user. WSH_SHELL_RET_STATE_t WshShell_Init (WshShell_t * pShell, const WshShell_Char_t * pcDevName, const WshShell_Char_t * pcCustomHeader, WshShell_ExtCallbacks_t * pExtClbks) Initialize a shell instance. void WshShell_InsertChar (WshShell_t * pShell, const WshShell_Char_t symbol) Process a new character entered by the user. WshShell_Bool_t WshShell_IsAuth (WshShell_t * pShell) Check if a user is currently authenticated. void WshShell_Stub_ExtClbk (void * pCtx)"},{"location":"Wsh_Shell_API/wsh__shell_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name void WshShell_AuthHandler (WshShell_t * pShell)  void WshShell_InvitationPrint (WshShell_t * pShell)  void WshShell_StringHandler (WshShell_t * pShell)  void WshShell_SymbolHandler (WshShell_t * pShell, const WshShell_Char_t symbol)"},{"location":"Wsh_Shell_API/wsh__shell_8c/#macros","title":"Macros","text":"Type Name define SHELL_SAVE_PREV_AND_RETURN (pShell, sym) <code>/* multi line expression */</code> define WSH_SHELL_INTER_CMD_EXISTS () <code>(pShell-&amp;gt;Interact.Handler != NULL)</code> define WSH_SHELL_TMP_LOGIN_IS_EMPTY () <code>(pShell-&amp;gt;TmpAuth.Login[0] == 0)</code> define WSH_SHELL_TMP_PASS_IS_EMPTY () <code>(pShell-&amp;gt;TmpAuth.Pass[0] == 0)</code> define WSH_SHELL_USER_IS_AUTH () <code>(pShell-&amp;gt;CurrUser != NULL)</code>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell_8c/#function-wshshell_auth","title":"function WshShell_Auth","text":"<p>Attempt to authenticate a user with given login credentials. <pre><code>WshShell_Bool_t WshShell_Auth (\n    WshShell_t * pShell,\n    const WshShell_Char_t * pcLogin,\n    const WshShell_Char_t * pcPass\n) \n</code></pre></p> <p>Updates the current user context on success, or leaves it unchanged on failure.</p> <p>Parameters:</p> <ul> <li><code>pShell</code> Shell instance. </li> <li><code>pcLogin</code> User name. </li> <li><code>pcPass</code> Password. </li> </ul> <p>Returns:</p> <p>Is auth OK? </p>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#function-wshshell_deauth","title":"function WshShell_DeAuth","text":"<p>De-authenticate the currently logged-in user. <pre><code>void WshShell_DeAuth (\n    WshShell_t * pShell,\n    const WshShell_Char_t * pcReason\n) \n</code></pre></p> <p>Resets the user context and optionally triggers the DeAuth callback.</p> <p>Parameters:</p> <ul> <li><code>pShell</code> Shell instance. </li> <li><code>pcReason</code> Reason or source of deauth. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#function-wshshell_init","title":"function WshShell_Init","text":"<p>Initialize a shell instance. <pre><code>WSH_SHELL_RET_STATE_t WshShell_Init (\n    WshShell_t * pShell,\n    const WshShell_Char_t * pcDevName,\n    const WshShell_Char_t * pcCustomHeader,\n    WshShell_ExtCallbacks_t * pExtClbks\n) \n</code></pre></p> <p>Initializes internal subsystems, assigns device name and optional header, and installs optional external callbacks.</p> <p>Parameters:</p> <ul> <li><code>pShell</code> Pointer to the shell instance. </li> <li><code>pcDevName</code> Device name (e.g., \"ttyS0\" or \"shell0\"). </li> <li><code>pcCustomHeader</code> Optional header string (can be NULL). </li> <li><code>pExtClbks</code> Pointer to external callback structure (can be NULL). </li> </ul> <p>Returns:</p> <p>Initialization status code. </p>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#function-wshshell_insertchar","title":"function WshShell_InsertChar","text":"<p>Process a new character entered by the user. <pre><code>void WshShell_InsertChar (\n    WshShell_t * pShell,\n    const WshShell_Char_t symbol\n) \n</code></pre></p> <p>Handles interactive editing, history navigation, or command execution if input is complete.</p> <p>Parameters:</p> <ul> <li><code>pShell</code> Shell instance. </li> <li><code>symbol</code> Character to insert. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#function-wshshell_isauth","title":"function WshShell_IsAuth","text":"<p>Check if a user is currently authenticated. <pre><code>WshShell_Bool_t WshShell_IsAuth (\n    WshShell_t * pShell\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShell</code> Shell instance. </li> </ul> <p>Returns:</p> <p><code>WSH_SHELL_TRUE</code> if a user is authenticated, <code>WSH_SHELL_FALSE</code> otherwise. </p>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#function-wshshell_stub_extclbk","title":"function WshShell_Stub_ExtClbk","text":"<pre><code>void WshShell_Stub_ExtClbk (\n    void * pCtx\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell_8c/#function-wshshell_authhandler","title":"function WshShell_AuthHandler","text":"<pre><code>static void WshShell_AuthHandler (\n    WshShell_t * pShell\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#function-wshshell_invitationprint","title":"function WshShell_InvitationPrint","text":"<pre><code>static void WshShell_InvitationPrint (\n    WshShell_t * pShell\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#function-wshshell_stringhandler","title":"function WshShell_StringHandler","text":"<pre><code>static void WshShell_StringHandler (\n    WshShell_t * pShell\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#function-wshshell_symbolhandler","title":"function WshShell_SymbolHandler","text":"<pre><code>static void WshShell_SymbolHandler (\n    WshShell_t * pShell,\n    const WshShell_Char_t symbol\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell_8c/#define-shell_save_prev_and_return","title":"define SHELL_SAVE_PREV_AND_RETURN","text":"<pre><code>#define SHELL_SAVE_PREV_AND_RETURN (\n    pShell,\n    sym\n) `/* multi line expression */`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#define-wsh_shell_inter_cmd_exists","title":"define WSH_SHELL_INTER_CMD_EXISTS","text":"<pre><code>#define WSH_SHELL_INTER_CMD_EXISTS (\n\n) `(pShell-&gt;Interact.Handler != NULL)`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#define-wsh_shell_tmp_login_is_empty","title":"define WSH_SHELL_TMP_LOGIN_IS_EMPTY","text":"<pre><code>#define WSH_SHELL_TMP_LOGIN_IS_EMPTY (\n\n) `(pShell-&gt;TmpAuth.Login[0] == 0)`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#define-wsh_shell_tmp_pass_is_empty","title":"define WSH_SHELL_TMP_PASS_IS_EMPTY","text":"<pre><code>#define WSH_SHELL_TMP_PASS_IS_EMPTY (\n\n) `(pShell-&gt;TmpAuth.Pass[0] == 0)`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell_8c/#define-wsh_shell_user_is_auth","title":"define WSH_SHELL_USER_IS_AUTH","text":"<pre><code>#define WSH_SHELL_USER_IS_AUTH (\n\n) `(pShell-&gt;CurrUser != NULL)`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/wsh_shell.c</code></p>"},{"location":"Wsh_Shell_API/wsh__shell_8c_source/","title":"File wsh_shell.c","text":"<p>File List &gt; src &gt; wsh_shell.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"wsh_shell.h\"\n\nvoid WshShell_Stub_ExtClbk(void* pCtx) {\n    (void)pCtx;\n}\n\n#define WSH_SHELL_USER_IS_AUTH()       (pShell-&gt;CurrUser != NULL)\n#define WSH_SHELL_TMP_LOGIN_IS_EMPTY() (pShell-&gt;TmpAuth.Login[0] == 0)\n#define WSH_SHELL_TMP_PASS_IS_EMPTY()  (pShell-&gt;TmpAuth.Pass[0] == 0)\n#define WSH_SHELL_INTER_CMD_EXISTS()   (pShell-&gt;Interact.Handler != NULL)\n\nstatic void WshShell_InvitationPrint(WshShell_t* pShell) {\n    if (!WSH_SHELL_USER_IS_AUTH()) {\n        if (WSH_SHELL_TMP_LOGIN_IS_EMPTY()) {\n            WSH_SHELL_PRINT_SYS(\"Login: \");\n        } else if (WSH_SHELL_TMP_PASS_IS_EMPTY()) {\n            WSH_SHELL_PRINT_SYS(\"Password: \");\n        }\n\n        return;\n    }\n\n    WSH_SHELL_PRINT(pShell-&gt;PS1);\n}\n\nWSH_SHELL_RET_STATE_t WshShell_Init(WshShell_t* pShell, const WshShell_Char_t* pcDevName,\n                                    const WshShell_Char_t* pcCustomHeader,\n                                    WshShell_ExtCallbacks_t* pExtClbks) {\n    WSH_SHELL_ASSERT(pShell &amp;&amp; pcDevName);\n    if (!pShell || !pcDevName)\n        return WSH_SHELL_RET_STATE_ERR_PARAM;\n\n    WSH_SHELL_MEMSET((void*)pShell, 0, sizeof(WshShell_t));\n\n    WshShell_Size_t bufSize = sizeof(pShell-&gt;DeviceName);\n    WshShell_Size_t len     = WSH_SHELL_STRLEN(pcDevName);\n    if (len &gt;= bufSize)\n        len = bufSize - 1;\n\n    WSH_SHELL_MEMCPY(pShell-&gt;DeviceName, pcDevName, len);\n    pShell-&gt;DeviceName[len] = '\\0';\n\n    pShell-&gt;Version = WSH_SHELL_VERSION_STR;\n\n    const WshShell_Size_t numClbks = sizeof(pShell-&gt;ExtCallbacks) / sizeof(WshShell_ExtClbk_t);\n    WshShell_ExtClbk_t* pClbkArr   = (WshShell_ExtClbk_t*)&amp;pShell-&gt;ExtCallbacks;\n\n    if (!pExtClbks) {\n        // Fill all with stub\n        for (WshShell_Size_t clbk = 0; clbk &lt; numClbks; clbk++) {\n            pClbkArr[clbk] = WshShell_Stub_ExtClbk;\n        }\n    } else {\n        // Fill from provided struct\n        WshShell_ExtClbk_t* pInputArr = (WshShell_ExtClbk_t*)pExtClbks;\n        for (WshShell_Size_t clbk = 0; clbk &lt; numClbks; clbk++) {\n            pClbkArr[clbk] = pInputArr[clbk] ? pInputArr[clbk] : WshShell_Stub_ExtClbk;\n        }\n    }\n\n    WSH_SHELL_PRINT(\"%c\", WSH_SHELL_SYM_SOUND);\n    WSH_SHELL_PRINT(WSH_SHELL_COLOR_PURPLE);\n    WSH_SHELL_PRINT(pcCustomHeader ? pcCustomHeader : WSH_SHELL_HEADER);\n    WSH_SHELL_PRINT_SYS(\"Serial Shell Service (wsh-shell v%s) started on device \"\n                        \"(%s)\\r\\n\" WSH_SHELL_PRESS_ENTER_TO_LOG_IN_STR \"\\r\\n\",\n                        pShell-&gt;Version, pShell-&gt;DeviceName);\n\n    WshShellPromptWait_Attach(&amp;(pShell-&gt;PromptWait), WshShellPromptWait_Enter, NULL);\n\n    return WSH_SHELL_RET_STATE_SUCCESS;\n}\n\nWshShell_Bool_t WshShell_Auth(WshShell_t* pShell, const WshShell_Char_t* pcLogin,\n                              const WshShell_Char_t* pcPass) {\n    WSH_SHELL_ASSERT(pShell &amp;&amp; pcLogin &amp;&amp; pcPass);\n    if (!pShell || !pcLogin || !pcPass)\n        return false;\n\n    pShell-&gt;CurrUser = WshShellUser_FindByCredentials(&amp;(pShell-&gt;Users), pcLogin, pcPass);\n    if (WSH_SHELL_USER_IS_AUTH()) {\n        WshShellStr_PS1Data_t data = {\n            .UserName     = pShell-&gt;CurrUser-&gt;Login,\n            .DevName      = pShell-&gt;DeviceName,\n            .InterCmdName = WSH_SHELL_INTER_CMD_EXISTS() ? pShell-&gt;Interact.CmdName : NULL,\n        };\n        WshShellStr_GeneratePS1(pShell-&gt;PS1, &amp;data);\n        pShell-&gt;ExtCallbacks.Auth(NULL);\n        WSH_SHELL_PRINT(\"%c\", WSH_SHELL_SYM_SOUND);\n    }\n\n    WSH_SHELL_MEMSET((void*)pShell-&gt;TmpAuth.Login, 0, WSH_SHELL_LOGIN_LEN);\n    WSH_SHELL_MEMSET((void*)pShell-&gt;TmpAuth.Pass, 0, WSH_SHELL_PASS_LEN);\n\n    return WSH_SHELL_USER_IS_AUTH();\n}\n\nWshShell_Bool_t WshShell_IsAuth(WshShell_t* pShell) {\n    WSH_SHELL_ASSERT(pShell);\n    if (!pShell)\n        return false;\n\n    return (bool)WSH_SHELL_USER_IS_AUTH();\n}\n\nvoid WshShell_DeAuth(WshShell_t* pShell, const WshShell_Char_t* pcReason) {\n    WSH_SHELL_ASSERT(pShell &amp;&amp; pcReason);\n    if (!pShell || !pcReason)\n        return;\n\n    pShell-&gt;CurrUser = NULL;\n    pShell-&gt;ExtCallbacks.DeAuth(NULL);\n    WshShellHistory_Flush(&amp;(pShell-&gt;HistoryIO));\n\n    WSH_SHELL_PRINT(\"%c\", WSH_SHELL_SYM_SOUND);\n    WSH_SHELL_PRINT_ERR(\"Shell deAuthed by `%s`!\\r\\n\", pcReason);\n    WSH_SHELL_PRINT_SYS(WSH_SHELL_PRESS_ENTER_TO_LOG_IN_STR \"\\r\\n\");\n\n    WshShellPromptWait_Attach(&amp;(pShell-&gt;PromptWait), WshShellPromptWait_Enter, NULL);\n}\n\nstatic void WshShell_AuthHandler(WshShell_t* pShell) {\n    WshShell_Size_t len = pShell-&gt;CommandLine.Len;\n    if (len &gt;= WSH_SHELL_LOGIN_LEN)\n        len = WSH_SHELL_LOGIN_LEN - 1;\n\n    if (WSH_SHELL_TMP_LOGIN_IS_EMPTY()) {\n        WSH_SHELL_MEMCPY(pShell-&gt;TmpAuth.Login, pShell-&gt;CommandLine.Buff, len);\n        pShell-&gt;TmpAuth.Login[len] = '\\0';\n    } else if (WSH_SHELL_TMP_PASS_IS_EMPTY()) {\n        WSH_SHELL_MEMCPY(pShell-&gt;TmpAuth.Pass, pShell-&gt;CommandLine.Buff, len);\n        pShell-&gt;TmpAuth.Pass[len] = '\\0';\n    }\n\n    if (!WSH_SHELL_TMP_LOGIN_IS_EMPTY() &amp;&amp; !WSH_SHELL_TMP_PASS_IS_EMPTY()) {\n        WshShell_Bool_t isAuthOk =\n            WshShell_Auth(pShell, pShell-&gt;TmpAuth.Login, pShell-&gt;TmpAuth.Pass);\n\n        if (!isAuthOk)\n            WSH_SHELL_PRINT(\"%c\", WSH_SHELL_SYM_SOUND);\n    }\n\n    WshShellIO_ClearInterBuff(&amp;(pShell-&gt;CommandLine));\n}\n\nstatic void WshShell_StringHandler(WshShell_t* pShell) {\n    pShell-&gt;CommandLine.Buff[pShell-&gt;CommandLine.Len] = 0;\n\n    const WshShell_Char_t* pcCmdStr =\n        WshShellStr_TrimString(pShell-&gt;CommandLine.Buff, pShell-&gt;CommandLine.Len);\n    WshShell_Char_t cmdStr[WSH_SHELL_INTR_BUFF_LEN] = {0};\n    WSH_SHELL_STRNCPY(cmdStr, pcCmdStr, WSH_SHELL_INTR_BUFF_LEN - 1);\n\n    WshShell_Size_t argc                                      = 0;\n    const WshShell_Char_t* p\u0441Argv[WSH_SHELL_CMD_ARGS_MAX_NUM] = {0};\n\n    WshShellStr_ParseToArgcArgv(cmdStr, &amp;argc, p\u0441Argv, WSH_SHELL_CMD_ARGS_MAX_NUM);\n    if (argc == 0)\n        return;\n\n    WshShellHistory_SaveCmd(&amp;(pShell-&gt;HistoryIO), pcCmdStr, WSH_SHELL_STRLEN(pcCmdStr));\n\n    const WshShellCmd_t* pcCmd      = WshShellDefCmd_GetPtr();\n    WshShellCmdHandler_t cmdHandler = NULL;\n\n    if (WSH_SHELL_STRNCMP(pcCmd-&gt;Name, p\u0441Argv[0], WSH_SHELL_CMD_NAME_LEN) == 0) {\n        cmdHandler = pcCmd-&gt;Handler;\n    } else {\n        pcCmd = WshShellCmd_SearchCmd(&amp;(pShell-&gt;Commands), p\u0441Argv[0]);\n        if (pcCmd == NULL) {\n            WSH_SHELL_PRINT_WARN(\"Command \\\"%s\\\" not found!\\r\\n\", pcCmdStr);\n        } else if ((pShell-&gt;CurrUser-&gt;Groups &amp; pcCmd-&gt;Groups) != 0) {\n            cmdHandler = pcCmd-&gt;Handler;\n        } else {\n            WSH_SHELL_PRINT_WARN(\"Access denied for command \\\"%s\\\"\\r\\n\", p\u0441Argv[0]);\n        }\n    }\n\n    if (cmdHandler) {\n        WSH_SHELL_RET_STATE_t retState = cmdHandler(pcCmd, argc, p\u0441Argv, pShell);\n\n        if (WSH_SHELL_INTER_CMD_EXISTS()) {\n            WshShellStr_PS1Data_t data = {\n                .UserName     = pShell-&gt;CurrUser-&gt;Login,\n                .DevName      = pShell-&gt;DeviceName,\n                .InterCmdName = pShell-&gt;Interact.CmdName,\n            };\n            WshShellStr_GeneratePS1(pShell-&gt;PS1, &amp;data);\n        }\n\n        if (retState != WSH_SHELL_RET_STATE_SUCCESS) {\n            WSH_SHELL_PRINT_ERR(\"Command handler internal error: %s\\r\\n\",\n                                WshShell_GetRetStateStr(retState));\n        }\n    }\n\n    WshShellIO_ClearInterBuff(&amp;(pShell-&gt;CommandLine));\n}\n\nstatic void WshShell_SymbolHandler(WshShell_t* pShell, const WshShell_Char_t symbol) {\n    switch (symbol) {\n        case WSH_SHELL_SYM_EXIT:\n            if (WSH_SHELL_INTER_CMD_EXISTS()) {\n                WshShellInteract_Flush(&amp;(pShell-&gt;Interact));\n\n                WshShellStr_PS1Data_t data = {\n                    .UserName     = pShell-&gt;CurrUser-&gt;Login,\n                    .DevName      = pShell-&gt;DeviceName,\n                    .InterCmdName = NULL,\n                };\n                WshShellStr_GeneratePS1(pShell-&gt;PS1, &amp;data);\n                WSH_SHELL_PRINT(WSH_SHELL_END_LINE);\n                WshShell_InvitationPrint(pShell);\n            } else\n                WshShell_DeAuth(pShell, \"Ctrl+D\");\n            break;\n\n        case WSH_SHELL_SYM_BACKSPACE:\n        case WSH_SHELL_SYM_DELETE:\n            WshShellIO_RemoveLeftSymbol(&amp;(pShell-&gt;CommandLine));\n            break;\n\n        case WSH_SHELL_SYM_TAB:\n            if (!WSH_SHELL_USER_IS_AUTH())\n                break;\n\n            if (WshShellAutocomplete_Try(pShell-&gt;CommandLine.Buff, pShell-&gt;CommandLine.Len,\n                                         &amp;(pShell-&gt;Commands))) {\n                WshShellIO_RefreshConsoleFromInterBuff(&amp;(pShell-&gt;CommandLine));\n            } else {\n                WshShell_InvitationPrint(pShell);\n                WshShellIO_PrintInterBuff(&amp;(pShell-&gt;CommandLine));\n            }\n            break;\n\n        case WSH_SHELL_ESC_SEQ_START_CHAR:\n            WshShellEsc_StartSeq(&amp;(pShell-&gt;EscStorage));\n            break;\n\n        default:\n            if (!WshShellStr_IsPrintableAscii(symbol)) {\n                WSH_SHELL_PRINT(\"%c\", WSH_SHELL_SYM_SOUND);\n                return;\n            }\n\n            WshShell_Bool_t starsOrChars =\n                (bool)(!WSH_SHELL_USER_IS_AUTH() &amp;&amp; !WSH_SHELL_TMP_LOGIN_IS_EMPTY());\n            WshShellIO_InsertSymbol(&amp;(pShell-&gt;CommandLine), symbol, starsOrChars);\n            break;\n    }\n}\n\n#define SHELL_SAVE_PREV_AND_RETURN(pShell, sym) \\\n    do {                                        \\\n        (pShell)-&gt;PrevSym = (sym);              \\\n        return;                                 \\\n    } while (0)\n\nvoid WshShell_InsertChar(WshShell_t* pShell, const WshShell_Char_t symbol) {\n    WSH_SHELL_ASSERT(pShell);\n    if (!pShell)\n        return;\n\n    pShell-&gt;ExtCallbacks.SymbolIn(NULL);\n\n    WshShell_Bool_t isEnterPressed = false;\n    if (symbol == WSH_SHELL_CHAR_CR || symbol == WSH_SHELL_CHAR_LF) {\n        if (pShell-&gt;PrevSym == WSH_SHELL_CHAR_CR &amp;&amp; symbol == WSH_SHELL_CHAR_LF) {\n            SHELL_SAVE_PREV_AND_RETURN(pShell, symbol);\n        }\n\n        isEnterPressed = true;\n    }\n\n    WSH_SHELL_RET_STATE_t promptWaitRes = WshShellPromptWait_Handle(&amp;(pShell-&gt;PromptWait), symbol);\n    if (promptWaitRes == WSH_SHELL_RET_STATE_ERR_BUSY) {\n        SHELL_SAVE_PREV_AND_RETURN(pShell, symbol);\n    }\n\n    if (isEnterPressed) {\n        WSH_SHELL_PRINT(WSH_SHELL_END_LINE);\n\n        if (!WSH_SHELL_USER_IS_AUTH()) {\n            WshShell_AuthHandler(pShell);\n            WshShell_InvitationPrint(pShell);\n            SHELL_SAVE_PREV_AND_RETURN(pShell, symbol);\n        }\n\n        if (WSH_SHELL_INTER_CMD_EXISTS()) {\n            pShell-&gt;Interact.Handler(&amp;(pShell-&gt;CommandLine));\n            WshShellIO_ClearInterBuff(&amp;(pShell-&gt;CommandLine));\n        } else\n            WshShell_StringHandler(pShell);\n\n        if (WshShell_IsAuth(pShell))\n            WshShell_InvitationPrint(pShell);\n\n        SHELL_SAVE_PREV_AND_RETURN(pShell, symbol);\n    }\n\n    if (WshShellEsc_IsSeqStarted(&amp;(pShell-&gt;EscStorage))) {\n        WshShellEsc_Handler(&amp;(pShell-&gt;HistoryIO), &amp;(pShell-&gt;CommandLine), &amp;(pShell-&gt;EscStorage),\n                            symbol);\n        SHELL_SAVE_PREV_AND_RETURN(pShell, symbol);\n    }\n\n    WshShell_SymbolHandler(pShell, symbol);\n    SHELL_SAVE_PREV_AND_RETURN(pShell, symbol);\n}\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell_8h/","title":"File wsh_shell.h","text":"<p>FileList &gt; src &gt; wsh_shell.h</p> <p>Go to the source code of this file</p> <p>Core shell interface for command parsing, user authentication, and terminal interaction. More...</p> <ul> <li><code>#include \"wsh_shell_autocomplete.h\"</code></li> <li><code>#include \"wsh_shell_cfg.h\"</code></li> <li><code>#include \"wsh_shell_cmd.h\"</code></li> <li><code>#include \"wsh_shell_cmd_def.h\"</code></li> <li><code>#include \"wsh_shell_esc.h\"</code></li> <li><code>#include \"wsh_shell_history.h\"</code></li> <li><code>#include \"wsh_shell_interact.h\"</code></li> <li><code>#include \"wsh_shell_io.h\"</code></li> <li><code>#include \"wsh_shell_promptwait.h\"</code></li> <li><code>#include \"wsh_shell_str.h\"</code></li> <li><code>#include \"wsh_shell_types.h\"</code></li> <li><code>#include \"wsh_shell_user.h\"</code></li> <li><code>#include \"wsh_shell_version.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell_8h/#classes","title":"Classes","text":"Type Name struct WshShell_AuthContext_t Temporary authentication context for login input handling. struct WshShell_ExtCallbacks_t Optional external callbacks invoked on user session changes. struct WshShell_t Main shell structure containing state, configuration, user context, and subsystems."},{"location":"Wsh_Shell_API/wsh__shell_8h/#public-types","title":"Public Types","text":"Type Name typedef void(* WshShell_ExtClbk_t Type of external callback used in shell extension hooks."},{"location":"Wsh_Shell_API/wsh__shell_8h/#public-functions","title":"Public Functions","text":"Type Name WshShell_Bool_t WshShell_Auth (WshShell_t * pShell, const WshShell_Char_t * pcLogin, const WshShell_Char_t * pcPass) Attempt to authenticate a user with given login credentials. void WshShell_DeAuth (WshShell_t * pShell, const WshShell_Char_t * pcReason) De-authenticate the currently logged-in user. WSH_SHELL_RET_STATE_t WshShell_Init (WshShell_t * pShell, const WshShell_Char_t * pcDevName, const WshShell_Char_t * pcCustomHeader, WshShell_ExtCallbacks_t * pExtClbks) Initialize a shell instance. void WshShell_InsertChar (WshShell_t * pShell, const WshShell_Char_t symbol) Process a new character entered by the user. WshShell_Bool_t WshShell_IsAuth (WshShell_t * pShell) Check if a user is currently authenticated."},{"location":"Wsh_Shell_API/wsh__shell_8h/#detailed-description","title":"Detailed Description","text":"<p>This header provides the main shell object (<code>WshShell_t</code>), core APIs for initialization, input processing, user session management, and support for optional external callbacks.</p> <p>Author:</p> <p>Whoosh Embedded Team </p> <p>Copyright:</p> <p>Copyright (c) 2024 </p>"},{"location":"Wsh_Shell_API/wsh__shell_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell_8h/#typedef-wshshell_extclbk_t","title":"typedef WshShell_ExtClbk_t","text":"<p>Type of external callback used in shell extension hooks. <pre><code>typedef void(* WshShell_ExtClbk_t) (void *pCtx);\n</code></pre></p>"},{"location":"Wsh_Shell_API/wsh__shell_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell_8h/#function-wshshell_auth","title":"function WshShell_Auth","text":"<p>Attempt to authenticate a user with given login credentials. <pre><code>WshShell_Bool_t WshShell_Auth (\n    WshShell_t * pShell,\n    const WshShell_Char_t * pcLogin,\n    const WshShell_Char_t * pcPass\n) \n</code></pre></p> <p>Updates the current user context on success, or leaves it unchanged on failure.</p> <p>Parameters:</p> <ul> <li><code>pShell</code> Shell instance. </li> <li><code>pcLogin</code> User name. </li> <li><code>pcPass</code> Password. </li> </ul> <p>Returns:</p> <p>Is auth OK? </p>"},{"location":"Wsh_Shell_API/wsh__shell_8h/#function-wshshell_deauth","title":"function WshShell_DeAuth","text":"<p>De-authenticate the currently logged-in user. <pre><code>void WshShell_DeAuth (\n    WshShell_t * pShell,\n    const WshShell_Char_t * pcReason\n) \n</code></pre></p> <p>Resets the user context and optionally triggers the DeAuth callback.</p> <p>Parameters:</p> <ul> <li><code>pShell</code> Shell instance. </li> <li><code>pcReason</code> Reason or source of deauth. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell_8h/#function-wshshell_init","title":"function WshShell_Init","text":"<p>Initialize a shell instance. <pre><code>WSH_SHELL_RET_STATE_t WshShell_Init (\n    WshShell_t * pShell,\n    const WshShell_Char_t * pcDevName,\n    const WshShell_Char_t * pcCustomHeader,\n    WshShell_ExtCallbacks_t * pExtClbks\n) \n</code></pre></p> <p>Initializes internal subsystems, assigns device name and optional header, and installs optional external callbacks.</p> <p>Parameters:</p> <ul> <li><code>pShell</code> Pointer to the shell instance. </li> <li><code>pcDevName</code> Device name (e.g., \"ttyS0\" or \"shell0\"). </li> <li><code>pcCustomHeader</code> Optional header string (can be NULL). </li> <li><code>pExtClbks</code> Pointer to external callback structure (can be NULL). </li> </ul> <p>Returns:</p> <p>Initialization status code. </p>"},{"location":"Wsh_Shell_API/wsh__shell_8h/#function-wshshell_insertchar","title":"function WshShell_InsertChar","text":"<p>Process a new character entered by the user. <pre><code>void WshShell_InsertChar (\n    WshShell_t * pShell,\n    const WshShell_Char_t symbol\n) \n</code></pre></p> <p>Handles interactive editing, history navigation, or command execution if input is complete.</p> <p>Parameters:</p> <ul> <li><code>pShell</code> Shell instance. </li> <li><code>symbol</code> Character to insert. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell_8h/#function-wshshell_isauth","title":"function WshShell_IsAuth","text":"<p>Check if a user is currently authenticated. <pre><code>WshShell_Bool_t WshShell_IsAuth (\n    WshShell_t * pShell\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShell</code> Shell instance. </li> </ul> <p>Returns:</p> <p><code>WSH_SHELL_TRUE</code> if a user is authenticated, <code>WSH_SHELL_FALSE</code> otherwise. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell.h</code></p>"},{"location":"Wsh_Shell_API/wsh__shell_8h_source/","title":"File wsh_shell.h","text":"<p>File List &gt; src &gt; wsh_shell.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __WSH_SHELL_H\n#define __WSH_SHELL_H\n\n#include \"wsh_shell_autocomplete.h\"\n#include \"wsh_shell_cfg.h\"\n#include \"wsh_shell_cmd.h\"\n#include \"wsh_shell_cmd_def.h\"\n#include \"wsh_shell_esc.h\"\n#include \"wsh_shell_history.h\"\n#include \"wsh_shell_interact.h\"\n#include \"wsh_shell_io.h\"\n#include \"wsh_shell_promptwait.h\"\n#include \"wsh_shell_str.h\"\n#include \"wsh_shell_types.h\"\n#include \"wsh_shell_user.h\"\n#include \"wsh_shell_version.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef void (*WshShell_ExtClbk_t)(void* pCtx);\n\ntypedef struct {\n    WshShell_ExtClbk_t Auth;     \n    WshShell_ExtClbk_t DeAuth;   \n    WshShell_ExtClbk_t SymbolIn; \n} WshShell_ExtCallbacks_t;\n\ntypedef struct {\n    WshShell_Char_t Login[WSH_SHELL_LOGIN_LEN]; \n    WshShell_Char_t Pass[WSH_SHELL_PASS_LEN];   \n} WshShell_AuthContext_t;\n\ntypedef struct {\n    WshShell_Char_t* Version;                           \n    WshShell_Char_t DeviceName[WSH_SHELL_DEV_NAME_LEN]; \n    WshShell_Char_t PS1[WSH_SHELL_PS1_MAX_LEN];         \n    WshShell_Char_t PrevSym;                            \n    WshShellIO_CommandLine_t CommandLine; \n    const WshShellUser_t* CurrUser;       \n    WshShell_AuthContext_t TmpAuth;       \n    WshShellEsc_Storage_t EscStorage;     \n    WshShellUser_Table_t Users;   \n    WshShellCmd_Table_t Commands; \n    WshShellHistory_IO_t HistoryIO; \n    WshShell_Interact_t Interact;   \n    WshShellPromptWait_t PromptWait;\n\n    WshShell_ExtCallbacks_t ExtCallbacks; \n} WshShell_t;\n\nWSH_SHELL_RET_STATE_t WshShell_Init(WshShell_t* pShell, const WshShell_Char_t* pcDevName,\n                                    const WshShell_Char_t* pcCustomHeader,\n                                    WshShell_ExtCallbacks_t* pExtClbks);\n\nWshShell_Bool_t WshShell_Auth(WshShell_t* pShell, const WshShell_Char_t* pcLogin,\n                              const WshShell_Char_t* pcPass);\n\nWshShell_Bool_t WshShell_IsAuth(WshShell_t* pShell);\n\nvoid WshShell_DeAuth(WshShell_t* pShell, const WshShell_Char_t* pcReason);\n\nvoid WshShell_InsertChar(WshShell_t* pShell, const WshShell_Char_t symbol);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __WSH_SHELL_H */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__autocomplete_8c/","title":"File wsh_shell_autocomplete.c","text":"<p>FileList &gt; src &gt; wsh_shell_autocomplete.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"wsh_shell_autocomplete.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__autocomplete_8c/#public-functions","title":"Public Functions","text":"Type Name WshShell_Bool_t WshShellAutocomplete_Try (WshShell_Char_t * pInBuff, WshShell_Size_t inBuffLen, WshShellCmd_Table_t * pShellCommands) Attempts to autocomplete the command in the input buffer."},{"location":"Wsh_Shell_API/wsh__shell__autocomplete_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__autocomplete_8c/#function-wshshellautocomplete_try","title":"function WshShellAutocomplete_Try","text":"<p>Attempts to autocomplete the command in the input buffer. <pre><code>WshShell_Bool_t WshShellAutocomplete_Try (\n    WshShell_Char_t * pInBuff,\n    WshShell_Size_t inBuffLen,\n    WshShellCmd_Table_t * pShellCommands\n) \n</code></pre></p> <p>Scans the registered command table and tries to match the current input as a prefix. If possible, it autocompletes the input buffer:</p> <ul> <li>If no matches are found, the buffer is not changed.</li> <li>If one match is found, the buffer is completed with the full command name.</li> <li>If multiple matches are found with a shared prefix, the buffer is extended to the longest matchable prefix.</li> </ul> <p>This function is typically triggered by the user pressing the Tab key.</p> <p>Parameters:</p> <ul> <li><code>pInBuff</code> Pointer to the input buffer to modify. </li> <li><code>inBuffLen</code> Total size of the input buffer. </li> <li><code>pShellCommands</code> Pointer to the command table to search.</li> </ul> <p>Return value:</p> <ul> <li><code>true</code> The buffer was modified (i.e., autocomplete was applied). </li> <li><code>false</code> No autocomplete was possible (zero matches or ambiguous match). </li> </ul> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_autocomplete.c</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__autocomplete_8c_source/","title":"File wsh_shell_autocomplete.c","text":"<p>File List &gt; src &gt; wsh_shell_autocomplete.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"wsh_shell_autocomplete.h\"\n\n#if WSH_SHELL_AUTOCOMPLETE\n\nWshShell_Bool_t WshShellAutocomplete_Try(WshShell_Char_t* pInBuff, WshShell_Size_t inBuffLen,\n                                         WshShellCmd_Table_t* pShellCommands) {\n    WSH_SHELL_ASSERT(pInBuff &amp;&amp; pShellCommands);\n    if (!pInBuff || !pShellCommands)\n        return false;\n\n    WshShell_Char_t inputCopy[WSH_SHELL_INTR_BUFF_LEN] = {0};\n    WSH_SHELL_STRNCPY(inputCopy, pInBuff, inBuffLen);\n\n    const WshShell_Char_t* pcInputCopyTrimmed =\n        WshShellStr_TrimString(inputCopy, WSH_SHELL_STRLEN(inputCopy));\n    WshShell_Size_t inputCopyTrimmedLen = WSH_SHELL_STRLEN(pcInputCopyTrimmed);\n\n    const WshShellCmd_t* pcDefCmd = WshShellDefCmd_GetPtr();\n\n    WshShell_Size_t cmdNum = WshShellCmd_GetCmdNum(pShellCommands);\n    WshShell_Char_t candidates[cmdNum + 1][WSH_SHELL_CMD_NAME_LEN];  // + one more for default cmd\n    WshShell_Size_t matchCount      = 0;\n    const WshShellCmd_t* pcCmdMatch = NULL;\n\n    // Check default command first\n    if (WSH_SHELL_STRNCMP(pcInputCopyTrimmed, pcDefCmd-&gt;Name, inputCopyTrimmedLen) == 0) {\n        WSH_SHELL_STRNCPY(candidates[matchCount], pcDefCmd-&gt;Name, WSH_SHELL_CMD_NAME_LEN - 1);\n        candidates[matchCount][WSH_SHELL_CMD_NAME_LEN - 1] = '\\0';  // safety null-term\n        pcCmdMatch                                         = pcDefCmd;\n        matchCount++;\n    }\n\n    // Collect other matching commands\n    for (WshShell_Size_t cmdIdx = 0; cmdIdx &lt; cmdNum; cmdIdx++) {\n        const WshShellCmd_t* pcCmd = WshShellCmd_GetCmdByIndex(pShellCommands, cmdIdx);\n        if (WSH_SHELL_STRNCMP(pcInputCopyTrimmed, pcCmd-&gt;Name, inputCopyTrimmedLen) == 0) {\n            WSH_SHELL_STRNCPY(candidates[matchCount], pcCmd-&gt;Name, WSH_SHELL_CMD_NAME_LEN);\n            pcCmdMatch = pcCmd;\n            matchCount++;\n        }\n    }\n\n    // Create padding buff for pretty message print\n    WshShell_Char_t sysMsgShift[WSH_SHELL_AUTOCOMPLETE_PAD_LEN + 1];\n    WshShell_Size_t padLen = (inBuffLen &lt; WSH_SHELL_AUTOCOMPLETE_PAD_LEN)\n                                 ? (WSH_SHELL_AUTOCOMPLETE_PAD_LEN - inBuffLen)\n                                 : 0;\n    WSH_SHELL_MEMSET((void*)sysMsgShift, WSH_SHELL_AUTOCOMPLETE_PAD_SYM, padLen);\n    sysMsgShift[0]      = ' ';\n    sysMsgShift[padLen] = '\\0';\n\n    // No matches found\n    if (matchCount == 0) {\n        WSH_SHELL_PRINT_SYS(\"%s /autocomplete: no matches\\r\\n\", sysMsgShift);\n        return false;\n    }\n\n    // Exactly one match found \u2014 autocomplete to full command\n    if (matchCount == 1) {\n        //Fetch options if command already autocomplited\n        if (inputCopyTrimmedLen == WSH_SHELL_STRLEN(candidates[0]) &amp;&amp;\n            WSH_SHELL_MEMCMP(pcInputCopyTrimmed, candidates[0], inputCopyTrimmedLen) == 0) {\n            WSH_SHELL_PRINT_SYS(\"%s /autocomplete flags found: \", sysMsgShift);\n\n            const WshShellOption_t* pOpt = pcCmdMatch-&gt;Options;\n            WshShell_Bool_t optFound     = false;\n            for (; pOpt-&gt;Type != WSH_SHELL_OPTION_END; pOpt++) {\n                if (pOpt-&gt;Type == WSH_SHELL_OPTION_NO || pOpt-&gt;Type == WSH_SHELL_OPTION_WAITS_INPUT)\n                    continue;\n\n                optFound = true;\n                WSH_SHELL_PRINT_INFO(\"[%s/%s] \", pOpt-&gt;ShortName, pOpt-&gt;LongName);\n            }\n\n            WSH_SHELL_PRINT_INFO(\"%s\\r\\n\", optFound ? \"\" : \"none\");\n            return false;\n        }\n\n        WshShell_Size_t candLen  = WSH_SHELL_STRLEN(candidates[0]);\n        candidates[0][candLen++] = ' ';  //add extra space if command found\n        WSH_SHELL_STRNCPY(pInBuff, candidates[0], candLen);\n        pInBuff[candLen] = '\\0';\n        return true;\n    }\n\n    // Determine longest common prefix among all matches\n    WshShell_Size_t prefixLen = inBuffLen;\n    WshShell_Bool_t match     = true;\n\n    while (match &amp;&amp; prefixLen &lt; WSH_SHELL_CMD_NAME_LEN) {\n        WshShell_Char_t nextChar = candidates[0][prefixLen];\n        for (WshShell_Size_t cnt = 1; cnt &lt; matchCount; cnt++) {\n            if (candidates[cnt][prefixLen] != nextChar) {\n                match = false;\n                break;\n            }\n        }\n\n        if (match)\n            prefixLen++;\n    }\n\n    // If common prefix is longer than input, extend input\n    if (prefixLen &gt; inBuffLen) {\n        WSH_SHELL_MEMCPY((void*)&amp;pInBuff[inBuffLen], (void*)&amp;candidates[0][inBuffLen],\n                         prefixLen - inBuffLen);\n        pInBuff[prefixLen] = '\\0';\n        return true;\n    }\n\n    // Print all candidates as options\n    WSH_SHELL_PRINT_SYS(\"%s /autocomplete cmd found: \", sysMsgShift);\n    for (WshShell_Size_t cnt = 0; cnt &lt; matchCount; cnt++)\n        WSH_SHELL_PRINT_INFO(\"%s \", candidates[cnt]);\n\n    WSH_SHELL_PRINT(\"\\r\\n\");\n\n    return false;\n}\n\n#else /* WSH_SHELL_AUTOCOMPLETE */\n\nWshShell_Bool_t WshShellAutocomplete_Try(WshShell_Char_t* pInBuff, WshShell_Size_t inBuffLen,\n                                         WshShellCmd_Table_t* pShellCommands) {\n    WSH_SHELL_ASSERT(pInBuff &amp;&amp; pShellCommands);\n    if (!pInBuff || !pShellCommands)\n        return false;\n\n    WshShell_Char_t sysMsgShift[WSH_SHELL_AUTOCOMPLETE_PAD_LEN + 1];\n    WshShell_Size_t padLen = (inBuffLen &lt; WSH_SHELL_AUTOCOMPLETE_PAD_LEN)\n                                 ? (WSH_SHELL_AUTOCOMPLETE_PAD_LEN - inBuffLen)\n                                 : 0;\n    WSH_SHELL_MEMSET((void*)sysMsgShift, WSH_SHELL_AUTOCOMPLETE_PAD_SYM, padLen);\n    sysMsgShift[0]      = ' ';\n    sysMsgShift[padLen] = '\\0';\n\n    WSH_SHELL_PRINT_WARN(\"%s /autocomplete disabled\", sysMsgShift);\n    WSH_SHELL_PRINT(\"\\r\\n\");\n\n    return false;\n}\n\n#endif /* WSH_SHELL_AUTOCOMPLETE */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__autocomplete_8h/","title":"File wsh_shell_autocomplete.h","text":"<p>FileList &gt; src &gt; wsh_shell_autocomplete.h</p> <p>Go to the source code of this file</p> <p>Command-line autocompletion for shell commands. More...</p> <ul> <li><code>#include \"wsh_shell_cfg.h\"</code></li> <li><code>#include \"wsh_shell_cmd.h\"</code></li> <li><code>#include \"wsh_shell_cmd_def.h\"</code></li> <li><code>#include \"wsh_shell_io.h\"</code></li> <li><code>#include \"wsh_shell_str.h\"</code></li> <li><code>#include \"wsh_shell_types.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__autocomplete_8h/#public-functions","title":"Public Functions","text":"Type Name WshShell_Bool_t WshShellAutocomplete_Try (WshShell_Char_t * pInBuff, WshShell_Size_t inBuffLen, WshShellCmd_Table_t * pShellCommands) Attempts to autocomplete the command in the input buffer."},{"location":"Wsh_Shell_API/wsh__shell__autocomplete_8h/#detailed-description","title":"Detailed Description","text":"<p>This module provides autocompletion support for the shell interface. It enables the user to complete partially typed commands based on the currently registered command set. The algorithm performs prefix matching and modifies the input buffer accordingly:</p> <ul> <li>If no match is found, the input remains unchanged.</li> <li>If exactly one match is found, the input is completed with that command.</li> <li>If multiple matches exist with a common prefix, the input is extended to the longest common prefix.</li> </ul> <p>Autocompletion improves user experience and reduces typing effort in shell environments.</p> <p>Author:</p> <p>Whoosh Embedded Team </p> <p>Copyright:</p> <p>Copyright (c) 2025 </p>"},{"location":"Wsh_Shell_API/wsh__shell__autocomplete_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__autocomplete_8h/#function-wshshellautocomplete_try","title":"function WshShellAutocomplete_Try","text":"<p>Attempts to autocomplete the command in the input buffer. <pre><code>WshShell_Bool_t WshShellAutocomplete_Try (\n    WshShell_Char_t * pInBuff,\n    WshShell_Size_t inBuffLen,\n    WshShellCmd_Table_t * pShellCommands\n) \n</code></pre></p> <p>Scans the registered command table and tries to match the current input as a prefix. If possible, it autocompletes the input buffer:</p> <ul> <li>If no matches are found, the buffer is not changed.</li> <li>If one match is found, the buffer is completed with the full command name.</li> <li>If multiple matches are found with a shared prefix, the buffer is extended to the longest matchable prefix.</li> </ul> <p>This function is typically triggered by the user pressing the Tab key.</p> <p>Parameters:</p> <ul> <li><code>pInBuff</code> Pointer to the input buffer to modify. </li> <li><code>inBuffLen</code> Total size of the input buffer. </li> <li><code>pShellCommands</code> Pointer to the command table to search.</li> </ul> <p>Return value:</p> <ul> <li><code>true</code> The buffer was modified (i.e., autocomplete was applied). </li> <li><code>false</code> No autocomplete was possible (zero matches or ambiguous match). </li> </ul> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_autocomplete.h</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__autocomplete_8h_source/","title":"File wsh_shell_autocomplete.h","text":"<p>File List &gt; src &gt; wsh_shell_autocomplete.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __WSH_SHELL_AUTOCOMPLETE_H\n#define __WSH_SHELL_AUTOCOMPLETE_H\n\n#include \"wsh_shell_cfg.h\"\n#include \"wsh_shell_cmd.h\"\n#include \"wsh_shell_cmd_def.h\"\n#include \"wsh_shell_io.h\"\n#include \"wsh_shell_str.h\"\n#include \"wsh_shell_types.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nWshShell_Bool_t WshShellAutocomplete_Try(WshShell_Char_t* pInBuff, WshShell_Size_t inBuffLen,\n                                         WshShellCmd_Table_t* pShellCommands);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __WSH_SHELL_AUTOCOMPLETE_H */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/","title":"File wsh_shell_cfg_def.h","text":"<p>FileList &gt; src &gt; wsh_shell_cfg_def.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"wsh_shell_types.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#public-static-functions","title":"Public Static Functions","text":"Type Name bool WshShellRetState_TranslateToProject (WSH_SHELL_RET_STATE_t state)"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#macros","title":"Macros","text":"Type Name define RET_STATE_MAP_TABLE () <code>/* multi line expression */</code> define WSH_SHELL_ASSERT (exp)  define WSH_SHELL_AUTOCOMPLETE <code>1</code> define WSH_SHELL_AUTOCOMPLETE_PAD_LEN <code>32</code> define WSH_SHELL_AUTOCOMPLETE_PAD_SYM <code>'.'</code> define WSH_SHELL_CMD_ARGS_MAX_NUM <code>16</code> define WSH_SHELL_CMD_GROUP_ADMIN <code>0x01</code> define WSH_SHELL_CMD_GROUP_ALL <code>((WshShell\\_Size\\_t)(~0U))</code> define WSH_SHELL_CMD_GROUP_MAX_COUNT <code>4</code> define WSH_SHELL_CMD_GROUP_NONE <code>0x00</code> define WSH_SHELL_CMD_GROUP_READER <code>0x02</code> define WSH_SHELL_CMD_NAME_LEN <code>16</code> define WSH_SHELL_CMD_OPTIONS_MAX_NUM <code>16</code> define WSH_SHELL_DEV_NAME_LEN <code>16</code> define WSH_SHELL_ESC_BUFF_LEN <code>8</code> define WSH_SHELL_HEADER <code>\"\\                \\_\\_               \\_\\_         \\_\\_\\_\\_  \\r\\n\\ \\_      \\_\\_\\_\\_\\_\\_\\_/ /\\_        \\_\\_\\_\\_\\_/ /\\_  \\_\\_\\_  / / /  \\r\\n\\\\| \\| /\\| / / \\_\\_\\_/ \\_\\_ \\\\\\_\\_\\_\\_\\_\\_/ \\_\\_\\_/ \\_\\_ \\\\/ \\_ \\\\/ / /\\r\\n\\\\| \\|/ \\|/ (\\_\\_  ) / / /\\_\\_\\_\\_\\_(\\_\\_  ) / / /  \\_\\_/ / /    \\r\\n\\\\|\\_\\_/\\|\\_\\_/\\_\\_\\_\\_/\\_/ /\\_/     /\\_\\_\\_\\_/\\_/ /\\_/\\\\\\_\\_\\_/\\_/\\_/    \\r\\n\\\\r\\n\"</code> define WSH_SHELL_HISTORY <code>1</code> define WSH_SHELL_HISTORY_BUFF_SIZE <code>256</code> define WSH_SHELL_INTERACTIVE_MODE <code>1</code> define WSH_SHELL_INTR_BUFF_LEN <code>64</code> define WSH_SHELL_LOGIN_LEN <code>16</code> define WSH_SHELL_MEMCMP (pD, pS, sz) <code>memcmp((pD), (pS), (sz))</code> define WSH_SHELL_MEMCPY (pD, pS, sz) <code>memcpy((pD), (pS), (sz))</code> define WSH_SHELL_MEMSET (pD, c, sz) <code>memset((pD), (c), (sz))</code> define WSH_SHELL_OPTION_LONG_NAME_LEN <code>16</code> define WSH_SHELL_OPTION_SHORT_NAME_LEN <code>2</code> define WSH_SHELL_PASS_LEN <code>16</code> define WSH_SHELL_PRINT (_f_, ...) <code>/* multi line expression */</code> define WSH_SHELL_PRINT_ERR_ENABLE <code>1</code> define WSH_SHELL_PRINT_INFO_ENABLE <code>1</code> define WSH_SHELL_PRINT_OPT_HELP_ENABLE <code>1</code> define WSH_SHELL_PRINT_SYS_ENABLE <code>1</code> define WSH_SHELL_PRINT_WARN_ENABLE <code>1</code> define WSH_SHELL_PS1_CUSTOM <code>1</code> define WSH_SHELL_PS1_MAX_LEN <code>128</code> define WSH_SHELL_PS1_TEMPLATE <code>\"%r%b%c6%d%c7@%c5%u%c2%i %c7&amp;gt; %r%c7\"</code> define WSH_SHELL_SNPRINTF (buf, size, ...) <code>snprintf((buf), (size), \\_\\_VA\\_ARGS\\_\\_)</code> define WSH_SHELL_STRCMP (pS1, pS2) <code>strcmp((pS1), (pS2))</code> define WSH_SHELL_STRCPY (pD, pS) <code>strcpy((pD), (pS))</code> define WSH_SHELL_STRLEN (pS) <code>strlen((pS))</code> define WSH_SHELL_STRNCMP (pS1, pS2, len) <code>strncmp((pS1), (pS2), (len))</code> define WSH_SHELL_STRNCPY (pD, pS, sz) <code>strncpy((pD), (pS), (sz))</code> define WSH_SHELL_STRNLEN (pS, len) <code>strnlen((pS), (len))</code> define WSH_SHELL_STRTOF (pN, pE) <code>strtof((pN), (pE))</code> define WSH_SHELL_STRTOL (pS, pE, radix) <code>strtol((pS), (pE), (radix))</code> define WSH_SHELL_USER_ACCESS_ADMIN <code>(WSH\\_SHELL\\_OPT\\_ACCESS\\_ANY)</code> define WSH_SHELL_USER_ACCESS_READER <code>(WSH\\_SHELL\\_OPT\\_ACCESS\\_ANY)</code> define WSH_SHELL_USER_GROUP_ADMIN <code>(WSH\\_SHELL\\_CMD\\_GROUP\\_ALL)</code> define WSH_SHELL_USER_GROUP_READER <code>(WSH\\_SHELL\\_CMD\\_GROUP\\_READER)</code> define X_MAP_ENTRY (proj, shell) <code>/* multi line expression */</code>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#function-wshshellretstate_translatetoproject","title":"function WshShellRetState_TranslateToProject","text":"<pre><code>static inline bool WshShellRetState_TranslateToProject (\n    WSH_SHELL_RET_STATE_t state\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-ret_state_map_table","title":"define RET_STATE_MAP_TABLE","text":"<pre><code>#define RET_STATE_MAP_TABLE (\n\n) `/* multi line expression */`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_assert","title":"define WSH_SHELL_ASSERT","text":"<pre><code>#define WSH_SHELL_ASSERT (\n    exp\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_autocomplete","title":"define WSH_SHELL_AUTOCOMPLETE","text":"<pre><code>#define WSH_SHELL_AUTOCOMPLETE `1`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_autocomplete_pad_len","title":"define WSH_SHELL_AUTOCOMPLETE_PAD_LEN","text":"<pre><code>#define WSH_SHELL_AUTOCOMPLETE_PAD_LEN `32`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_autocomplete_pad_sym","title":"define WSH_SHELL_AUTOCOMPLETE_PAD_SYM","text":"<pre><code>#define WSH_SHELL_AUTOCOMPLETE_PAD_SYM `'.'`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_cmd_args_max_num","title":"define WSH_SHELL_CMD_ARGS_MAX_NUM","text":"<pre><code>#define WSH_SHELL_CMD_ARGS_MAX_NUM `16`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_cmd_group_admin","title":"define WSH_SHELL_CMD_GROUP_ADMIN","text":"<pre><code>#define WSH_SHELL_CMD_GROUP_ADMIN `0x01`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_cmd_group_all","title":"define WSH_SHELL_CMD_GROUP_ALL","text":"<pre><code>#define WSH_SHELL_CMD_GROUP_ALL `((WshShell_Size_t)(~0U))`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_cmd_group_max_count","title":"define WSH_SHELL_CMD_GROUP_MAX_COUNT","text":"<pre><code>#define WSH_SHELL_CMD_GROUP_MAX_COUNT `4`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_cmd_group_none","title":"define WSH_SHELL_CMD_GROUP_NONE","text":"<pre><code>#define WSH_SHELL_CMD_GROUP_NONE `0x00`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_cmd_group_reader","title":"define WSH_SHELL_CMD_GROUP_READER","text":"<pre><code>#define WSH_SHELL_CMD_GROUP_READER `0x02`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_cmd_name_len","title":"define WSH_SHELL_CMD_NAME_LEN","text":"<pre><code>#define WSH_SHELL_CMD_NAME_LEN `16`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_cmd_options_max_num","title":"define WSH_SHELL_CMD_OPTIONS_MAX_NUM","text":"<pre><code>#define WSH_SHELL_CMD_OPTIONS_MAX_NUM `16`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_dev_name_len","title":"define WSH_SHELL_DEV_NAME_LEN","text":"<pre><code>#define WSH_SHELL_DEV_NAME_LEN `16`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_esc_buff_len","title":"define WSH_SHELL_ESC_BUFF_LEN","text":"<pre><code>#define WSH_SHELL_ESC_BUFF_LEN `8`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_header","title":"define WSH_SHELL_HEADER","text":"<pre><code>#define WSH_SHELL_HEADER `\"\\                __               __         ____  \\r\\n\\ _      _______/ /_        _____/ /_  ___  / / /  \\r\\n\\| | /| / / ___/ __ \\\\______/ ___/ __ \\\\/ _ \\\\/ / /\\r\\n\\| |/ |/ (__  ) / / /_____(__  ) / / /  __/ / /    \\r\\n\\|__/|__/____/_/ /_/     /____/_/ /_/\\\\___/_/_/    \\r\\n\\\\r\\n\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_history","title":"define WSH_SHELL_HISTORY","text":"<pre><code>#define WSH_SHELL_HISTORY `1`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_history_buff_size","title":"define WSH_SHELL_HISTORY_BUFF_SIZE","text":"<pre><code>#define WSH_SHELL_HISTORY_BUFF_SIZE `256`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_interactive_mode","title":"define WSH_SHELL_INTERACTIVE_MODE","text":"<pre><code>#define WSH_SHELL_INTERACTIVE_MODE `1`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_intr_buff_len","title":"define WSH_SHELL_INTR_BUFF_LEN","text":"<pre><code>#define WSH_SHELL_INTR_BUFF_LEN `64`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_login_len","title":"define WSH_SHELL_LOGIN_LEN","text":"<pre><code>#define WSH_SHELL_LOGIN_LEN `16`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_memcmp","title":"define WSH_SHELL_MEMCMP","text":"<pre><code>#define WSH_SHELL_MEMCMP (\n    pD,\n    pS,\n    sz\n) `memcmp((pD), (pS), (sz))`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_memcpy","title":"define WSH_SHELL_MEMCPY","text":"<pre><code>#define WSH_SHELL_MEMCPY (\n    pD,\n    pS,\n    sz\n) `memcpy((pD), (pS), (sz))`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_memset","title":"define WSH_SHELL_MEMSET","text":"<pre><code>#define WSH_SHELL_MEMSET (\n    pD,\n    c,\n    sz\n) `memset((pD), (c), (sz))`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_option_long_name_len","title":"define WSH_SHELL_OPTION_LONG_NAME_LEN","text":"<pre><code>#define WSH_SHELL_OPTION_LONG_NAME_LEN `16`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_option_short_name_len","title":"define WSH_SHELL_OPTION_SHORT_NAME_LEN","text":"<pre><code>#define WSH_SHELL_OPTION_SHORT_NAME_LEN `2`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_pass_len","title":"define WSH_SHELL_PASS_LEN","text":"<pre><code>#define WSH_SHELL_PASS_LEN `16`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_print","title":"define WSH_SHELL_PRINT","text":"<pre><code>#define WSH_SHELL_PRINT (\n    _f_,\n    ...\n) `/* multi line expression */`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_print_err_enable","title":"define WSH_SHELL_PRINT_ERR_ENABLE","text":"<pre><code>#define WSH_SHELL_PRINT_ERR_ENABLE `1`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_print_info_enable","title":"define WSH_SHELL_PRINT_INFO_ENABLE","text":"<pre><code>#define WSH_SHELL_PRINT_INFO_ENABLE `1`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_print_opt_help_enable","title":"define WSH_SHELL_PRINT_OPT_HELP_ENABLE","text":"<pre><code>#define WSH_SHELL_PRINT_OPT_HELP_ENABLE `1`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_print_sys_enable","title":"define WSH_SHELL_PRINT_SYS_ENABLE","text":"<pre><code>#define WSH_SHELL_PRINT_SYS_ENABLE `1`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_print_warn_enable","title":"define WSH_SHELL_PRINT_WARN_ENABLE","text":"<pre><code>#define WSH_SHELL_PRINT_WARN_ENABLE `1`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_ps1_custom","title":"define WSH_SHELL_PS1_CUSTOM","text":"<pre><code>#define WSH_SHELL_PS1_CUSTOM `1`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_ps1_max_len","title":"define WSH_SHELL_PS1_MAX_LEN","text":"<pre><code>#define WSH_SHELL_PS1_MAX_LEN `128`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_ps1_template","title":"define WSH_SHELL_PS1_TEMPLATE","text":"<pre><code>#define WSH_SHELL_PS1_TEMPLATE `\"%r%b%c6%d%c7@%c5%u%c2%i %c7&gt; %r%c7\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_snprintf","title":"define WSH_SHELL_SNPRINTF","text":"<pre><code>#define WSH_SHELL_SNPRINTF (\n    buf,\n    size,\n    ...\n) `snprintf((buf), (size), __VA_ARGS__)`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_strcmp","title":"define WSH_SHELL_STRCMP","text":"<pre><code>#define WSH_SHELL_STRCMP (\n    pS1,\n    pS2\n) `strcmp((pS1), (pS2))`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_strcpy","title":"define WSH_SHELL_STRCPY","text":"<pre><code>#define WSH_SHELL_STRCPY (\n    pD,\n    pS\n) `strcpy((pD), (pS))`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_strlen","title":"define WSH_SHELL_STRLEN","text":"<pre><code>#define WSH_SHELL_STRLEN (\n    pS\n) `strlen((pS))`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_strncmp","title":"define WSH_SHELL_STRNCMP","text":"<pre><code>#define WSH_SHELL_STRNCMP (\n    pS1,\n    pS2,\n    len\n) `strncmp((pS1), (pS2), (len))`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_strncpy","title":"define WSH_SHELL_STRNCPY","text":"<pre><code>#define WSH_SHELL_STRNCPY (\n    pD,\n    pS,\n    sz\n) `strncpy((pD), (pS), (sz))`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_strnlen","title":"define WSH_SHELL_STRNLEN","text":"<pre><code>#define WSH_SHELL_STRNLEN (\n    pS,\n    len\n) `strnlen((pS), (len))`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_strtof","title":"define WSH_SHELL_STRTOF","text":"<pre><code>#define WSH_SHELL_STRTOF (\n    pN,\n    pE\n) `strtof((pN), (pE))`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_strtol","title":"define WSH_SHELL_STRTOL","text":"<pre><code>#define WSH_SHELL_STRTOL (\n    pS,\n    pE,\n    radix\n) `strtol((pS), (pE), (radix))`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_user_access_admin","title":"define WSH_SHELL_USER_ACCESS_ADMIN","text":"<pre><code>#define WSH_SHELL_USER_ACCESS_ADMIN `(WSH_SHELL_OPT_ACCESS_ANY)`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_user_access_reader","title":"define WSH_SHELL_USER_ACCESS_READER","text":"<pre><code>#define WSH_SHELL_USER_ACCESS_READER `(WSH_SHELL_OPT_ACCESS_ANY)`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_user_group_admin","title":"define WSH_SHELL_USER_GROUP_ADMIN","text":"<pre><code>#define WSH_SHELL_USER_GROUP_ADMIN `(WSH_SHELL_CMD_GROUP_ALL)`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-wsh_shell_user_group_reader","title":"define WSH_SHELL_USER_GROUP_READER","text":"<pre><code>#define WSH_SHELL_USER_GROUP_READER `(WSH_SHELL_CMD_GROUP_READER)`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h/#define-x_map_entry","title":"define X_MAP_ENTRY","text":"<pre><code>#define X_MAP_ENTRY (\n    proj,\n    shell\n) `/* multi line expression */`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_cfg_def.h</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__cfg__def_8h_source/","title":"File wsh_shell_cfg_def.h","text":"<p>File List &gt; src &gt; wsh_shell_cfg_def.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __WSH_SHELL_CFG_H\n#define __WSH_SHELL_CFG_H\n\n#include \"wsh_shell_types.h\"\n\n/* \n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n * Shell welcome banner\n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n */\n\n/* clang-format off */\n#define WSH_SHELL_HEADER \"\\\n                __               __         ____  \\r\\n\\\n _      _______/ /_        _____/ /_  ___  / / /  \\r\\n\\\n| | /| / / ___/ __ \\\\______/ ___/ __ \\\\/ _ \\\\/ / /\\r\\n\\\n| |/ |/ (__  ) / / /_____(__  ) / / /  __/ / /    \\r\\n\\\n|__/|__/____/_/ /_/     /____/_/ /_/\\\\___/_/_/    \\r\\n\\\n\\r\\n\"\n/* clang-format on */\n\n/* \n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n * History configuration\n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n */\n#define WSH_SHELL_HISTORY           1\n#define WSH_SHELL_HISTORY_BUFF_SIZE 256\n\n/* \n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n * PS1 line configuration\n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n */\n#define WSH_SHELL_PS1_CUSTOM   1\n#define WSH_SHELL_PS1_TEMPLATE \"%r%b%c6%d%c7@%c5%u%c2%i %c7&gt; %r%c7\"\n#define WSH_SHELL_PS1_MAX_LEN  128\n\n/* \n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n * Command autocompletion\n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n */\n#define WSH_SHELL_AUTOCOMPLETE         1\n#define WSH_SHELL_AUTOCOMPLETE_PAD_LEN 32\n#define WSH_SHELL_AUTOCOMPLETE_PAD_SYM '.'\n\n/* \n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n * Interactive command mode\n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n */\n#define WSH_SHELL_INTERACTIVE_MODE 1\n\n/* \n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n * Print objects customization for minimize shell size\n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n */\n#define WSH_SHELL_PRINT_SYS_ENABLE      1\n#define WSH_SHELL_PRINT_INFO_ENABLE     1\n#define WSH_SHELL_PRINT_WARN_ENABLE     1\n#define WSH_SHELL_PRINT_ERR_ENABLE      1\n#define WSH_SHELL_PRINT_OPT_HELP_ENABLE 1\n\n/* \n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n * Command groups\n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n */\n\n#define WSH_SHELL_CMD_GROUP_NONE      0x00\n#define WSH_SHELL_CMD_GROUP_ALL       ((WshShell_Size_t)(~0U))\n#define WSH_SHELL_CMD_GROUP_MAX_COUNT 4\n\n#define WSH_SHELL_CMD_GROUP_ADMIN  0x01\n#define WSH_SHELL_CMD_GROUP_READER 0x02\n\n#define WSH_SHELL_USER_GROUP_ADMIN  (WSH_SHELL_CMD_GROUP_ALL)\n#define WSH_SHELL_USER_ACCESS_ADMIN (WSH_SHELL_OPT_ACCESS_ANY)\n\n#define WSH_SHELL_USER_GROUP_READER  (WSH_SHELL_CMD_GROUP_READER)\n#define WSH_SHELL_USER_ACCESS_READER (WSH_SHELL_OPT_ACCESS_ANY)\n\n/* \n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n * \n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n */\n\n#define WSH_SHELL_PRINT(_f_, ...)   \\\n    do {                            \\\n        printf(_f_, ##__VA_ARGS__); \\\n        fflush(stdout);             \\\n    } while (0)\n\n/* \n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n * \n * \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \n */\n\n#define WSH_SHELL_DEV_NAME_LEN          16  //Device name max length.\n#define WSH_SHELL_OPTION_SHORT_NAME_LEN 2   //Option short name string max length.\n#define WSH_SHELL_OPTION_LONG_NAME_LEN  16  //Option long name string max length.\n#define WSH_SHELL_CMD_OPTIONS_MAX_NUM   16  //Max amount of founded options in command call string.\n#define WSH_SHELL_CMD_NAME_LEN          16  //Command name string max length.\n#define WSH_SHELL_CMD_ARGS_MAX_NUM      16  //Max amount of arguments for passing in command.\n#define WSH_SHELL_LOGIN_LEN             16  //Max length of a user name\n#define WSH_SHELL_PASS_LEN              16  //Max length of a user password\n#define WSH_SHELL_INTR_BUFF_LEN         64  //Interactive buffer size.\n#define WSH_SHELL_ESC_BUFF_LEN          8   //Escape sequence buffer length.\n\n#ifdef WSH_SHELL_ASSERT_ENABLE\n    #include &lt;assert.h&gt;\n    #include &lt;signal.h&gt;\n\n    #ifndef WSH_SHELL_ASSERT\n        #define WSH_SHELL_ASSERT(exp) \\\n            do {                      \\\n                if (!(exp)) {         \\\n                    raise(SIGTRAP);   \\\n                    while (1) {       \\\n                    }                 \\\n                }                     \\\n            } while (0)\n    #endif /* WSH_SHELL_ASSERT */\n\n#else /* WSH_SHELL_ASSERT_ENABLE */\n\n    #ifndef WSH_SHELL_ASSERT\n        #define WSH_SHELL_ASSERT(exp)\n    #endif /* WSH_SHELL_ASSERT */\n\n#endif /* WSH_SHELL_ASSERT_ENABLE */\n\n#ifndef WSH_SHELL_MEMSET\n    #define WSH_SHELL_MEMSET(pD, c, sz) memset((pD), (c), (sz))\n#endif /* WSH_SHELL_MEMSET */\n\n#ifndef WSH_SHELL_MEMCPY\n    #define WSH_SHELL_MEMCPY(pD, pS, sz) memcpy((pD), (pS), (sz))\n#endif /* WSH_SHELL_MEMCPY */\n\n#ifndef WSH_SHELL_MEMCMP\n    #define WSH_SHELL_MEMCMP(pD, pS, sz) memcmp((pD), (pS), (sz))\n#endif /* WSH_SHELL_MEMCPY */\n\n#ifndef WSH_SHELL_STRCPY\n    #define WSH_SHELL_STRCPY(pD, pS) strcpy((pD), (pS))\n#endif /* WSH_SHELL_STRCPY */\n\n#ifndef WSH_SHELL_STRNCPY\n    #define WSH_SHELL_STRNCPY(pD, pS, sz) strncpy((pD), (pS), (sz))\n#endif /* WSH_SHELL_STRNCPY */\n\n#ifndef WSH_SHELL_STRLEN\n    #define WSH_SHELL_STRLEN(pS) strlen((pS))\n#endif /* WSH_SHELL_STRLEN */\n\n#ifndef WSH_SHELL_STRNLEN\n    #define WSH_SHELL_STRNLEN(pS, len) strnlen((pS), (len))\n#endif /* WSH_SHELL_STRNLEN */\n\n#ifndef WSH_SHELL_STRCMP\n    #define WSH_SHELL_STRCMP(pS1, pS2) strcmp((pS1), (pS2))\n#endif /* WSH_SHELL_STRCMP */\n\n#ifndef WSH_SHELL_STRNCMP\n    #define WSH_SHELL_STRNCMP(pS1, pS2, len) strncmp((pS1), (pS2), (len))\n#endif /* WSH_SHELL_STRNCMP */\n\n#ifndef WSH_SHELL_STRTOL\n    #define WSH_SHELL_STRTOL(pS, pE, radix) strtol((pS), (pE), (radix))\n#endif /* WSH_SHELL_STRTOL */\n\n#ifndef WSH_SHELL_STRTOF\n    #define WSH_SHELL_STRTOF(pN, pE) strtof((pN), (pE))\n#endif /* WSH_SHELL_STRTOF */\n\n#ifndef WSH_SHELL_SNPRINTF\n    #define WSH_SHELL_SNPRINTF(buf, size, ...) snprintf((buf), (size), __VA_ARGS__)\n#endif /* WSH_SHELL_SNPRINTF */\n\n// Project-to-shell enum mapping table\n#define RET_STATE_MAP_TABLE()                            \\\n    X_MAP_ENTRY(true, WSH_SHELL_RET_STATE_SUCCESS)       \\\n    X_MAP_ENTRY(true, WSH_SHELL_RET_STATE_WARNING)       \\\n    X_MAP_ENTRY(false, WSH_SHELL_RET_STATE_ERROR)        \\\n    X_MAP_ENTRY(false, WSH_SHELL_RET_STATE_ERR_EMPTY)    \\\n    X_MAP_ENTRY(false, WSH_SHELL_RET_STATE_ERR_PARAM)    \\\n    X_MAP_ENTRY(false, WSH_SHELL_RET_STATE_ERR_BUSY)     \\\n    X_MAP_ENTRY(false, WSH_SHELL_RET_STATE_ERR_OVERFLOW) \\\n    X_MAP_ENTRY(false, WSH_SHELL_RET_STATE_ERR_MEMORY)   \\\n    X_MAP_ENTRY(false, WSH_SHELL_RET_STATE_ERR_TIMEOUT)  \\\n    X_MAP_ENTRY(false, WSH_SHELL_RET_STATE_ERR_CRC)      \\\n    X_MAP_ENTRY(false, WSH_SHELL_RET_STATE_UNDEF)\n\nstatic inline bool WshShellRetState_TranslateToProject(WSH_SHELL_RET_STATE_t state) {\n    switch (state) {\n#define X_MAP_ENTRY(proj, shell) \\\n    case shell:                  \\\n        return proj;\n        RET_STATE_MAP_TABLE()\n#undef X_MAP_ENTRY\n        default:\n            return false;\n    }\n}\n\n#endif /* __WSH_SHELL_CFG_H */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8c/","title":"File wsh_shell_cmd.c","text":"<p>FileList &gt; src &gt; wsh_shell_cmd.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"wsh_shell_cmd.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8c/#public-functions","title":"Public Functions","text":"Type Name WSH_SHELL_RET_STATE_t WshShellCmd_Attach (WshShellCmd_Table_t * pShellCommands, const WshShellCmd_t * pcCmdTable, WshShell_Size_t cmdNum) Initializes the command table. void WshShellCmd_DeAttach (WshShellCmd_Table_t * pShellCommands) Frees or resets the command table. const WshShellCmd_t * WshShellCmd_GetCmdByIndex (WshShellCmd_Table_t * pShellCommands, WshShell_Size_t idx) Retrieves a command by index. WshShell_Size_t WshShellCmd_GetCmdNum (WshShellCmd_Table_t * pShellCommands) Returns the number of registered commands. WSH_SHELL_RET_STATE_t WshShellCmd_GetOptValue (WshShellOption_Context_t * pOptCtx, WshShell_Size_t argc, const WshShell_Char_t * pArgv, WshShell_Size_t valueSize, void * pValue) Retrieves the value associated with a parsed command option. WshShellOption_Context_t WshShellCmd_ParseOpt (const WshShellCmd_t * pcCmd, WshShell_Size_t argc, const WshShell_Char_t * pArgv, WshShell_Size_t * pTokenPos) Parses a command-line option for a given shell command. void WshShellCmd_PrintInfo (const WshShellCmd_t * pcCmd) Prints detailed information about a shell command and its options. const WshShellCmd_t * WshShellCmd_SearchCmd (WshShellCmd_Table_t * pShellCommands, const WshShell_Char_t * pcCmdName) Finds a command by its name."},{"location":"Wsh_Shell_API/wsh__shell__cmd_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name const WshShellOption_t * WshShellCmd_FindOpt (const WshShellCmd_t * pcCmd, const WshShell_Char_t * pcStr, WshShell_Size_t strLen)"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__cmd_8c/#function-wshshellcmd_attach","title":"function WshShellCmd_Attach","text":"<p>Initializes the command table. <pre><code>WSH_SHELL_RET_STATE_t WshShellCmd_Attach (\n    WshShellCmd_Table_t * pShellCommands,\n    const WshShellCmd_t * pcCmdTable,\n    WshShell_Size_t cmdNum\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShellCommands</code> Pointer to the shell command table. </li> <li><code>pcCmdTable</code> Pointer to the static list of commands. </li> <li><code>cmdNum</code> Number of commands in the list.</li> </ul> <p>Returns:</p> <p>WSH_SHELL_RET_STATE_SUCCESS on success. </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8c/#function-wshshellcmd_deattach","title":"function WshShellCmd_DeAttach","text":"<p>Frees or resets the command table. <pre><code>void WshShellCmd_DeAttach (\n    WshShellCmd_Table_t * pShellCommands\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShellCommands</code> Pointer to the command table. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8c/#function-wshshellcmd_getcmdbyindex","title":"function WshShellCmd_GetCmdByIndex","text":"<p>Retrieves a command by index. <pre><code>const WshShellCmd_t * WshShellCmd_GetCmdByIndex (\n    WshShellCmd_Table_t * pShellCommands,\n    WshShell_Size_t idx\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShellCommands</code> Pointer to the command table. </li> <li><code>idx</code> Command index.</li> </ul> <p>Returns:</p> <p>Pointer to the command descriptor or NULL if out-of-bounds. </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8c/#function-wshshellcmd_getcmdnum","title":"function WshShellCmd_GetCmdNum","text":"<p>Returns the number of registered commands. <pre><code>WshShell_Size_t WshShellCmd_GetCmdNum (\n    WshShellCmd_Table_t * pShellCommands\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShellCommands</code> Pointer to the command table.</li> </ul> <p>Returns:</p> <p>Number of commands. </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8c/#function-wshshellcmd_getoptvalue","title":"function WshShellCmd_GetOptValue","text":"<p>Retrieves the value associated with a parsed command option. <pre><code>WSH_SHELL_RET_STATE_t WshShellCmd_GetOptValue (\n    WshShellOption_Context_t * pOptCtx,\n    WshShell_Size_t argc,\n    const WshShell_Char_t * pArgv,\n    WshShell_Size_t valueSize,\n    void * pValue\n) \n</code></pre></p> <p>This function extracts the value of a command-line option parsed by <code>WshShellCmd_ParseOpt()</code>, based on its type. Supported types include: * <code>WSH_SHELL_OPTION_STR</code> \u2192 copied to <code>pValue</code> as a string * <code>WSH_SHELL_OPTION_INT</code> \u2192 parsed as integer and written to <code>pValue</code> * <code>WSH_SHELL_OPTION_FLOAT</code>\u2192 parsed as float and written to <code>pValue</code></p> <p>The function expects the option to be followed by its value in <code>pArgv</code>. All other option types return <code>WSH_SHELL_RET_STATE_ERR_EMPTY</code>.</p> <p>Parameters:</p> <ul> <li><code>pOptCtx</code> Pointer to parsed option descriptor. </li> <li><code>argc</code> Argument count. </li> <li><code>pArgv</code> Argument vector (array of strings). </li> <li><code>valueSize</code> Maximum size of the output buffer (used for strings). </li> <li><code>pValue</code> Output buffer for value (string/int/float based on type).</li> </ul> <p>Returns:</p> <p>WSH_SHELL_RET_STATE_SUCCESS if value was successfully retrieved, </p> <p>Returns:</p> <p>WSH_SHELL_RET_STATE_ERR_PARAM if input parameters are invalid, </p> <p>Returns:</p> <p>WSH_SHELL_RET_STATE_ERR_EMPTY if the option doesn't accept a value, </p> <p>Returns:</p> <p>WSH_SHELL_RET_STATE_ERR_OVERFLOW if argument list is too short. </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8c/#function-wshshellcmd_parseopt","title":"function WshShellCmd_ParseOpt","text":"<p>Parses a command-line option for a given shell command. <pre><code>WshShellOption_Context_t WshShellCmd_ParseOpt (\n    const WshShellCmd_t * pcCmd,\n    WshShell_Size_t argc,\n    const WshShell_Char_t * pArgv,\n    WshShell_Size_t * pTokenPos\n) \n</code></pre></p> <p>This function analyzes the current token in the argument list and attempts to identify a valid option defined in the given command's option table. If a valid option is found, its descriptor is returned. The token position (<code>*pTokenPos</code>) is advanced accordingly depending on the number of arguments that the option consumes.</p> <p>If only the command name is present (i.e., <code>argc == 1</code>), the function checks for an option of type <code>WSH_SHELL_OPTION_NO</code> (indicating the command may be executed without any parameters).</p> <p>Parameters:</p> <ul> <li><code>pcCmd</code> Pointer to the shell command definition. </li> <li><code>argc</code> Number of arguments in the input array. </li> <li><code>pArgv</code> Array of argument strings. </li> <li><code>pTokenPos</code> Pointer to the current token position in <code>pArgv</code>. Will be updated to point past the parsed option.</li> </ul> <p>Returns:</p> <p>A filled option descriptor if a matching option is found, or an empty descriptor if not. </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8c/#function-wshshellcmd_printinfo","title":"function WshShellCmd_PrintInfo","text":"<p>Prints detailed information about a shell command and its options. <pre><code>void WshShellCmd_PrintInfo (\n    const WshShellCmd_t * pcCmd\n) \n</code></pre></p> <p>This function outputs the help text and a formatted table describing each available option for the specified command. For each option, the following fields are printed: * Short name * Long name * Option type (e.g., INT, STR, FLOAT) * Access flags (read/write/etc.) * Description/help string</p> <p>Options of type <code>WSH_SHELL_OPTION_NO</code> and <code>WSH_SHELL_OPTION_WAITS_INPUT</code> are skipped.</p> <p>This is typically used for displaying help information when a user requests <code>--help</code> for a specific command.</p> <p>Parameters:</p> <ul> <li><code>pcCmd</code> Pointer to the command descriptor whose options should be printed. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8c/#function-wshshellcmd_searchcmd","title":"function WshShellCmd_SearchCmd","text":"<p>Finds a command by its name. <pre><code>const WshShellCmd_t * WshShellCmd_SearchCmd (\n    WshShellCmd_Table_t * pShellCommands,\n    const WshShell_Char_t * pcCmdName\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShellCommands</code> Pointer to the command table. </li> <li><code>pcCmdName</code> Command name string.</li> </ul> <p>Returns:</p> <p>Pointer to the matching command descriptor or NULL if not found. </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__cmd_8c/#function-wshshellcmd_findopt","title":"function WshShellCmd_FindOpt","text":"<pre><code>static const WshShellOption_t * WshShellCmd_FindOpt (\n    const WshShellCmd_t * pcCmd,\n    const WshShell_Char_t * pcStr,\n    WshShell_Size_t strLen\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_cmd.c</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8c_source/","title":"File wsh_shell_cmd.c","text":"<p>File List &gt; src &gt; wsh_shell_cmd.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"wsh_shell_cmd.h\"\n\nWSH_SHELL_RET_STATE_t WshShellCmd_Attach(WshShellCmd_Table_t* pShellCommands,\n                                         const WshShellCmd_t* pcCmdTable[],\n                                         WshShell_Size_t cmdNum) {\n    WSH_SHELL_ASSERT(pShellCommands &amp;&amp; pcCmdTable &amp;&amp; cmdNum &gt; 0);\n    if (!pShellCommands || !pcCmdTable || cmdNum == 0)\n        return WSH_SHELL_RET_STATE_ERR_PARAM;\n\n    if (pShellCommands-&gt;List != NULL)\n        return WSH_SHELL_RET_STATE_ERR_BUSY;  // Already inited\n\n    pShellCommands-&gt;List = pcCmdTable;\n    pShellCommands-&gt;Num  = cmdNum;\n\n    return WSH_SHELL_RET_STATE_SUCCESS;\n}\n\nvoid WshShellCmd_DeAttach(WshShellCmd_Table_t* pShellCommands) {\n    WSH_SHELL_ASSERT(pShellCommands);\n\n    if (pShellCommands)\n        *pShellCommands = (WshShellCmd_Table_t){0};\n}\n\nWshShell_Size_t WshShellCmd_GetCmdNum(WshShellCmd_Table_t* pShellCommands) {\n    WSH_SHELL_ASSERT(pShellCommands);\n\n    if (!pShellCommands || !pShellCommands-&gt;List)\n        return 0;\n\n    return pShellCommands-&gt;Num;\n}\n\nconst WshShellCmd_t* WshShellCmd_GetCmdByIndex(WshShellCmd_Table_t* pShellCommands,\n                                               WshShell_Size_t idx) {\n    WSH_SHELL_ASSERT(pShellCommands);\n    if (!pShellCommands || !pShellCommands-&gt;List)\n        return NULL;\n\n    WSH_SHELL_ASSERT(idx &lt; pShellCommands-&gt;Num);\n\n    return idx &lt; pShellCommands-&gt;Num ? pShellCommands-&gt;List[idx] : NULL;\n}\n\nconst WshShellCmd_t* WshShellCmd_SearchCmd(WshShellCmd_Table_t* pShellCommands,\n                                           const WshShell_Char_t* pcCmdName) {\n    WSH_SHELL_ASSERT(pcCmdName);\n    if (!pcCmdName)\n        return NULL;\n\n    for (WshShell_Size_t cmd = 0; cmd &lt; WshShellCmd_GetCmdNum(pShellCommands); cmd++) {\n        const WshShellCmd_t* pcCmd = WshShellCmd_GetCmdByIndex(pShellCommands, cmd);\n        if (WSH_SHELL_STRNCMP(pcCmd-&gt;Name, pcCmdName, WSH_SHELL_CMD_NAME_LEN) == 0)\n            return pcCmd;\n    }\n\n    return NULL;\n}\n\nstatic const WshShellOption_t* WshShellCmd_FindOpt(const WshShellCmd_t* pcCmd,\n                                                   const WshShell_Char_t* pcStr,\n                                                   WshShell_Size_t strLen) {\n    WSH_SHELL_ASSERT(pcCmd &amp;&amp; pcStr);\n    if (!pcCmd || !pcCmd)\n        return NULL;\n\n    const WshShellOption_t* pcWaitsInputOpt = NULL;\n\n    const WshShellOption_t* pcOpt = pcCmd-&gt;Options;\n    for (; pcOpt-&gt;Type != WSH_SHELL_OPTION_END; pcOpt++) {\n        switch (pcOpt-&gt;Type) {\n            case WSH_SHELL_OPTION_NO:\n                continue;\n\n            case WSH_SHELL_OPTION_WAITS_INPUT:\n                pcWaitsInputOpt = pcOpt;\n                continue;\n\n            default: {\n                const WshShell_Char_t* pRefStr = (strLen == WSH_SHELL_OPTION_SHORT_NAME_LEN)\n                                                     ? pcOpt-&gt;ShortName\n                                                     : pcOpt-&gt;LongName;\n                WshShell_Size_t cmpLen         = (strLen == WSH_SHELL_OPTION_SHORT_NAME_LEN)\n                                                     ? WSH_SHELL_OPTION_SHORT_NAME_LEN\n                                                     : WSH_SHELL_OPTION_LONG_NAME_LEN;\n\n                if (WSH_SHELL_STRNCMP(pRefStr, pcStr, cmpLen) == 0)\n                    return pcOpt;\n            }\n        }\n    }\n\n    return pcWaitsInputOpt;\n}\n\nWshShellOption_Context_t WshShellCmd_ParseOpt(const WshShellCmd_t* pcCmd, WshShell_Size_t argc,\n                                              const WshShell_Char_t* pArgv[],\n                                              WshShell_Size_t* pTokenPos) {\n    WSH_SHELL_ASSERT(pcCmd &amp;&amp; pArgv &amp;&amp; argc &gt; 0 &amp;&amp; pTokenPos);\n    WshShellOption_Context_t optCtx = {0};\n    if (!pcCmd || !pArgv || argc == 0 || !pTokenPos || *pTokenPos &gt;= argc)\n        return optCtx;\n\n    if (argc == 1) {  // Only command without options\n        const WshShellOption_t* pcOpt = pcCmd-&gt;Options;\n        for (; pcOpt-&gt;Type != WSH_SHELL_OPTION_END; pcOpt++) {\n            if (pcOpt-&gt;Type == WSH_SHELL_OPTION_NO) {\n                optCtx.Option = pcOpt;\n                break;\n            }\n        }\n\n        (*pTokenPos)++;\n        return optCtx;\n    }\n\n    if (*pTokenPos == 0)  // Skip command token if not yet skipped\n        (*pTokenPos)++;\n\n    const WshShell_Char_t* pcStr  = pArgv[*pTokenPos];\n    WshShell_Size_t strLen        = WSH_SHELL_STRLEN(pcStr);\n    const WshShellOption_t* pcOpt = WshShellCmd_FindOpt(pcCmd, pcStr, strLen);\n\n    if (pcOpt) {\n        optCtx.Option   = pcOpt;\n        optCtx.TokenPos = *pTokenPos;\n\n        if (pcOpt-&gt;Type == WSH_SHELL_OPTION_WAITS_INPUT) {\n            // Consume all remaining arguments\n            *pTokenPos = argc;\n        } else {\n            *pTokenPos += pcOpt-&gt;ArgNum;\n        }\n    }\n\n    (*pTokenPos)++;\n    return optCtx;\n}\n\nWSH_SHELL_RET_STATE_t WshShellCmd_GetOptValue(WshShellOption_Context_t* pOptCtx,\n                                              WshShell_Size_t argc, const WshShell_Char_t* pArgv[],\n                                              WshShell_Size_t valueSize, void* pValue) {\n    WSH_SHELL_ASSERT(pOptCtx &amp;&amp; pOptCtx-&gt;Option &amp;&amp; pArgv &amp;&amp; pValue &amp;&amp; valueSize);\n    if (!pOptCtx || !pOptCtx-&gt;Option || !pArgv || !pValue || valueSize == 0)\n        return WSH_SHELL_RET_STATE_ERR_PARAM;\n\n    if (argc &lt; 2 || pOptCtx-&gt;TokenPos == 0)\n        return WSH_SHELL_RET_STATE_ERR_EMPTY;\n\n    WshShell_Size_t valIdx = pOptCtx-&gt;TokenPos + 1;\n    if (valIdx &gt;= argc)\n        return WSH_SHELL_RET_STATE_ERR_OVERFLOW;  //FIXME ?\n\n    switch (pOptCtx-&gt;Option-&gt;Type) {\n        case WSH_SHELL_OPTION_STR:\n            WSH_SHELL_STRNCPY((WshShell_Char_t*)pValue, pArgv[valIdx], valueSize);\n            break;\n\n        case WSH_SHELL_OPTION_INT:\n            *((WshShell_Size_t*)pValue) = WSH_SHELL_STRTOL(pArgv[valIdx], NULL, 10);\n            break;\n\n        case WSH_SHELL_OPTION_FLOAT:\n            *((float*)pValue) = WSH_SHELL_STRTOF(pArgv[valIdx], NULL);\n            break;\n\n        case WSH_SHELL_OPTION_NO:\n        case WSH_SHELL_OPTION_HELP:\n        case WSH_SHELL_OPTION_WO_PARAM:\n        case WSH_SHELL_OPTION_MULTI_ARG:\n        case WSH_SHELL_OPTION_WAITS_INPUT:\n        case WSH_SHELL_OPTION_END:\n        case WSH_SHELL_OPTION_ENUM_SIZE:\n        default:\n            return WSH_SHELL_RET_STATE_ERR_EMPTY;\n    }\n\n    return WSH_SHELL_RET_STATE_SUCCESS;\n}\n\nvoid WshShellCmd_PrintInfo(const WshShellCmd_t* pcCmd) {\n    WSH_SHELL_ASSERT(pcCmd);\n    if (!pcCmd)\n        return;\n\n    WSH_SHELL_PRINT_SYS(\"%s\\r\\nOptions overview:\\r\\n\", pcCmd-&gt;Descr);\n\n    const WshShell_Size_t shortNameMaxLen = WSH_SHELL_OPTION_SHORT_NAME_LEN + 5;\n    const WshShell_Size_t longNameMaxLen  = WSH_SHELL_OPTION_LONG_NAME_LEN;\n    const WshShell_Size_t typeMaxLen      = 10;\n    const WshShell_Size_t accessMaxLen    = 6;\n\n    WshShell_Char_t headTemplate[64];\n    WSH_SHELL_SNPRINTF(headTemplate, sizeof(headTemplate),\n                       WSH_SHELL_COLOR_SYS\n                       \"  %%-%ds %%-%ds %%-%ds %%-%ds %%s\\r\\n\" WSH_SHELL_ESC_RESET_STYLE,\n                       shortNameMaxLen, longNameMaxLen, typeMaxLen, accessMaxLen);\n\n    WSH_SHELL_PRINT(headTemplate, \"Short\", \"Long\", \"Type\", \"Access\", \"Descr\");\n\n    WshShell_Char_t rowTemplate[64];\n    WSH_SHELL_SNPRINTF(rowTemplate, sizeof(rowTemplate), \"  %%-%ds %%-%ds %%-%ds %%-%ds %%s\\r\\n\",\n                       shortNameMaxLen, longNameMaxLen, typeMaxLen, accessMaxLen);\n\n    const WshShellOption_t* pcOpt = pcCmd-&gt;Options;\n    for (; pcOpt-&gt;Type != WSH_SHELL_OPTION_END; pcOpt++) {\n        if (pcOpt-&gt;Type == WSH_SHELL_OPTION_NO || pcOpt-&gt;Type == WSH_SHELL_OPTION_WAITS_INPUT)\n            continue;\n\n        WshShell_Char_t accessRow[8];\n        WshShellStr_AccessBitsToStr(pcOpt-&gt;Access, accessRow);\n        WSH_SHELL_PRINT(rowTemplate, pcOpt-&gt;ShortName, pcOpt-&gt;LongName,\n                        WshShell_OptTypeStr_Get(pcOpt-&gt;Type), accessRow, pcOpt-&gt;Descr);\n    }\n}\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/","title":"File wsh_shell_cmd.h","text":"<p>FileList &gt; src &gt; wsh_shell_cmd.h</p> <p>Go to the source code of this file</p> <p>Shell command object definition and public API. More...</p> <ul> <li><code>#include \"wsh_shell_cfg.h\"</code></li> <li><code>#include \"wsh_shell_io.h\"</code></li> <li><code>#include \"wsh_shell_option.h\"</code></li> <li><code>#include \"wsh_shell_str.h\"</code></li> <li><code>#include \"wsh_shell_types.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#classes","title":"Classes","text":"Type Name struct WshShellCmd Descriptor for a shell command. struct WshShellCmd_Table_t Table of shell commands."},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#public-types","title":"Public Types","text":"Type Name typedef WSH_SHELL_RET_STATE_t(* WshShellCmdHandler_t Function pointer type for shell command execution. typedef struct WshShellCmd WshShellCmd_t Descriptor for a shell command."},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#public-functions","title":"Public Functions","text":"Type Name WSH_SHELL_RET_STATE_t WshShellCmd_Attach (WshShellCmd_Table_t * pShellCommands, const WshShellCmd_t * pcCmdTable, WshShell_Size_t cmdNum) Initializes the command table. void WshShellCmd_DeAttach (WshShellCmd_Table_t * pShellCommands) Frees or resets the command table. const WshShellCmd_t * WshShellCmd_GetCmdByIndex (WshShellCmd_Table_t * pShellCommands, WshShell_Size_t idx) Retrieves a command by index. WshShell_Size_t WshShellCmd_GetCmdNum (WshShellCmd_Table_t * pShellCommands) Returns the number of registered commands. WSH_SHELL_RET_STATE_t WshShellCmd_GetOptValue (WshShellOption_Context_t * pOptCtx, WshShell_Size_t argc, const WshShell_Char_t * pArgv, WshShell_Size_t valueSize, void * pValue) Retrieves the value associated with a parsed command option. WshShellOption_Context_t WshShellCmd_ParseOpt (const WshShellCmd_t * pcCmd, WshShell_Size_t argc, const WshShell_Char_t * pArgv, WshShell_Size_t * pTokenPos) Parses a command-line option for a given shell command. void WshShellCmd_PrintInfo (const WshShellCmd_t * pcCmd) Prints detailed information about a shell command and its options. const WshShellCmd_t * WshShellCmd_SearchCmd (WshShellCmd_Table_t * pShellCommands, const WshShell_Char_t * pcCmdName) Finds a command by its name."},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#detailed-description","title":"Detailed Description","text":"<p>Provides data structures and APIs for defining and handling shell commands, including command execution, option parsing, and help information printing.</p> <p>Author:</p> <p>Whoosh Embedded Team </p> <p>Copyright:</p> <p>Copyright (c) 2024 </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#typedef-wshshellcmdhandler_t","title":"typedef WshShellCmdHandler_t","text":"<p>Function pointer type for shell command execution. <pre><code>typedef WSH_SHELL_RET_STATE_t(* WshShellCmdHandler_t) (const struct WshShellCmd *pcCmd, WshShell_Size_t argc, const WshShell_Char_t *pArgv[], void *pCtx);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pcCmd</code> Pointer to the command descriptor. </li> <li><code>argc</code> Number of command-line arguments. </li> <li><code>pArgv</code> Array of argument strings.</li> </ul> <p>Returns:</p> <p>Command execution result (success, error, etc.). </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#typedef-wshshellcmd_t","title":"typedef WshShellCmd_t","text":"<p>Descriptor for a shell command. <pre><code>typedef struct WshShellCmd WshShellCmd_t;\n</code></pre></p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#function-wshshellcmd_attach","title":"function WshShellCmd_Attach","text":"<p>Initializes the command table. <pre><code>WSH_SHELL_RET_STATE_t WshShellCmd_Attach (\n    WshShellCmd_Table_t * pShellCommands,\n    const WshShellCmd_t * pcCmdTable,\n    WshShell_Size_t cmdNum\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShellCommands</code> Pointer to the shell command table. </li> <li><code>pcCmdTable</code> Pointer to the static list of commands. </li> <li><code>cmdNum</code> Number of commands in the list.</li> </ul> <p>Returns:</p> <p>WSH_SHELL_RET_STATE_SUCCESS on success. </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#function-wshshellcmd_deattach","title":"function WshShellCmd_DeAttach","text":"<p>Frees or resets the command table. <pre><code>void WshShellCmd_DeAttach (\n    WshShellCmd_Table_t * pShellCommands\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShellCommands</code> Pointer to the command table. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#function-wshshellcmd_getcmdbyindex","title":"function WshShellCmd_GetCmdByIndex","text":"<p>Retrieves a command by index. <pre><code>const WshShellCmd_t * WshShellCmd_GetCmdByIndex (\n    WshShellCmd_Table_t * pShellCommands,\n    WshShell_Size_t idx\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShellCommands</code> Pointer to the command table. </li> <li><code>idx</code> Command index.</li> </ul> <p>Returns:</p> <p>Pointer to the command descriptor or NULL if out-of-bounds. </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#function-wshshellcmd_getcmdnum","title":"function WshShellCmd_GetCmdNum","text":"<p>Returns the number of registered commands. <pre><code>WshShell_Size_t WshShellCmd_GetCmdNum (\n    WshShellCmd_Table_t * pShellCommands\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShellCommands</code> Pointer to the command table.</li> </ul> <p>Returns:</p> <p>Number of commands. </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#function-wshshellcmd_getoptvalue","title":"function WshShellCmd_GetOptValue","text":"<p>Retrieves the value associated with a parsed command option. <pre><code>WSH_SHELL_RET_STATE_t WshShellCmd_GetOptValue (\n    WshShellOption_Context_t * pOptCtx,\n    WshShell_Size_t argc,\n    const WshShell_Char_t * pArgv,\n    WshShell_Size_t valueSize,\n    void * pValue\n) \n</code></pre></p> <p>This function extracts the value of a command-line option parsed by <code>WshShellCmd_ParseOpt()</code>, based on its type. Supported types include: * <code>WSH_SHELL_OPTION_STR</code> \u2192 copied to <code>pValue</code> as a string * <code>WSH_SHELL_OPTION_INT</code> \u2192 parsed as integer and written to <code>pValue</code> * <code>WSH_SHELL_OPTION_FLOAT</code>\u2192 parsed as float and written to <code>pValue</code></p> <p>The function expects the option to be followed by its value in <code>pArgv</code>. All other option types return <code>WSH_SHELL_RET_STATE_ERR_EMPTY</code>.</p> <p>Parameters:</p> <ul> <li><code>pOptCtx</code> Pointer to parsed option descriptor. </li> <li><code>argc</code> Argument count. </li> <li><code>pArgv</code> Argument vector (array of strings). </li> <li><code>valueSize</code> Maximum size of the output buffer (used for strings). </li> <li><code>pValue</code> Output buffer for value (string/int/float based on type).</li> </ul> <p>Returns:</p> <p>WSH_SHELL_RET_STATE_SUCCESS if value was successfully retrieved, </p> <p>Returns:</p> <p>WSH_SHELL_RET_STATE_ERR_PARAM if input parameters are invalid, </p> <p>Returns:</p> <p>WSH_SHELL_RET_STATE_ERR_EMPTY if the option doesn't accept a value, </p> <p>Returns:</p> <p>WSH_SHELL_RET_STATE_ERR_OVERFLOW if argument list is too short. </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#function-wshshellcmd_parseopt","title":"function WshShellCmd_ParseOpt","text":"<p>Parses a command-line option for a given shell command. <pre><code>WshShellOption_Context_t WshShellCmd_ParseOpt (\n    const WshShellCmd_t * pcCmd,\n    WshShell_Size_t argc,\n    const WshShell_Char_t * pArgv,\n    WshShell_Size_t * pTokenPos\n) \n</code></pre></p> <p>This function analyzes the current token in the argument list and attempts to identify a valid option defined in the given command's option table. If a valid option is found, its descriptor is returned. The token position (<code>*pTokenPos</code>) is advanced accordingly depending on the number of arguments that the option consumes.</p> <p>If only the command name is present (i.e., <code>argc == 1</code>), the function checks for an option of type <code>WSH_SHELL_OPTION_NO</code> (indicating the command may be executed without any parameters).</p> <p>Parameters:</p> <ul> <li><code>pcCmd</code> Pointer to the shell command definition. </li> <li><code>argc</code> Number of arguments in the input array. </li> <li><code>pArgv</code> Array of argument strings. </li> <li><code>pTokenPos</code> Pointer to the current token position in <code>pArgv</code>. Will be updated to point past the parsed option.</li> </ul> <p>Returns:</p> <p>A filled option descriptor if a matching option is found, or an empty descriptor if not. </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#function-wshshellcmd_printinfo","title":"function WshShellCmd_PrintInfo","text":"<p>Prints detailed information about a shell command and its options. <pre><code>void WshShellCmd_PrintInfo (\n    const WshShellCmd_t * pcCmd\n) \n</code></pre></p> <p>This function outputs the help text and a formatted table describing each available option for the specified command. For each option, the following fields are printed: * Short name * Long name * Option type (e.g., INT, STR, FLOAT) * Access flags (read/write/etc.) * Description/help string</p> <p>Options of type <code>WSH_SHELL_OPTION_NO</code> and <code>WSH_SHELL_OPTION_WAITS_INPUT</code> are skipped.</p> <p>This is typically used for displaying help information when a user requests <code>--help</code> for a specific command.</p> <p>Parameters:</p> <ul> <li><code>pcCmd</code> Pointer to the command descriptor whose options should be printed. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h/#function-wshshellcmd_searchcmd","title":"function WshShellCmd_SearchCmd","text":"<p>Finds a command by its name. <pre><code>const WshShellCmd_t * WshShellCmd_SearchCmd (\n    WshShellCmd_Table_t * pShellCommands,\n    const WshShell_Char_t * pcCmdName\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShellCommands</code> Pointer to the command table. </li> <li><code>pcCmdName</code> Command name string.</li> </ul> <p>Returns:</p> <p>Pointer to the matching command descriptor or NULL if not found. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_cmd.h</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd_8h_source/","title":"File wsh_shell_cmd.h","text":"<p>File List &gt; src &gt; wsh_shell_cmd.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __WSH_SHELL_CMD_H\n#define __WSH_SHELL_CMD_H\n\n#include \"wsh_shell_cfg.h\"\n#include \"wsh_shell_io.h\"\n#include \"wsh_shell_option.h\"\n#include \"wsh_shell_str.h\"\n#include \"wsh_shell_types.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Forward declaration of command structure\nstruct WshShellCmd;\n\ntypedef WSH_SHELL_RET_STATE_t (*WshShellCmdHandler_t)(const struct WshShellCmd* pcCmd,\n                                                      WshShell_Size_t argc,\n                                                      const WshShell_Char_t* pArgv[], void* pCtx);\n\ntypedef struct WshShellCmd {\n    const WshShell_Char_t* Name;  \n    const WshShell_Char_t* Descr; \n    WshShell_Size_t Groups; \n    const WshShellOption_t* Options; \n    WshShell_Size_t OptNum;          \n    WshShellCmdHandler_t Handler;    \n} WshShellCmd_t;\n\ntypedef struct {\n    const WshShellCmd_t** List; \n    WshShell_Size_t Num;        \n} WshShellCmd_Table_t;\n\nWSH_SHELL_RET_STATE_t WshShellCmd_Attach(WshShellCmd_Table_t* pShellCommands,\n                                         const WshShellCmd_t* pcCmdTable[], WshShell_Size_t cmdNum);\n\nvoid WshShellCmd_DeAttach(WshShellCmd_Table_t* pShellCommands);\n\nWshShell_Size_t WshShellCmd_GetCmdNum(WshShellCmd_Table_t* pShellCommands);\n\nconst WshShellCmd_t* WshShellCmd_GetCmdByIndex(WshShellCmd_Table_t* pShellCommands,\n                                               WshShell_Size_t idx);\n\nconst WshShellCmd_t* WshShellCmd_SearchCmd(WshShellCmd_Table_t* pShellCommands,\n                                           const WshShell_Char_t* pcCmdName);\n\nWshShellOption_Context_t WshShellCmd_ParseOpt(const WshShellCmd_t* pcCmd, WshShell_Size_t argc,\n                                              const WshShell_Char_t* pArgv[],\n                                              WshShell_Size_t* pTokenPos);\n\nWSH_SHELL_RET_STATE_t WshShellCmd_GetOptValue(WshShellOption_Context_t* pOptCtx,\n                                              WshShell_Size_t argc, const WshShell_Char_t* pArgv[],\n                                              WshShell_Size_t valueSize, void* pValue);\n\nvoid WshShellCmd_PrintInfo(const WshShellCmd_t* pcCmd);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __WSH_SHELL_CMD_H */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/","title":"File wsh_shell_cmd_def.c","text":"<p>FileList &gt; src &gt; wsh_shell_cmd_def.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"wsh_shell_cmd_def.h\"</code></li> <li><code>#include \"wsh_shell.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#public-types","title":"Public Types","text":"Type Name enum WSH_SHELL_DEF_OPT_t Enumeration of supported options for the default shell command."},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name WshShellOption_t OptArr   = <code>{WSH\\_SHELL\\_CMD\\_DEF\\_OPT\\_TABLE()}</code> const WshShellCmd_t WshShellDefCmd   = <code>/* multi line expression */</code>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#public-functions","title":"Public Functions","text":"Type Name WSH_SHELL_RET_STATE_t WshShellCmdDef (const WshShellCmd_t * pcCmd, WshShell_Size_t argc, const WshShell_Char_t * pArgv, void * pCtx)  const WshShellCmd_t * WshShellDefCmd_GetPtr (void) Get a pointer to the default shell command structure."},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name void shell_cmd_def__interactive (WshShellIO_CommandLine_t * pInter)"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#macros","title":"Macros","text":"Type Name define WSH_SHELL_CMD_DEF_OPT_TABLE () <code>/* multi line expression */</code>Macro defining the default shell command options using X-Macros. define X_CMD_ENTRY (en, m) <code>en,</code> define X_CMD_ENTRY (enum, opt) <code>{enum, opt},</code>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#enum-wsh_shell_def_opt_t","title":"enum WSH_SHELL_DEF_OPT_t","text":"<p>Enumeration of supported options for the default shell command. <pre><code>enum WSH_SHELL_DEF_OPT_t {\n    WSH_SHELL_CMD_DEF_OPT_TABLE =() WSH_SHELL_CMD_DEF_OPT_ENUM_SIZE\n};\n</code></pre></p> <p>Each value corresponds to an entry from the WSH_SHELL_CMD_DEF_OPT_TABLE. </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#variable-optarr","title":"variable OptArr","text":"<pre><code>WshShellOption_t OptArr[];\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#variable-wshshelldefcmd","title":"variable WshShellDefCmd","text":"<pre><code>const WshShellCmd_t WshShellDefCmd;\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#function-wshshellcmddef","title":"function WshShellCmdDef","text":"<pre><code>WSH_SHELL_RET_STATE_t WshShellCmdDef (\n    const WshShellCmd_t * pcCmd,\n    WshShell_Size_t argc,\n    const WshShell_Char_t * pArgv,\n    void * pCtx\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#function-wshshelldefcmd_getptr","title":"function WshShellDefCmd_GetPtr","text":"<p>Get a pointer to the default shell command structure. <pre><code>const WshShellCmd_t * WshShellDefCmd_GetPtr (\n    void\n) \n</code></pre></p> <p>This function returns a constant pointer to the static command structure WshShellDefCmd, which describes the default command used for configuring and querying the shell interface.</p> <p>Returns:</p> <p>const WshShellCmd_t* Pointer to the default command structure. </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#function-shell_cmd_def__interactive","title":"function shell_cmd_def__interactive","text":"<pre><code>static void shell_cmd_def__interactive (\n    WshShellIO_CommandLine_t * pInter\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#define-wsh_shell_cmd_def_opt_table","title":"define WSH_SHELL_CMD_DEF_OPT_TABLE","text":"<p>Macro defining the default shell command options using X-Macros. <pre><code>#define WSH_SHELL_CMD_DEF_OPT_TABLE (\n\n) `/* multi line expression */`\n</code></pre></p> <p>This macro expands into a list of <code>X_CMD_ENTRY()</code> calls, each representing an available option for the default shell command. Used for both option structure definitions and enumeration. </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#define-x_cmd_entry","title":"define X_CMD_ENTRY","text":"<pre><code>#define X_CMD_ENTRY (\n    en,\n    m\n) `en,`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c/#define-x_cmd_entry_1","title":"define X_CMD_ENTRY","text":"<pre><code>#define X_CMD_ENTRY (\n    enum,\n    opt\n) `{enum, opt},`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_cmd_def.c</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8c_source/","title":"File wsh_shell_cmd_def.c","text":"<p>File List &gt; src &gt; wsh_shell_cmd_def.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"wsh_shell_cmd_def.h\"\n#include \"wsh_shell.h\"\n\n/* clang-format off */\n#define WSH_SHELL_CMD_DEF_OPT_TABLE() \\\n    X_CMD_ENTRY(WSH_SHELL_DEF_OPT_HELP, WSH_SHELL_OPT_HELP()) \\\n    X_CMD_ENTRY(WSH_SHELL_DEF_OPT_INTERACT, WSH_SHELL_OPT_INTERACT()) \\\n    X_CMD_ENTRY(WSH_SHELL_DEF_OPT_DEF, WSH_SHELL_OPT_NO(WSH_SHELL_OPT_ACCESS_ANY)) \\\n    X_CMD_ENTRY(WSH_SHELL_DEF_OPT_EXEC, WSH_SHELL_OPT_WO_PARAM(WSH_SHELL_OPT_ACCESS_ANY, \"-x\", \"--exec\", \"Get info about accessible commands\")) \\\n    X_CMD_ENTRY(WSH_SHELL_DEF_OPT_USER, WSH_SHELL_OPT_WO_PARAM(WSH_SHELL_OPT_ACCESS_ANY, \"-u\", \"--user\", \"Get info about users\")) \\\n    X_CMD_ENTRY(WSH_SHELL_DEF_OPT_CLS, WSH_SHELL_OPT_WO_PARAM(WSH_SHELL_OPT_ACCESS_ANY, \"-c\", \"--cls\", \"Clear screen\")) \\\n    X_CMD_ENTRY(WSH_SHELL_DEF_OPT_HIST_CLEAR, WSH_SHELL_OPT_WO_PARAM(WSH_SHELL_OPT_ACCESS_ANY, \"-r\", \"--histrst\", \"Reset history storage\")) \\\n    X_CMD_ENTRY(WSH_SHELL_DEF_OPT_HIST_PRINT, WSH_SHELL_OPT_WO_PARAM(WSH_SHELL_OPT_ACCESS_ANY, \"-p\", \"--histprint\", \"Print history storage\")) \\\n    X_CMD_ENTRY(WSH_SHELL_DEF_OPT_DEAUTH, WSH_SHELL_OPT_WO_PARAM(WSH_SHELL_OPT_ACCESS_ANY, \"-d\", \"--deauth\", \"DeAuth and destroy history\")) \\\n    X_CMD_ENTRY(WSH_SHELL_DEF_OPT_END, WSH_SHELL_OPT_END())\n/* clang-format on */\n\ntypedef enum {\n#define X_CMD_ENTRY(en, m) en,\n    WSH_SHELL_CMD_DEF_OPT_TABLE() WSH_SHELL_CMD_DEF_OPT_ENUM_SIZE\n#undef X_CMD_ENTRY\n} WSH_SHELL_DEF_OPT_t;\n\nstatic void shell_cmd_def__interactive(WshShellIO_CommandLine_t* pInter) {\n    WshShellInteract_AppendLineBreak(pInter);\n\n    WSH_SHELL_PRINT(\"Just echo of interactive command: %s\", pInter-&gt;Buff);\n}\n\nWSH_SHELL_RET_STATE_t WshShellCmdDef(const WshShellCmd_t* pcCmd, WshShell_Size_t argc,\n                                     const WshShell_Char_t* pArgv[], void* pCtx) {\n    if ((argc &gt; 0 &amp;&amp; pArgv == NULL) || pcCmd == NULL)\n        return WSH_SHELL_RET_STATE_ERROR;\n\n    WshShell_t* pParentShell       = (WshShell_t*)pCtx;\n    WSH_SHELL_RET_STATE_t retState = WSH_SHELL_RET_STATE_SUCCESS;\n\n    WshShell_Size_t tokenPos = 0;\n    while (tokenPos &lt; argc) {\n        WshShellOption_Context_t optCtx = WshShellCmd_ParseOpt(pcCmd, argc, pArgv, &amp;tokenPos);\n        if (optCtx.Option == NULL) {\n            retState = WSH_SHELL_RET_STATE_ERR_EMPTY;\n            break;\n        }\n\n        switch (optCtx.Option-&gt;ID) {\n            case WSH_SHELL_DEF_OPT_HELP:\n                WshShellCmd_PrintInfo(pcCmd);\n                break;\n\n            case WSH_SHELL_DEF_OPT_DEF:\n                WSH_SHELL_PRINT(\"Ver: %s\\r\\n\", pParentShell-&gt;Version);\n                WSH_SHELL_PRINT(\"Device name: %s\\r\\n\", pParentShell-&gt;DeviceName);\n                WSH_SHELL_PRINT(\"User: %s\\r\\n\", pParentShell-&gt;CurrUser-&gt;Login);\n                break;\n\n            case WSH_SHELL_DEF_OPT_INTERACT:\n                WshShellInteract_Attach(&amp;(pParentShell-&gt;Interact), pcCmd-&gt;Name,\n                                        shell_cmd_def__interactive);\n                break;\n\n            case WSH_SHELL_DEF_OPT_EXEC: {\n                WSH_SHELL_PRINT(\"Availible commans:\\r\\n\");\n\n                const WshShell_Size_t cmdMaxLen   = WSH_SHELL_CMD_NAME_LEN;\n                const WshShell_Size_t optMaxLen   = 5;\n                const WshShell_Size_t groupMaxLen = WSH_SHELL_CMD_GROUP_MAX_COUNT + 3;\n\n                WshShell_Char_t headTemplate[64];\n                WSH_SHELL_SNPRINTF(headTemplate, sizeof(headTemplate),\n                                   WSH_SHELL_COLOR_SYS\n                                   \"  %%-%ds %%-%ds %%-%ds %%s\\r\\n\" WSH_SHELL_ESC_RESET_STYLE,\n                                   cmdMaxLen, optMaxLen, groupMaxLen);\n\n                WSH_SHELL_PRINT(headTemplate, \"Command\", \"Opts\", \"Groups\", \"Descr\");\n\n                WshShell_Char_t rowTemplate[64];\n                WSH_SHELL_SNPRINTF(rowTemplate, sizeof(rowTemplate),\n                                   \"  %%-%ds %%-%dd %%-%ds %%s\\r\\n\", cmdMaxLen, optMaxLen,\n                                   groupMaxLen);\n\n                const WshShellCmd_t* pcDefCmd = WshShellDefCmd_GetPtr();\n                if (pcDefCmd != NULL) {\n                    WshShell_Char_t groupRow[16];\n                    WshShellStr_GroupBitsToStr(pcDefCmd-&gt;Groups, groupRow);\n                    WSH_SHELL_PRINT(rowTemplate, pcDefCmd-&gt;Name, pcDefCmd-&gt;OptNum - 1, groupRow,\n                                    pcDefCmd-&gt;Descr);\n                }\n\n                WshShell_Size_t commandsNum = WshShellCmd_GetCmdNum(&amp;(pParentShell-&gt;Commands));\n                for (WshShell_Size_t cmd = 0; cmd &lt; commandsNum; cmd++) {\n                    const WshShellCmd_t* pcTargetCmd =\n                        WshShellCmd_GetCmdByIndex(&amp;(pParentShell-&gt;Commands), cmd);\n\n                    if (pcTargetCmd == NULL)\n                        continue;\n\n                    WshShell_Char_t groupRow[16];\n                    WshShellStr_GroupBitsToStr(pcTargetCmd-&gt;Groups, groupRow);\n\n                    WSH_SHELL_PRINT(rowTemplate, pcTargetCmd-&gt;Name, pcTargetCmd-&gt;OptNum - 1,\n                                    groupRow, pcTargetCmd-&gt;Descr);\n                }\n            } break;\n\n            case WSH_SHELL_DEF_OPT_USER:\n                WSH_SHELL_PRINT(\"Availible users:\\r\\n\");\n\n                const WshShell_Size_t loginMaxLen  = WSH_SHELL_LOGIN_LEN;\n                const WshShell_Size_t groupMaxLen  = WSH_SHELL_CMD_GROUP_MAX_COUNT + 3;\n                const WshShell_Size_t rightsMaxLen = 6;\n\n                WshShell_Char_t headTemplate[64];\n                WSH_SHELL_SNPRINTF(headTemplate, sizeof(headTemplate),\n                                   WSH_SHELL_COLOR_SYS\n                                   \"  %%-%ds %%-%ds %%-%ds\\r\\n\" WSH_SHELL_ESC_RESET_STYLE,\n                                   loginMaxLen, groupMaxLen, rightsMaxLen);\n\n                WSH_SHELL_PRINT(headTemplate, \"Login\", \"Groups\", \"Rights\");\n\n                WshShell_Char_t rowTemplate[64];\n                WSH_SHELL_SNPRINTF(rowTemplate, sizeof(rowTemplate), \"  %%-%ds %%-%ds %%-%ds\\r\\n\",\n                                   loginMaxLen, groupMaxLen, rightsMaxLen);\n\n                const WshShell_Size_t usersNum = WshShellUser_GetUsersNum(&amp;(pParentShell-&gt;Users));\n                for (WshShell_Size_t user = 0; user &lt; usersNum; user++) {\n                    const WshShellUser_t* pcTargetUser =\n                        WshShellUser_GetUserByIndex(&amp;(pParentShell-&gt;Users), user);\n\n                    if (pcTargetUser == NULL)\n                        continue;\n\n                    WshShell_Char_t groupRow[16];\n                    WshShellStr_GroupBitsToStr(pcTargetUser-&gt;Groups, groupRow);\n\n                    WshShell_Char_t rightsRow[16];\n                    WshShellStr_AccessBitsToStr(pcTargetUser-&gt;Rights, rightsRow);\n\n                    WSH_SHELL_PRINT(rowTemplate, pcTargetUser-&gt;Login, groupRow, rightsRow);\n                }\n                break;\n\n            case WSH_SHELL_DEF_OPT_CLS:\n                WSH_SHELL_PRINT(WSH_SHELL_ECS_CLR_SCREEN);\n                break;\n\n            case WSH_SHELL_DEF_OPT_HIST_CLEAR:\n                WshShellHistory_Flush(&amp;(pParentShell-&gt;HistoryIO));\n                break;\n\n            case WSH_SHELL_DEF_OPT_HIST_PRINT: {\n                WshShell_Char_t cmdBuff[WSH_SHELL_INTR_BUFF_LEN];\n                WshShell_Size_t cmdNum = WshShellHistory_GetTokenNum(&amp;(pParentShell-&gt;HistoryIO));\n\n                WSH_SHELL_PRINT(\"History len: %d\\r\\n\", cmdNum);\n                for (WshShell_Size_t cmdIdx = cmdNum; cmdIdx &gt; 0; cmdIdx--) {\n                    if (WshShellHistory_GetTokenByIndex(&amp;(pParentShell-&gt;HistoryIO), cmdBuff,\n                                                        sizeof(cmdBuff), cmdIdx - 1)) {\n                        WSH_SHELL_PRINT(\"  hist[%2d]: %s\\r\\n\", cmdNum - cmdIdx + 1, cmdBuff);\n                    }\n                }\n            } break;\n\n            case WSH_SHELL_DEF_OPT_DEAUTH:\n                WshShell_DeAuth(pParentShell, \"command\");\n                break;\n\n            default:\n                retState = WSH_SHELL_RET_STATE_ERROR;\n                break;\n        }\n    }\n\n    return retState;\n}\n\n#define X_CMD_ENTRY(enum, opt) {enum, opt},\nstatic WshShellOption_t OptArr[] = {WSH_SHELL_CMD_DEF_OPT_TABLE()};\n#undef X_CMD_ENTRY\n\nstatic const WshShellCmd_t WshShellDefCmd = {\n    .Groups  = WSH_SHELL_CMD_GROUP_ALL,\n    .Name    = \"def\",\n    .Descr   = \"Default command for configuring and querying the shell interface\",\n    .Options = OptArr,\n    .OptNum  = WSH_SHELL_ARR_LEN(OptArr),\n    .Handler = WshShellCmdDef,\n};\n\nconst WshShellCmd_t* WshShellDefCmd_GetPtr(void) {\n    return &amp;WshShellDefCmd;\n}\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8h/","title":"File wsh_shell_cmd_def.h","text":"<p>FileList &gt; src &gt; wsh_shell_cmd_def.h</p> <p>Go to the source code of this file</p> <p>Declaration of default shell commands and their option tables. More...</p> <ul> <li><code>#include \"wsh_shell_cfg.h\"</code></li> <li><code>#include \"wsh_shell_cmd.h\"</code></li> <li><code>#include \"wsh_shell_history.h\"</code></li> <li><code>#include \"wsh_shell_types.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8h/#public-functions","title":"Public Functions","text":"Type Name const WshShellCmd_t * WshShellDefCmd_GetPtr (void) Get a pointer to the default shell command structure."},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8h/#detailed-description","title":"Detailed Description","text":"<p>This header defines macros and functions for registering and executing a set of built-in shell commands. Each command is associated with a predefined option table and an executable handler.</p> <p>These default commands provide core shell functionality such as help, user info, clearing the screen, and managing command history.</p> <p>Author:</p> <p>Whoosh Embedded Team </p> <p>Copyright:</p> <p>Copyright (c) 2025 </p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8h/#function-wshshelldefcmd_getptr","title":"function WshShellDefCmd_GetPtr","text":"<p>Get a pointer to the default shell command structure. <pre><code>const WshShellCmd_t * WshShellDefCmd_GetPtr (\n    void\n) \n</code></pre></p> <p>This function returns a constant pointer to the static command structure WshShellDefCmd, which describes the default command used for configuring and querying the shell interface.</p> <p>Returns:</p> <p>const WshShellCmd_t* Pointer to the default command structure. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_cmd_def.h</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__cmd__def_8h_source/","title":"File wsh_shell_cmd_def.h","text":"<p>File List &gt; src &gt; wsh_shell_cmd_def.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __WSH_SHELL_CMD_DEF_H\n#define __WSH_SHELL_CMD_DEF_H\n\n#include \"wsh_shell_cfg.h\"\n#include \"wsh_shell_cmd.h\"\n#include \"wsh_shell_history.h\"\n#include \"wsh_shell_types.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nconst WshShellCmd_t* WshShellDefCmd_GetPtr(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __WSH_SHELL_CMD_DEF_H */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/","title":"File wsh_shell_esc.c","text":"<p>FileList &gt; src &gt; wsh_shell_esc.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"wsh_shell_esc.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const WshShellEsc_Action_t WshShellEsc_SeqHandlers   = <code>/* multi line expression */</code>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/#public-functions","title":"Public Functions","text":"Type Name void WshShellEsc_Handler (WshShellHistory_IO_t * pHistIO, WshShellIO_CommandLine_t * pCommandLine, WshShellEsc_Storage_t * pEscStorage, const WshShell_Char_t symbol) Handles incoming escape sequence character. WshShell_Bool_t WshShellEsc_IsSeqStarted (WshShellEsc_Storage_t * pEscStorage) Checks if escape sequence is in progress. void WshShellEsc_StartSeq (WshShellEsc_Storage_t * pEscStorage) Starts a new escape sequence."},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/#public-static-functions","title":"Public Static Functions","text":"Type Name void WshShellEsc_ArrowDown (WshShellHistory_IO_t * pHistIO, WshShellIO_CommandLine_t * pCommandLine)  void WshShellEsc_ArrowLeft (WshShellHistory_IO_t * pHistIO, WshShellIO_CommandLine_t * pCommandLine)  void WshShellEsc_ArrowRight (WshShellHistory_IO_t * pHistIO, WshShellIO_CommandLine_t * pCommandLine)  void WshShellEsc_ArrowUp (WshShellHistory_IO_t * pHistIO, WshShellIO_CommandLine_t * pCommandLine)  void WshShellEsc_ClearStorage (WshShellEsc_Storage_t * pEscStorage)"},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/#variable-wshshellesc_seqhandlers","title":"variable WshShellEsc_SeqHandlers","text":"<pre><code>const WshShellEsc_Action_t WshShellEsc_SeqHandlers[];\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/#function-wshshellesc_handler","title":"function WshShellEsc_Handler","text":"<p>Handles incoming escape sequence character. <pre><code>void WshShellEsc_Handler (\n    WshShellHistory_IO_t * pHistIO,\n    WshShellIO_CommandLine_t * pCommandLine,\n    WshShellEsc_Storage_t * pEscStorage,\n    const WshShell_Char_t symbol\n) \n</code></pre></p> <p>Matches current buffer against known ANSI sequences and triggers appropriate handler.</p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to shell history interface </li> <li><code>pCommandLine</code> Pointer to input interaction buffer </li> <li><code>pEscStorage</code> Pointer to escape sequence buffer </li> <li><code>symbol</code> Incoming character to append </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/#function-wshshellesc_isseqstarted","title":"function WshShellEsc_IsSeqStarted","text":"<p>Checks if escape sequence is in progress. <pre><code>WshShell_Bool_t WshShellEsc_IsSeqStarted (\n    WshShellEsc_Storage_t * pEscStorage\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pEscStorage</code> Pointer to escape sequence buffer </li> </ul> <p>Returns:</p> <p>WshShell_Bool_t <code>true</code> if sequence has started </p>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/#function-wshshellesc_startseq","title":"function WshShellEsc_StartSeq","text":"<p>Starts a new escape sequence. <pre><code>void WshShellEsc_StartSeq (\n    WshShellEsc_Storage_t * pEscStorage\n) \n</code></pre></p> <p>Initializes the escape buffer with ESC char.</p> <p>Parameters:</p> <ul> <li><code>pEscStorage</code> Pointer to escape sequence buffer </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/#function-wshshellesc_arrowdown","title":"function WshShellEsc_ArrowDown","text":"<pre><code>static void WshShellEsc_ArrowDown (\n    WshShellHistory_IO_t * pHistIO,\n    WshShellIO_CommandLine_t * pCommandLine\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/#function-wshshellesc_arrowleft","title":"function WshShellEsc_ArrowLeft","text":"<pre><code>static void WshShellEsc_ArrowLeft (\n    WshShellHistory_IO_t * pHistIO,\n    WshShellIO_CommandLine_t * pCommandLine\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/#function-wshshellesc_arrowright","title":"function WshShellEsc_ArrowRight","text":"<pre><code>static void WshShellEsc_ArrowRight (\n    WshShellHistory_IO_t * pHistIO,\n    WshShellIO_CommandLine_t * pCommandLine\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/#function-wshshellesc_arrowup","title":"function WshShellEsc_ArrowUp","text":"<pre><code>static void WshShellEsc_ArrowUp (\n    WshShellHistory_IO_t * pHistIO,\n    WshShellIO_CommandLine_t * pCommandLine\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8c/#function-wshshellesc_clearstorage","title":"function WshShellEsc_ClearStorage","text":"<pre><code>static void WshShellEsc_ClearStorage (\n    WshShellEsc_Storage_t * pEscStorage\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_esc.c</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8c_source/","title":"File wsh_shell_esc.c","text":"<p>File List &gt; src &gt; wsh_shell_esc.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"wsh_shell_esc.h\"\n\nstatic void WshShellEsc_ArrowUp(WshShellHistory_IO_t* pHistIO,\n                                WshShellIO_CommandLine_t* pCommandLine) {\n    WSH_SHELL_ASSERT(pHistIO &amp;&amp; pCommandLine);\n    if (!pHistIO || !pCommandLine)\n        return;\n\n    WshShellHistory_GetPrevCmd(pHistIO, pCommandLine-&gt;Buff, WSH_SHELL_INTR_BUFF_LEN);\n    WshShellIO_RefreshConsoleFromInterBuff(pCommandLine);\n}\n\nstatic void WshShellEsc_ArrowDown(WshShellHistory_IO_t* pHistIO,\n                                  WshShellIO_CommandLine_t* pCommandLine) {\n    WSH_SHELL_ASSERT(pHistIO &amp;&amp; pCommandLine);\n    if (!pHistIO || !pCommandLine)\n        return;\n\n    WshShellHistory_GetNextCmd(pHistIO, pCommandLine-&gt;Buff, WSH_SHELL_INTR_BUFF_LEN);\n    WshShellIO_RefreshConsoleFromInterBuff(pCommandLine);\n}\n\nstatic void WshShellEsc_ArrowRight(WshShellHistory_IO_t* pHistIO,\n                                   WshShellIO_CommandLine_t* pCommandLine) {\n    (void)pHistIO;\n\n    WSH_SHELL_ASSERT(pCommandLine);\n    if (!pCommandLine)\n        return;\n\n    if (pCommandLine-&gt;CursorPos &lt; pCommandLine-&gt;Len) {\n        WSH_SHELL_PRINT(WSH_SHELL_ESC_ARROW_RIGHT);\n        WshShellStr_IncrInterCnt(&amp;(pCommandLine-&gt;CursorPos), WSH_SHELL_INTR_BUFF_LEN);\n    }\n}\n\nstatic void WshShellEsc_ArrowLeft(WshShellHistory_IO_t* pHistIO,\n                                  WshShellIO_CommandLine_t* pCommandLine) {\n    (void)pHistIO;\n\n    WSH_SHELL_ASSERT(pCommandLine);\n    if (!pCommandLine)\n        return;\n\n    if (pCommandLine-&gt;CursorPos &gt; 0) {\n        WSH_SHELL_PRINT(WSH_SHELL_ESC_ARROW_LEFT);\n        WshShellStr_DecrInterCnt(&amp;(pCommandLine-&gt;CursorPos));\n    }\n}\n\nstatic void WshShellEsc_ClearStorage(WshShellEsc_Storage_t* pEscStorage) {\n    WSH_SHELL_ASSERT(pEscStorage);\n    if (!pEscStorage)\n        return;\n\n    WSH_SHELL_MEMSET((void*)pEscStorage-&gt;Buff, 0, WSH_SHELL_ESC_BUFF_LEN);\n    pEscStorage-&gt;Cnt = 0;\n}\n\nstatic const WshShellEsc_Action_t WshShellEsc_SeqHandlers[] = {\n    {WSH_SHELL_ESC_ARROW_UP, WshShellEsc_ArrowUp},\n    {WSH_SHELL_ESC_ARROW_DOWN, WshShellEsc_ArrowDown},\n    {WSH_SHELL_ESC_ARROW_LEFT, WshShellEsc_ArrowLeft},\n    {WSH_SHELL_ESC_ARROW_RIGHT, WshShellEsc_ArrowRight},\n};\n\nvoid WshShellEsc_Handler(WshShellHistory_IO_t* pHistIO, WshShellIO_CommandLine_t* pCommandLine,\n                         WshShellEsc_Storage_t* pEscStorage, const WshShell_Char_t symbol) {\n    WSH_SHELL_ASSERT(pHistIO &amp;&amp; pCommandLine &amp;&amp; pEscStorage);\n    if (!pHistIO || !pCommandLine || !pEscStorage)\n        return;\n\n    if (pEscStorage-&gt;Cnt &gt;= WSH_SHELL_ESC_BUFF_LEN)\n        return;\n\n    pEscStorage-&gt;Buff[pEscStorage-&gt;Cnt++] = symbol;\n\n    for (WshShell_Size_t seq = 0; seq &lt; WSH_SHELL_ARR_LEN(WshShellEsc_SeqHandlers); seq++) {\n        if (WSH_SHELL_STRNCMP(WshShellEsc_SeqHandlers[seq].Sequence, pEscStorage-&gt;Buff,\n                              WSH_SHELL_ESC_BUFF_LEN) == 0) {\n            WshShellEsc_SeqHandlers[seq].Handler(pHistIO, pCommandLine);\n            WshShellEsc_ClearStorage(pEscStorage);\n            break;\n        }\n    }\n}\n\nvoid WshShellEsc_StartSeq(WshShellEsc_Storage_t* pEscStorage) {\n    WSH_SHELL_ASSERT(pEscStorage);\n    if (!pEscStorage)\n        return;\n\n    pEscStorage-&gt;Cnt     = 1;\n    pEscStorage-&gt;Buff[0] = WSH_SHELL_ESC_SEQ_START_CHAR;\n}\n\nWshShell_Bool_t WshShellEsc_IsSeqStarted(WshShellEsc_Storage_t* pEscStorage) {\n    WSH_SHELL_ASSERT(pEscStorage);\n    if (!pEscStorage)\n        return false;\n\n    return (WshShell_Bool_t)(pEscStorage-&gt;Cnt &gt; 0 &amp;&amp;\n                             pEscStorage-&gt;Buff[0] == WSH_SHELL_ESC_SEQ_START_CHAR);\n}\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8h/","title":"File wsh_shell_esc.h","text":"<p>FileList &gt; src &gt; wsh_shell_esc.h</p> <p>Go to the source code of this file</p> <p>Escape sequence handling logic for WSH shell. More...</p> <ul> <li><code>#include \"wsh_shell_cfg.h\"</code></li> <li><code>#include \"wsh_shell_history.h\"</code></li> <li><code>#include \"wsh_shell_io.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8h/#classes","title":"Classes","text":"Type Name struct WshShellEsc_Action_t Escape sequence to handler mapping. struct WshShellEsc_Storage_t Escape sequence input state tracker."},{"location":"Wsh_Shell_API/wsh__shell__esc_8h/#public-types","title":"Public Types","text":"Type Name typedef void(* WshShellEsc_Hadler_t Escape sequence handler function type."},{"location":"Wsh_Shell_API/wsh__shell__esc_8h/#public-functions","title":"Public Functions","text":"Type Name void WshShellEsc_Handler (WshShellHistory_IO_t * pHistIO, WshShellIO_CommandLine_t * pCommandLine, WshShellEsc_Storage_t * pEscStorage, const WshShell_Char_t symbol) Handles incoming escape sequence character. WshShell_Bool_t WshShellEsc_IsSeqStarted (WshShellEsc_Storage_t * pEscStorage) Checks if escape sequence is in progress. void WshShellEsc_StartSeq (WshShellEsc_Storage_t * pEscStorage) Starts a new escape sequence."},{"location":"Wsh_Shell_API/wsh__shell__esc_8h/#detailed-description","title":"Detailed Description","text":"<p>Provides functionality to process ANSI escape sequences (e.g., arrow keys) and interact with shell history and input buffer.</p> <p>Author:</p> <p>Whoosh Embedded Team </p> <p>Copyright:</p> <p>Copyright (c) 2025 </p>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__esc_8h/#typedef-wshshellesc_hadler_t","title":"typedef WshShellEsc_Hadler_t","text":"<p>Escape sequence handler function type. <pre><code>typedef void(* WshShellEsc_Hadler_t) (WshShellHistory_IO_t *pHistIO, WshShellIO_CommandLine_t *pCommandLine);\n</code></pre></p>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__esc_8h/#function-wshshellesc_handler","title":"function WshShellEsc_Handler","text":"<p>Handles incoming escape sequence character. <pre><code>void WshShellEsc_Handler (\n    WshShellHistory_IO_t * pHistIO,\n    WshShellIO_CommandLine_t * pCommandLine,\n    WshShellEsc_Storage_t * pEscStorage,\n    const WshShell_Char_t symbol\n) \n</code></pre></p> <p>Matches current buffer against known ANSI sequences and triggers appropriate handler.</p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to shell history interface </li> <li><code>pCommandLine</code> Pointer to input interaction buffer </li> <li><code>pEscStorage</code> Pointer to escape sequence buffer </li> <li><code>symbol</code> Incoming character to append </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8h/#function-wshshellesc_isseqstarted","title":"function WshShellEsc_IsSeqStarted","text":"<p>Checks if escape sequence is in progress. <pre><code>WshShell_Bool_t WshShellEsc_IsSeqStarted (\n    WshShellEsc_Storage_t * pEscStorage\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pEscStorage</code> Pointer to escape sequence buffer </li> </ul> <p>Returns:</p> <p>WshShell_Bool_t <code>true</code> if sequence has started </p>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8h/#function-wshshellesc_startseq","title":"function WshShellEsc_StartSeq","text":"<p>Starts a new escape sequence. <pre><code>void WshShellEsc_StartSeq (\n    WshShellEsc_Storage_t * pEscStorage\n) \n</code></pre></p> <p>Initializes the escape buffer with ESC char.</p> <p>Parameters:</p> <ul> <li><code>pEscStorage</code> Pointer to escape sequence buffer </li> </ul> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_esc.h</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__esc_8h_source/","title":"File wsh_shell_esc.h","text":"<p>File List &gt; src &gt; wsh_shell_esc.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __WSH_SHELL_ESC_H\n#define __WSH_SHELL_ESC_H\n\n#include \"wsh_shell_cfg.h\"\n#include \"wsh_shell_history.h\"\n#include \"wsh_shell_io.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef void (*WshShellEsc_Hadler_t)(WshShellHistory_IO_t* pHistIO,\n                                     WshShellIO_CommandLine_t* pCommandLine);\n\ntypedef struct {\n    const WshShell_Char_t* Sequence; \n    WshShellEsc_Hadler_t Handler;    \n} WshShellEsc_Action_t;\n\ntypedef struct {\n    WshShell_Size_t Cnt;                          \n    WshShell_Char_t Buff[WSH_SHELL_ESC_BUFF_LEN]; \n} WshShellEsc_Storage_t;\n\nvoid WshShellEsc_Handler(WshShellHistory_IO_t* pHistIO, WshShellIO_CommandLine_t* pCommandLine,\n                         WshShellEsc_Storage_t* pEscStorage, const WshShell_Char_t symbol);\n\nvoid WshShellEsc_StartSeq(WshShellEsc_Storage_t* pEscStorage);\n\nWshShell_Bool_t WshShellEsc_IsSeqStarted(WshShellEsc_Storage_t* pEscStorage);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __WSH_SHELL_ESC_H */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__history_8c/","title":"File wsh_shell_history.c","text":"<p>FileList &gt; src &gt; wsh_shell_history.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"wsh_shell_history.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__history_8c/#public-functions","title":"Public Functions","text":"Type Name void WshShellHistory_Flush (WshShellHistory_IO_t * pHistIO) Clear the command history buffer. WshShell_Size_t WshShellHistory_GetNextCmd (WshShellHistory_IO_t * pHistIO, WshShell_Char_t * pOutBuff, WshShell_Size_t outBuffSize) Retrieve the next command from history. WshShell_Size_t WshShellHistory_GetPrevCmd (WshShellHistory_IO_t * pHistIO, WshShell_Char_t * pOutBuff, WshShell_Size_t outBuffSize) Retrieve the previous command from history. WshShell_Size_t WshShellHistory_GetTokenByIndex (WshShellHistory_IO_t * pHistIO, WshShell_Char_t * pOutBuff, WshShell_Size_t outBuffSize, WshShell_Size_t index) Retrieve a command from history by its index. WshShell_Size_t WshShellHistory_GetTokenNum (WshShellHistory_IO_t * pHistIO) Get the total number of commands stored in history. void WshShellHistory_Init (WshShellHistory_IO_t * pHistIO, WshShellHistory_ReadHandler_t readFn, WshShellHistory_WriteHandler_t writeFn) Initialize the shell history system with custom I/O functions. void WshShellHistory_SaveCmd (WshShellHistory_IO_t * pHistIO, const WshShell_Char_t * pcCmdStr, WshShell_Size_t cmdStrLen) Save a new command to the history buffer."},{"location":"Wsh_Shell_API/wsh__shell__history_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__history_8c/#function-wshshellhistory_flush","title":"function WshShellHistory_Flush","text":"<p>Clear the command history buffer. <pre><code>void WshShellHistory_Flush (\n    WshShellHistory_IO_t * pHistIO\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to the I/O structure. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__history_8c/#function-wshshellhistory_getnextcmd","title":"function WshShellHistory_GetNextCmd","text":"<p>Retrieve the next command from history. <pre><code>WshShell_Size_t WshShellHistory_GetNextCmd (\n    WshShellHistory_IO_t * pHistIO,\n    WshShell_Char_t * pOutBuff,\n    WshShell_Size_t outBuffSize\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to the I/O structure. </li> <li><code>pOutBuff</code> Buffer to store the command string. </li> <li><code>outBuffSize</code> Size of the output buffer.</li> </ul> <p>Returns:</p> <p>Length of the retrieved command. </p>"},{"location":"Wsh_Shell_API/wsh__shell__history_8c/#function-wshshellhistory_getprevcmd","title":"function WshShellHistory_GetPrevCmd","text":"<p>Retrieve the previous command from history. <pre><code>WshShell_Size_t WshShellHistory_GetPrevCmd (\n    WshShellHistory_IO_t * pHistIO,\n    WshShell_Char_t * pOutBuff,\n    WshShell_Size_t outBuffSize\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to the I/O structure. </li> <li><code>pOutBuff</code> Buffer to store the command string. </li> <li><code>outBuffSize</code> Size of the output buffer.</li> </ul> <p>Returns:</p> <p>Length of the retrieved command. </p>"},{"location":"Wsh_Shell_API/wsh__shell__history_8c/#function-wshshellhistory_gettokenbyindex","title":"function WshShellHistory_GetTokenByIndex","text":"<p>Retrieve a command from history by its index. <pre><code>WshShell_Size_t WshShellHistory_GetTokenByIndex (\n    WshShellHistory_IO_t * pHistIO,\n    WshShell_Char_t * pOutBuff,\n    WshShell_Size_t outBuffSize,\n    WshShell_Size_t index\n) \n</code></pre></p> <p>Index 0 corresponds to the most recently saved command, index 1 to the previous one, and so on.</p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to the I/O structure. </li> <li><code>pOutBuff</code> Buffer to store the retrieved command. </li> <li><code>outBuffSize</code> Size of the output buffer. </li> <li><code>index</code> Index of the command to retrieve (0 = latest).</li> </ul> <p>Returns:</p> <p>Length of the retrieved command, or 0 if not found or buffer too small. </p>"},{"location":"Wsh_Shell_API/wsh__shell__history_8c/#function-wshshellhistory_gettokennum","title":"function WshShellHistory_GetTokenNum","text":"<p>Get the total number of commands stored in history. <pre><code>WshShell_Size_t WshShellHistory_GetTokenNum (\n    WshShellHistory_IO_t * pHistIO\n) \n</code></pre></p> <p>Starts from the most recently saved command and iterates backwards through the history buffer to count all stored commands.</p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to the I/O structure.</li> </ul> <p>Returns:</p> <p>Number of stored commands in history. </p>"},{"location":"Wsh_Shell_API/wsh__shell__history_8c/#function-wshshellhistory_init","title":"function WshShellHistory_Init","text":"<p>Initialize the shell history system with custom I/O functions. <pre><code>void WshShellHistory_Init (\n    WshShellHistory_IO_t * pHistIO,\n    WshShellHistory_ReadHandler_t readFn,\n    WshShellHistory_WriteHandler_t writeFn\n) \n</code></pre></p> <p>This function sets up the internal history system and loads existing history using the provided read/write callbacks.</p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to the I/O structure used for read/write access. </li> <li><code>readFn</code> Callback to read saved history data. </li> <li><code>writeFn</code> Callback to persist current history data. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__history_8c/#function-wshshellhistory_savecmd","title":"function WshShellHistory_SaveCmd","text":"<p>Save a new command to the history buffer. <pre><code>void WshShellHistory_SaveCmd (\n    WshShellHistory_IO_t * pHistIO,\n    const WshShell_Char_t * pcCmdStr,\n    WshShell_Size_t cmdStrLen\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to the I/O structure. </li> <li><code>pcCmdStr</code> Pointer to the command string (without EOL). </li> <li><code>cmdStrLen</code> Length of the command string. </li> </ul> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_history.c</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__history_8c_source/","title":"File wsh_shell_history.c","text":"<p>File List &gt; src &gt; wsh_shell_history.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"wsh_shell_history.h\"\n\n#if WSH_SHELL_HISTORY\n\nstatic WshShell_U32_t WshShellHistory_CalcHash(const WshShell_U8_t* pBuff, WshShell_Size_t len) {\n    WSH_SHELL_ASSERT(pBuff);\n\n    WshShell_U32_t hash = 0;\n    for (WshShell_Size_t idx = 0; idx &lt; len; idx++) {\n        hash += pBuff[idx];\n        hash += hash &lt;&lt; 10;\n        hash ^= hash &gt;&gt; 6;\n    }\n\n    hash += hash &lt;&lt; 3;\n    hash ^= hash &gt;&gt; 11;\n    hash += hash &lt;&lt; 15;\n\n    return hash;\n}\n\nstatic void WshShellHistory_CalcHashAndWrite(WshShellHistory_IO_t* pHistIO,\n                                             WshShellHistory_t history) {\n    WSH_SHELL_ASSERT(pHistIO);\n\n    history.Hash = WshShellHistory_CalcHash((WshShell_U8_t*)&amp;history.Data, sizeof(history.Data));\n    pHistIO-&gt;Write(history);\n    // WSH_SHELL_PRINT(\"\\r\\nh %d, t %d, l %d\\r\\n\", history.Data.HeadIdx, history.Data.TailIdx,\n    //                 history.Data.LastSavedCmdIdx);\n}\n\nvoid WshShellHistory_Init(WshShellHistory_IO_t* pHistIO, WshShellHistory_ReadHandler_t readFn,\n                          WshShellHistory_WriteHandler_t writeFn) {\n    WSH_SHELL_ASSERT(pHistIO &amp;&amp; readFn &amp;&amp; writeFn);\n    if (!pHistIO || !readFn || !writeFn)\n        return;\n\n    pHistIO-&gt;Read  = readFn;\n    pHistIO-&gt;Write = writeFn;\n\n    WshShellHistory_t extHistory = pHistIO-&gt;Read();\n    WshShell_U32_t extHash =\n        WshShellHistory_CalcHash((WshShell_U8_t*)&amp;extHistory.Data, sizeof(extHistory.Data));\n\n    if (extHash != extHistory.Hash)\n        WshShellHistory_CalcHashAndWrite(pHistIO, (WshShellHistory_t){0});\n}\n\nstatic void WshShellHistory_IncrIdx(WshShell_Size_t* pIdx) {\n    WSH_SHELL_ASSERT(pIdx);\n\n    if (++(*pIdx) &gt;= WSH_SHELL_HISTORY_BUFF_SIZE)\n        *pIdx = 0;\n}\n\nstatic void WshShellHistory_DecrIdx(WshShell_Size_t* pIdx) {\n    WSH_SHELL_ASSERT(pIdx);\n\n    *pIdx = *pIdx == 0 ? WSH_SHELL_HISTORY_BUFF_SIZE - 1 : *pIdx - 1;\n}\n\nstatic void WshShellHistory_GetTokenFromBuffer(WshShell_Char_t* pDst, const WshShell_Char_t* p\u0441Src,\n                                               WshShell_Size_t tokStartIdx,\n                                               WshShell_Size_t tokLen) {\n    WSH_SHELL_ASSERT(pDst &amp;&amp; p\u0441Src &amp;&amp; tokLen &gt; 0);\n\n    WshShell_Size_t readIdx = tokStartIdx;\n    for (WshShell_Size_t tokIdx = 0; tokIdx &lt; tokLen; tokIdx++) {\n        pDst[tokIdx] = p\u0441Src[readIdx];\n        WshShellHistory_IncrIdx(&amp;readIdx);\n    }\n    pDst[tokLen] = '\\0';\n}\n\nvoid WshShellHistory_SaveCmd(WshShellHistory_IO_t* pHistIO, const WshShell_Char_t* pcCmdStr,\n                             WshShell_Size_t cmdStrLen) {\n    WSH_SHELL_ASSERT(pcCmdStr &amp;&amp; cmdStrLen &lt; WSH_SHELL_HISTORY_BUFF_SIZE);\n    if (!pcCmdStr || cmdStrLen == 0 || cmdStrLen &gt;= WSH_SHELL_HISTORY_BUFF_SIZE)\n        return;\n\n    WshShellHistory_t locHist = pHistIO-&gt;Read();\n\n    /* Skip duplicate command */\n    WshShell_Char_t* pHistCmd = &amp;locHist.Data.StorageBuff[locHist.Data.LastSavedCmdIdx];\n    if (WSH_SHELL_STRNCMP(pcCmdStr, pHistCmd, cmdStrLen) == 0) {\n        /* Reset history rollback on cmd execution */\n        locHist.Data.TailIdx = locHist.Data.HeadIdx;\n        WshShellHistory_CalcHashAndWrite(pHistIO, locHist);\n\n        return;\n    }\n\n    locHist.Data.LastSavedCmdIdx = locHist.Data.HeadIdx;\n\n    for (WshShell_Size_t strIdx = 0; strIdx &lt; cmdStrLen; strIdx++) {\n        WSH_SHELL_ASSERT(WshShellStr_IsPrintableAscii(pcCmdStr[strIdx]));\n        locHist.Data.StorageBuff[locHist.Data.HeadIdx] = pcCmdStr[strIdx];\n        WshShellHistory_IncrIdx(&amp;locHist.Data.HeadIdx);\n    }\n\n    /* Null-terminate and update tail */\n    locHist.Data.StorageBuff[locHist.Data.HeadIdx] = '\\0';\n    WshShellHistory_IncrIdx(&amp;locHist.Data.HeadIdx);\n    locHist.Data.TailIdx = locHist.Data.HeadIdx;\n\n    WshShellHistory_CalcHashAndWrite(pHistIO, locHist);\n}\n\nstatic WshShell_Size_t WshShellHistory_GetPrevToken(WshShellHistory_Data_t* pHistData,\n                                                    WshShell_Size_t* pTokenIdx) {\n    WSH_SHELL_ASSERT(pHistData &amp;&amp; pTokenIdx);\n\n    const WshShell_Char_t* pBuff = pHistData-&gt;StorageBuff;\n    WshShell_Size_t head         = pHistData-&gt;HeadIdx;\n    WshShell_Size_t tail         = pHistData-&gt;TailIdx;\n\n    WshShellHistory_DecrIdx(&amp;tail);\n    while (pBuff[tail] == '\\0') {\n        if (tail == head)\n            return 0;\n\n        WshShellHistory_DecrIdx(&amp;tail);\n    }\n\n    WshShell_Size_t tokLen = 0;\n    while (pBuff[tail] != '\\0') {\n        if (tail == head)\n            return 0;\n\n        WshShellHistory_DecrIdx(&amp;tail);\n        tokLen++;\n    }\n\n    WshShellHistory_IncrIdx(&amp;tail);\n    pHistData-&gt;TailIdx = tail;\n    *pTokenIdx         = tail;\n\n    return tokLen;\n}\n\nstatic WshShell_Size_t WshShellHistory_GetNextToken(WshShellHistory_Data_t* pHistData,\n                                                    WshShell_Size_t* pTokenIdx) {\n    WSH_SHELL_ASSERT(pHistData &amp;&amp; pTokenIdx);\n\n    WshShell_Size_t tail = pHistData-&gt;TailIdx;\n    if (tail == pHistData-&gt;HeadIdx)\n        return 0;  // If tail reached head, no more commands\n\n    *pTokenIdx = tail;\n\n    WshShell_Size_t tokLen       = 0;\n    const WshShell_Char_t* pBuff = pHistData-&gt;StorageBuff;\n    while (pBuff[tail] != '\\0') {\n        if (tail == pHistData-&gt;HeadIdx)\n            return 0;\n\n        WshShellHistory_IncrIdx(&amp;tail);\n        tokLen++;\n    }\n\n    WshShellHistory_IncrIdx(&amp;tail);\n    pHistData-&gt;TailIdx = tail;\n    return tokLen;\n}\n\nstatic WshShell_Size_t WshShellHistory_GetCmd(WshShellHistory_IO_t* pHistIO,\n                                              WshShell_Char_t* pOutBuff,\n                                              WshShell_Size_t outBuffSize,\n                                              WSH_SHELL_HIST_CMD_DIR_t dir) {\n    WSH_SHELL_ASSERT(pHistIO &amp;&amp; pOutBuff &amp;&amp; outBuffSize &gt; 0);\n    if (!pHistIO || !pOutBuff || outBuffSize == 0)\n        return 0;\n\n    WshShellHistory_t hist = pHistIO-&gt;Read();\n    if (hist.Data.HeadIdx == 0 &amp;&amp; hist.Data.TailIdx == 0 &amp;&amp; hist.Data.LastSavedCmdIdx == 0)\n        return 0;\n\n    WshShell_Size_t tokIdx = 0;\n    WshShell_Size_t tokLen = 0;\n\n    if (dir == WSH_SHELL_HIST_CMD_PREV) {\n        tokLen = WshShellHistory_GetPrevToken(&amp;hist.Data, &amp;tokIdx);\n        if (hist.Data.PrevDir == WSH_SHELL_HIST_CMD_NEXT &amp;&amp; !hist.Data.LimitIsReached)\n            tokLen = WshShellHistory_GetPrevToken(&amp;hist.Data, &amp;tokIdx);\n    } else {\n        tokLen = WshShellHistory_GetNextToken(&amp;hist.Data, &amp;tokIdx);\n        if (hist.Data.PrevDir == WSH_SHELL_HIST_CMD_PREV &amp;&amp; !hist.Data.LimitIsReached)\n            tokLen = WshShellHistory_GetNextToken(&amp;hist.Data, &amp;tokIdx);\n    }\n\n    if (tokLen != 0 &amp;&amp; tokLen + 1 &lt; outBuffSize) {\n        hist.Data.LimitIsReached = false;\n        WshShellHistory_GetTokenFromBuffer(pOutBuff, hist.Data.StorageBuff, tokIdx, tokLen);\n    } else {\n        hist.Data.LimitIsReached = true;\n        WSH_SHELL_MEMSET(pOutBuff, 0, outBuffSize);\n    }\n\n    hist.Data.PrevDir = dir;\n    WshShellHistory_CalcHashAndWrite(pHistIO, hist);\n    return tokLen;\n}\n\nWshShell_Size_t WshShellHistory_GetPrevCmd(WshShellHistory_IO_t* pHistIO, WshShell_Char_t* pOutBuff,\n                                           WshShell_Size_t outBuffSize) {\n    return WshShellHistory_GetCmd(pHistIO, pOutBuff, outBuffSize, WSH_SHELL_HIST_CMD_PREV);\n}\n\nWshShell_Size_t WshShellHistory_GetNextCmd(WshShellHistory_IO_t* pHistIO, WshShell_Char_t* pOutBuff,\n                                           WshShell_Size_t outBuffSize) {\n    return WshShellHistory_GetCmd(pHistIO, pOutBuff, outBuffSize, WSH_SHELL_HIST_CMD_NEXT);\n}\n\nWshShell_Size_t WshShellHistory_GetTokenNum(WshShellHistory_IO_t* pHistIO) {\n    WSH_SHELL_ASSERT(pHistIO);\n    if (!pHistIO)\n        return 0;\n\n    WshShellHistory_t hist        = pHistIO-&gt;Read();\n    WshShellHistory_Data_t* pHist = &amp;hist.Data;\n    pHist-&gt;TailIdx                = pHist-&gt;HeadIdx;\n\n    WshShell_Size_t dummyTokIdx = 0;\n    WshShell_Size_t count       = 0;\n\n    while (WshShellHistory_GetPrevToken(pHist, &amp;dummyTokIdx))\n        count++;\n\n    return count;\n}\n\nWshShell_Size_t WshShellHistory_GetTokenByIndex(WshShellHistory_IO_t* pHistIO,\n                                                WshShell_Char_t* pOutBuff,\n                                                WshShell_Size_t outBuffSize,\n                                                WshShell_Size_t index) {\n    WSH_SHELL_ASSERT(pHistIO &amp;&amp; pOutBuff &amp;&amp; outBuffSize &gt; 0);\n    if (!pHistIO || !pOutBuff || outBuffSize == 0)\n        return 0;\n\n    WshShellHistory_t hist        = pHistIO-&gt;Read();\n    WshShellHistory_Data_t* pHist = &amp;hist.Data;\n\n    /* Set start position on last cmd for search */\n    pHist-&gt;TailIdx = pHist-&gt;HeadIdx;\n\n    WshShell_Size_t tokIdx = 0;\n    WshShell_Size_t tokLen = 0;\n\n    for (WshShell_Size_t idx = 0; idx &lt;= index; idx++) {\n        tokLen = WshShellHistory_GetPrevToken(pHist, &amp;tokIdx);\n        if (tokLen == 0)\n            return 0;\n    }\n\n    if (tokLen + 1 &gt;= outBuffSize)\n        return 0;\n\n    WshShellHistory_GetTokenFromBuffer(pOutBuff, pHist-&gt;StorageBuff, tokIdx, tokLen);\n    return tokLen;\n}\n\nvoid WshShellHistory_Flush(WshShellHistory_IO_t* pHistIO) {\n    WSH_SHELL_ASSERT(pHistIO);\n    if (!pHistIO)\n        return;\n\n    WshShellHistory_CalcHashAndWrite(pHistIO, (WshShellHistory_t){0});\n}\n\n#else /* WSH_SHELL_HISTORY */\n\nvoid WshShellHistory_Init(WshShellHistory_IO_t* pHistIO, WshShellHistory_ReadHandler_t readFn,\n                          WshShellHistory_WriteHandler_t writeFn) {\n    (void)(pHistIO);\n    (void)(readFn);\n    (void)(writeFn);\n}\n\nvoid WshShellHistory_SaveCmd(WshShellHistory_IO_t* pHistIO, const WshShell_Char_t* pcCmdStr,\n                             WshShell_Size_t cmdStrLen) {\n    (void)(pHistIO);\n    (void)(pcCmdStr);\n    (void)(cmdStrLen);\n}\n\nWshShell_Size_t WshShellHistory_GetPrevCmd(WshShellHistory_IO_t* pHistIO, WshShell_Char_t* pOutBuff,\n                                           WshShell_Size_t outBuffSize) {\n    (void)(pHistIO);\n    (void)(pOutBuff);\n    (void)(outBuffSize);\n\n    return 0;\n}\n\nWshShell_Size_t WshShellHistory_GetNextCmd(WshShellHistory_IO_t* pHistIO, WshShell_Char_t* pOutBuff,\n                                           WshShell_Size_t outBuffSize) {\n    (void)(pHistIO);\n    (void)(pOutBuff);\n    (void)(outBuffSize);\n\n    return 0;\n}\n\nWshShell_Size_t WshShellHistory_GetTokenNum(WshShellHistory_IO_t* pHistIO) {\n    (void)(pHistIO);\n\n    return 0;\n}\n\nWshShell_Size_t WshShellHistory_GetTokenByIndex(WshShellHistory_IO_t* pHistIO,\n                                                WshShell_Char_t* pOutBuff,\n                                                WshShell_Size_t outBuffSize,\n                                                WshShell_Size_t index) {\n    (void)(pHistIO);\n    (void)(pOutBuff);\n    (void)(outBuffSize);\n    (void)(index);\n\n    return 0;\n}\n\nvoid WshShellHistory_Flush(WshShellHistory_IO_t* pHistIO) {\n    (void)(pHistIO);\n}\n\n#endif /* WSH_SHELL_HISTORY */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__history_8h/","title":"File wsh_shell_history.h","text":"<p>FileList &gt; src &gt; wsh_shell_history.h</p> <p>Go to the source code of this file</p> <p>Shell history management API. More...</p> <ul> <li><code>#include \"wsh_shell_cfg.h\"</code></li> <li><code>#include \"wsh_shell_str.h\"</code></li> <li><code>#include \"wsh_shell_types.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#classes","title":"Classes","text":"Type Name struct WshShellHistory_Data_t Internal structure for storing command history buffer. struct WshShellHistory_IO_t Structure holding function pointers for history persistence I/O. struct WshShellHistory_t Shell history structure with integrity check."},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#public-types","title":"Public Types","text":"Type Name enum WSH_SHELL_HIST_CMD_DIR_t Direction for history navigation. typedef WshShellHistory_t(* WshShellHistory_ReadHandler_t Function pointer type for reading shell history from persistent storage. typedef void(* WshShellHistory_WriteHandler_t Function pointer type for writing shell history to persistent storage."},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#public-functions","title":"Public Functions","text":"Type Name void WshShellHistory_Flush (WshShellHistory_IO_t * pHistIO) Clear the command history buffer. WshShell_Size_t WshShellHistory_GetNextCmd (WshShellHistory_IO_t * pHistIO, WshShell_Char_t * pOutBuff, WshShell_Size_t outBuffSize) Retrieve the next command from history. WshShell_Size_t WshShellHistory_GetPrevCmd (WshShellHistory_IO_t * pHistIO, WshShell_Char_t * pOutBuff, WshShell_Size_t outBuffSize) Retrieve the previous command from history. WshShell_Size_t WshShellHistory_GetTokenByIndex (WshShellHistory_IO_t * pHistIO, WshShell_Char_t * pOutBuff, WshShell_Size_t outBuffSize, WshShell_Size_t index) Retrieve a command from history by its index. WshShell_Size_t WshShellHistory_GetTokenNum (WshShellHistory_IO_t * pHistIO) Get the total number of commands stored in history. void WshShellHistory_Init (WshShellHistory_IO_t * pHistIO, WshShellHistory_ReadHandler_t readFn, WshShellHistory_WriteHandler_t writeFn) Initialize the shell history system with custom I/O functions. void WshShellHistory_SaveCmd (WshShellHistory_IO_t * pHistIO, const WshShell_Char_t * pcCmdStr, WshShell_Size_t cmdStrLen) Save a new command to the history buffer."},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#detailed-description","title":"Detailed Description","text":"<p>This module provides functionality for storing, navigating, and persisting command history in an embedded shell environment.</p> <p>Author:</p> <p>Whoosh Embedded Team </p> <p>Copyright:</p> <p>Copyright (c) 2025 </p>"},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#enum-wsh_shell_hist_cmd_dir_t","title":"enum WSH_SHELL_HIST_CMD_DIR_t","text":"<p>Direction for history navigation. <pre><code>enum WSH_SHELL_HIST_CMD_DIR_t {\n    WSH_SHELL_HIST_CMD_PREV = 0,\n    WSH_SHELL_HIST_CMD_NEXT\n};\n</code></pre></p>"},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#typedef-wshshellhistory_readhandler_t","title":"typedef WshShellHistory_ReadHandler_t","text":"<p>Function pointer type for reading shell history from persistent storage. <pre><code>typedef WshShellHistory_t(* WshShellHistory_ReadHandler_t) (void);\n</code></pre></p>"},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#typedef-wshshellhistory_writehandler_t","title":"typedef WshShellHistory_WriteHandler_t","text":"<p>Function pointer type for writing shell history to persistent storage. <pre><code>typedef void(* WshShellHistory_WriteHandler_t) (WshShellHistory_t);\n</code></pre></p>"},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#function-wshshellhistory_flush","title":"function WshShellHistory_Flush","text":"<p>Clear the command history buffer. <pre><code>void WshShellHistory_Flush (\n    WshShellHistory_IO_t * pHistIO\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to the I/O structure. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#function-wshshellhistory_getnextcmd","title":"function WshShellHistory_GetNextCmd","text":"<p>Retrieve the next command from history. <pre><code>WshShell_Size_t WshShellHistory_GetNextCmd (\n    WshShellHistory_IO_t * pHistIO,\n    WshShell_Char_t * pOutBuff,\n    WshShell_Size_t outBuffSize\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to the I/O structure. </li> <li><code>pOutBuff</code> Buffer to store the command string. </li> <li><code>outBuffSize</code> Size of the output buffer.</li> </ul> <p>Returns:</p> <p>Length of the retrieved command. </p>"},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#function-wshshellhistory_getprevcmd","title":"function WshShellHistory_GetPrevCmd","text":"<p>Retrieve the previous command from history. <pre><code>WshShell_Size_t WshShellHistory_GetPrevCmd (\n    WshShellHistory_IO_t * pHistIO,\n    WshShell_Char_t * pOutBuff,\n    WshShell_Size_t outBuffSize\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to the I/O structure. </li> <li><code>pOutBuff</code> Buffer to store the command string. </li> <li><code>outBuffSize</code> Size of the output buffer.</li> </ul> <p>Returns:</p> <p>Length of the retrieved command. </p>"},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#function-wshshellhistory_gettokenbyindex","title":"function WshShellHistory_GetTokenByIndex","text":"<p>Retrieve a command from history by its index. <pre><code>WshShell_Size_t WshShellHistory_GetTokenByIndex (\n    WshShellHistory_IO_t * pHistIO,\n    WshShell_Char_t * pOutBuff,\n    WshShell_Size_t outBuffSize,\n    WshShell_Size_t index\n) \n</code></pre></p> <p>Index 0 corresponds to the most recently saved command, index 1 to the previous one, and so on.</p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to the I/O structure. </li> <li><code>pOutBuff</code> Buffer to store the retrieved command. </li> <li><code>outBuffSize</code> Size of the output buffer. </li> <li><code>index</code> Index of the command to retrieve (0 = latest).</li> </ul> <p>Returns:</p> <p>Length of the retrieved command, or 0 if not found or buffer too small. </p>"},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#function-wshshellhistory_gettokennum","title":"function WshShellHistory_GetTokenNum","text":"<p>Get the total number of commands stored in history. <pre><code>WshShell_Size_t WshShellHistory_GetTokenNum (\n    WshShellHistory_IO_t * pHistIO\n) \n</code></pre></p> <p>Starts from the most recently saved command and iterates backwards through the history buffer to count all stored commands.</p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to the I/O structure.</li> </ul> <p>Returns:</p> <p>Number of stored commands in history. </p>"},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#function-wshshellhistory_init","title":"function WshShellHistory_Init","text":"<p>Initialize the shell history system with custom I/O functions. <pre><code>void WshShellHistory_Init (\n    WshShellHistory_IO_t * pHistIO,\n    WshShellHistory_ReadHandler_t readFn,\n    WshShellHistory_WriteHandler_t writeFn\n) \n</code></pre></p> <p>This function sets up the internal history system and loads existing history using the provided read/write callbacks.</p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to the I/O structure used for read/write access. </li> <li><code>readFn</code> Callback to read saved history data. </li> <li><code>writeFn</code> Callback to persist current history data. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__history_8h/#function-wshshellhistory_savecmd","title":"function WshShellHistory_SaveCmd","text":"<p>Save a new command to the history buffer. <pre><code>void WshShellHistory_SaveCmd (\n    WshShellHistory_IO_t * pHistIO,\n    const WshShell_Char_t * pcCmdStr,\n    WshShell_Size_t cmdStrLen\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pHistIO</code> Pointer to the I/O structure. </li> <li><code>pcCmdStr</code> Pointer to the command string (without EOL). </li> <li><code>cmdStrLen</code> Length of the command string. </li> </ul> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_history.h</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__history_8h_source/","title":"File wsh_shell_history.h","text":"<p>File List &gt; src &gt; wsh_shell_history.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __WSH_SHELL_HISTORY_H\n#define __WSH_SHELL_HISTORY_H\n\n#include \"wsh_shell_cfg.h\"\n#include \"wsh_shell_str.h\"\n#include \"wsh_shell_types.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef enum {\n    WSH_SHELL_HIST_CMD_PREV = 0, \n    WSH_SHELL_HIST_CMD_NEXT      \n} WSH_SHELL_HIST_CMD_DIR_t;\n\ntypedef struct {\n    WshShell_Char_t StorageBuff[WSH_SHELL_HISTORY_BUFF_SIZE]; \n    WshShell_Size_t HeadIdx;                                  \n    WshShell_Size_t TailIdx;                                  \n    WshShell_Size_t LastSavedCmdIdx;  \n    WSH_SHELL_HIST_CMD_DIR_t PrevDir; \n    WshShell_Bool_t LimitIsReached;   \n} WshShellHistory_Data_t;\n\ntypedef struct {\n    WshShell_U32_t Hash;         \n    WshShellHistory_Data_t Data; \n} WshShellHistory_t;\n\ntypedef WshShellHistory_t (*WshShellHistory_ReadHandler_t)(void);\n\ntypedef void (*WshShellHistory_WriteHandler_t)(WshShellHistory_t);\n\ntypedef struct {\n    WshShellHistory_ReadHandler_t Read;   \n    WshShellHistory_WriteHandler_t Write; \n} WshShellHistory_IO_t;\n\nvoid WshShellHistory_Init(WshShellHistory_IO_t* pHistIO, WshShellHistory_ReadHandler_t readFn,\n                          WshShellHistory_WriteHandler_t writeFn);\n\nvoid WshShellHistory_SaveCmd(WshShellHistory_IO_t* pHistIO, const WshShell_Char_t* pcCmdStr,\n                             WshShell_Size_t cmdStrLen);\n\nWshShell_Size_t WshShellHistory_GetPrevCmd(WshShellHistory_IO_t* pHistIO, WshShell_Char_t* pOutBuff,\n                                           WshShell_Size_t outBuffSize);\n\nWshShell_Size_t WshShellHistory_GetNextCmd(WshShellHistory_IO_t* pHistIO, WshShell_Char_t* pOutBuff,\n                                           WshShell_Size_t outBuffSize);\n\nWshShell_Size_t WshShellHistory_GetTokenNum(WshShellHistory_IO_t* pHistIO);\n\nWshShell_Size_t WshShellHistory_GetTokenByIndex(WshShellHistory_IO_t* pHistIO,\n                                                WshShell_Char_t* pOutBuff,\n                                                WshShell_Size_t outBuffSize, WshShell_Size_t index);\n\nvoid WshShellHistory_Flush(WshShellHistory_IO_t* pHistIO);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __WSH_SHELL_HISTORY_H */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__interact_8c/","title":"File wsh_shell_interact.c","text":"<p>FileList &gt; src &gt; wsh_shell_interact.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"wsh_shell_interact.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__interact_8c/#public-functions","title":"Public Functions","text":"Type Name void WshShellInteract_AppendLineBreak (WshShellIO_CommandLine_t * pCommandLine) Appends a CRLF ( <code>\\r\\n</code> ) sequence to the interaction buffer. void WshShellInteract_Attach (WshShell_Interact_t * pInteract, const WshShell_Char_t * pcName, WshShellInteractive_CmdHandler_t handler) Registers an interactive command. void WshShellInteract_Flush (WshShell_Interact_t * pInteract) Clears the contents of an interactive command slot."},{"location":"Wsh_Shell_API/wsh__shell__interact_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__interact_8c/#function-wshshellinteract_appendlinebreak","title":"function WshShellInteract_AppendLineBreak","text":"<p>Appends a CRLF ( <code>\\r\\n</code> ) sequence to the interaction buffer. <pre><code>void WshShellInteract_AppendLineBreak (\n    WshShellIO_CommandLine_t * pCommandLine\n) \n</code></pre></p> <p>Adds a carriage return and line feed to the end of the current input buffer, if there is enough space. This is typically used to terminate user input lines.</p> <p>If the buffer is too full to append both characters, an error is printed.</p> <p>Parameters:</p> <ul> <li><code>pCommandLine</code> Pointer to the interaction buffer (command line). </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__interact_8c/#function-wshshellinteract_attach","title":"function WshShellInteract_Attach","text":"<p>Registers an interactive command. <pre><code>void WshShellInteract_Attach (\n    WshShell_Interact_t * pInteract,\n    const WshShell_Char_t * pcName,\n    WshShellInteractive_CmdHandler_t handler\n) \n</code></pre></p> <p>Attaches a named command and its execution function to the given interact structure. The command name is truncated if it exceeds the internal buffer size.</p> <p>Parameters:</p> <ul> <li><code>pInteract</code> Pointer to the interact object to initialize. </li> <li><code>pcName</code> Null-terminated name of the interactive command. </li> <li><code>handler</code> Function pointer to be called when the command is executed. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__interact_8c/#function-wshshellinteract_flush","title":"function WshShellInteract_Flush","text":"<p>Clears the contents of an interactive command slot. <pre><code>void WshShellInteract_Flush (\n    WshShell_Interact_t * pInteract\n) \n</code></pre></p> <p>Resets the execution function pointer to <code>NULL</code> and clears the command name buffer. This effectively \"removes\" the interactive command from the shell registry.</p> <p>Parameters:</p> <ul> <li><code>pInteract</code> Pointer to the interact structure to flush. </li> </ul> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_interact.c</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__interact_8c_source/","title":"File wsh_shell_interact.c","text":"<p>File List &gt; src &gt; wsh_shell_interact.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"wsh_shell_interact.h\"\n\n#if WSH_SHELL_INTERACTIVE_MODE\n\nvoid WshShellInteract_Attach(WshShell_Interact_t* pInteract, const WshShell_Char_t* pcName,\n                             WshShellInteractive_CmdHandler_t handler) {\n    WSH_SHELL_ASSERT(pInteract &amp;&amp; pcName &amp;&amp; handler);\n    if (!pInteract || !pcName || !handler)\n        return;\n\n    pInteract-&gt;Handler = handler;\n\n    WshShell_Size_t bufSize = sizeof(pInteract-&gt;CmdName);\n    WshShell_Size_t len     = WSH_SHELL_STRLEN(pcName);\n    if (len &gt;= bufSize)\n        len = bufSize - 1;\n\n    WSH_SHELL_MEMCPY(pInteract-&gt;CmdName, pcName, len);\n    pInteract-&gt;CmdName[len] = '\\0';\n}\n\nvoid WshShellInteract_AppendLineBreak(WshShellIO_CommandLine_t* pCommandLine) {\n    WSH_SHELL_ASSERT(pCommandLine);\n    if (!pCommandLine)\n        return;\n\n    WshShell_Size_t len    = pCommandLine-&gt;Len;\n    WshShell_Size_t maxLen = sizeof(pCommandLine-&gt;Buff);\n\n    if (len + 2 &lt; maxLen) {\n        pCommandLine-&gt;Buff[len++] = '\\r';\n        pCommandLine-&gt;Buff[len++] = '\\n';\n    } else {\n        WSH_SHELL_PRINT_ERR(\"Command too long!\");\n    }\n}\n\nvoid WshShellInteract_Flush(WshShell_Interact_t* pInteract) {\n    WSH_SHELL_ASSERT(pInteract);\n    if (!pInteract)\n        return;\n\n    pInteract-&gt;Handler = NULL;\n    WSH_SHELL_MEMSET((void*)pInteract-&gt;CmdName, 0, sizeof(pInteract-&gt;CmdName));\n}\n\n#else /* WSH_SHELL_INTERACTIVE_MODE */\n\nvoid WshShellInteract_Attach(WshShell_Interact_t* pInteract, const WshShell_Char_t* pcName,\n                             WshShellInteractive_CmdHandler_t handler) {\n    (void)(pInteract);\n    (void)(pcName);\n    (void)(handler);\n\n    WSH_SHELL_PRINT_WARN(\"interactive mode disabled\\r\\n\");\n}\n\nvoid WshShellInteract_AppendLineBreak(WshShellIO_CommandLine_t* pCommandLine) {\n    (void)(pCommandLine);\n}\n\nvoid WshShellInteract_Flush(WshShell_Interact_t* pInteract) {\n    (void)(pInteract);\n}\n\n#endif /* WSH_SHELL_INTERACTIVE_MODE */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__interact_8h/","title":"File wsh_shell_interact.h","text":"<p>FileList &gt; src &gt; wsh_shell_interact.h</p> <p>Go to the source code of this file</p> <p>Interactive command registration and line editing utilities for WshShell. More...</p> <ul> <li><code>#include \"wsh_shell_cfg.h\"</code></li> <li><code>#include \"wsh_shell_io.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__interact_8h/#classes","title":"Classes","text":"Type Name struct WshShell_Interact_t Interactive command registration structure."},{"location":"Wsh_Shell_API/wsh__shell__interact_8h/#public-types","title":"Public Types","text":"Type Name typedef void(* WshShellInteractive_CmdHandler_t Function pointer type for an interactive shell command."},{"location":"Wsh_Shell_API/wsh__shell__interact_8h/#public-functions","title":"Public Functions","text":"Type Name void WshShellInteract_AppendLineBreak (WshShellIO_CommandLine_t * pCommandLine) Appends a CRLF ( <code>\\r\\n</code> ) sequence to the interaction buffer. void WshShellInteract_Attach (WshShell_Interact_t * pInteract, const WshShell_Char_t * pcName, WshShellInteractive_CmdHandler_t handler) Registers an interactive command. void WshShellInteract_Flush (WshShell_Interact_t * pInteract) Clears the contents of an interactive command slot."},{"location":"Wsh_Shell_API/wsh__shell__interact_8h/#detailed-description","title":"Detailed Description","text":"<p>This module provides an interface for attaching interactive commands and for modifying the user input buffer, such as appending carriage return and line feed sequences (<code>\\r\\n</code>) at the end of the command line.</p> <p>It is used internally by the shell to register interactive commands and manage the formatting of user-entered command lines.</p> <p>Author:</p> <p>Whoosh Embedded Team </p> <p>Copyright:</p> <p>Copyright (c) 2024 </p>"},{"location":"Wsh_Shell_API/wsh__shell__interact_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__interact_8h/#typedef-wshshellinteractive_cmdhandler_t","title":"typedef WshShellInteractive_CmdHandler_t","text":"<p>Function pointer type for an interactive shell command. <pre><code>typedef void(* WshShellInteractive_CmdHandler_t) (WshShellIO_CommandLine_t *pCommandLine);\n</code></pre></p> <p>This type defines the prototype for interactive command callbacks, which are invoked with a pointer to the current command line buffer. </p>"},{"location":"Wsh_Shell_API/wsh__shell__interact_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__interact_8h/#function-wshshellinteract_appendlinebreak","title":"function WshShellInteract_AppendLineBreak","text":"<p>Appends a CRLF ( <code>\\r\\n</code> ) sequence to the interaction buffer. <pre><code>void WshShellInteract_AppendLineBreak (\n    WshShellIO_CommandLine_t * pCommandLine\n) \n</code></pre></p> <p>Adds a carriage return and line feed to the end of the current input buffer, if there is enough space. This is typically used to terminate user input lines.</p> <p>If the buffer is too full to append both characters, an error is printed.</p> <p>Parameters:</p> <ul> <li><code>pCommandLine</code> Pointer to the interaction buffer (command line). </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__interact_8h/#function-wshshellinteract_attach","title":"function WshShellInteract_Attach","text":"<p>Registers an interactive command. <pre><code>void WshShellInteract_Attach (\n    WshShell_Interact_t * pInteract,\n    const WshShell_Char_t * pcName,\n    WshShellInteractive_CmdHandler_t handler\n) \n</code></pre></p> <p>Attaches a named command and its execution function to the given interact structure. The command name is truncated if it exceeds the internal buffer size.</p> <p>Parameters:</p> <ul> <li><code>pInteract</code> Pointer to the interact object to initialize. </li> <li><code>pcName</code> Null-terminated name of the interactive command. </li> <li><code>handler</code> Function pointer to be called when the command is executed. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__interact_8h/#function-wshshellinteract_flush","title":"function WshShellInteract_Flush","text":"<p>Clears the contents of an interactive command slot. <pre><code>void WshShellInteract_Flush (\n    WshShell_Interact_t * pInteract\n) \n</code></pre></p> <p>Resets the execution function pointer to <code>NULL</code> and clears the command name buffer. This effectively \"removes\" the interactive command from the shell registry.</p> <p>Parameters:</p> <ul> <li><code>pInteract</code> Pointer to the interact structure to flush. </li> </ul> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_interact.h</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__interact_8h_source/","title":"File wsh_shell_interact.h","text":"<p>File List &gt; src &gt; wsh_shell_interact.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __WSH_SHELL_INTERACT_H\n#define __WSH_SHELL_INTERACT_H\n\n#include \"wsh_shell_cfg.h\"\n#include \"wsh_shell_io.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef void (*WshShellInteractive_CmdHandler_t)(WshShellIO_CommandLine_t* pCommandLine);\n\ntypedef struct {\n    WshShellInteractive_CmdHandler_t Handler; \n    WshShell_Char_t CmdName[WSH_SHELL_CMD_NAME_LEN]; \n} WshShell_Interact_t;\n\nvoid WshShellInteract_Attach(WshShell_Interact_t* pInteract, const WshShell_Char_t* pcName,\n                             WshShellInteractive_CmdHandler_t handler);\n\nvoid WshShellInteract_AppendLineBreak(WshShellIO_CommandLine_t* pCommandLine);\n\nvoid WshShellInteract_Flush(WshShell_Interact_t* pInteract);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __WSH_SHELL_INTERACT_H */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8c/","title":"File wsh_shell_io.c","text":"<p>FileList &gt; src &gt; wsh_shell_io.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"wsh_shell_io.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__io_8c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const WshShell_Char_t * WshShellIO_InsertStringTemplate   = <code>/* multi line expression */</code>"},{"location":"Wsh_Shell_API/wsh__shell__io_8c/#public-functions","title":"Public Functions","text":"Type Name void WshShellIO_ClearInterBuff (WshShellIO_CommandLine_t * pCommandLine) Clears the interaction buffer. void WshShellIO_InsertSymbol (WshShellIO_CommandLine_t * pCommandLine, WshShell_Char_t ch, WshShell_Bool_t starsOrChars) Inserts a symbol at the current cursor position in the input buffer. void WshShellIO_PrintInterBuff (WshShellIO_CommandLine_t * pCommandLine) Prints the current interaction buffer to the terminal. void WshShellIO_RefreshConsoleFromInterBuff (WshShellIO_CommandLine_t * pCommandLine) Refreshes the terminal display using the interaction buffer. void WshShellIO_RemoveLeftSymbol (WshShellIO_CommandLine_t * pCommandLine) Removes the symbol to the left of the cursor in the input buffer. void WshShellIO_WriteToInterBuff (WshShellIO_CommandLine_t * pCommandLine, WshShell_Char_t symbol) Writes a character into the interaction buffer at the cursor position."},{"location":"Wsh_Shell_API/wsh__shell__io_8c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__io_8c/#variable-wshshellio_insertstringtemplate","title":"variable WshShellIO_InsertStringTemplate","text":"<pre><code>const WshShell_Char_t* WshShellIO_InsertStringTemplate;\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__io_8c/#function-wshshellio_clearinterbuff","title":"function WshShellIO_ClearInterBuff","text":"<p>Clears the interaction buffer. <pre><code>void WshShellIO_ClearInterBuff (\n    WshShellIO_CommandLine_t * pCommandLine\n) \n</code></pre></p> <p>Resets buffer contents, cursor position, and line length.</p> <p>Parameters:</p> <ul> <li><code>pCommandLine</code> Pointer to the interaction buffer. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__io_8c/#function-wshshellio_insertsymbol","title":"function WshShellIO_InsertSymbol","text":"<p>Inserts a symbol at the current cursor position in the input buffer. <pre><code>void WshShellIO_InsertSymbol (\n    WshShellIO_CommandLine_t * pCommandLine,\n    WshShell_Char_t ch,\n    WshShell_Bool_t starsOrChars\n) \n</code></pre></p> <p>This function handles character insertion into the interaction buffer: * If the cursor is in the middle of the line (not at the end), it shifts existing characters to the right to make space for the new symbol. * The character is then written into the buffer at the cursor position using <code>WshShellIO_WriteToInterBuff</code>. * The terminal is updated to reflect the insertion, printing either the actual symbol or an asterisk (<code>*</code>) if <code>starsOrChars</code> is true (used for password masking).</p> <p>Cursor position and buffer length are updated internally. Asserts that <code>pCommandLine</code> is valid and that <code>CursorPos &gt;= 1</code> before printing.</p> <p>Parameters:</p> <ul> <li><code>pCommandLine</code> Pointer to the interaction buffer. </li> <li><code>ch</code> The symbol to insert. </li> <li><code>starsOrChars</code> If true, prints <code>*</code> instead of the actual character. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__io_8c/#function-wshshellio_printinterbuff","title":"function WshShellIO_PrintInterBuff","text":"<p>Prints the current interaction buffer to the terminal. <pre><code>void WshShellIO_PrintInterBuff (\n    WshShellIO_CommandLine_t * pCommandLine\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pCommandLine</code> Pointer to the interaction buffer. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__io_8c/#function-wshshellio_refreshconsolefrominterbuff","title":"function WshShellIO_RefreshConsoleFromInterBuff","text":"<p>Refreshes the terminal display using the interaction buffer. <pre><code>void WshShellIO_RefreshConsoleFromInterBuff (\n    WshShellIO_CommandLine_t * pCommandLine\n) \n</code></pre></p> <p>Clears the current line and reprints buffer contents.</p> <p>Parameters:</p> <ul> <li><code>pCommandLine</code> Pointer to the interaction buffer. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__io_8c/#function-wshshellio_removeleftsymbol","title":"function WshShellIO_RemoveLeftSymbol","text":"<p>Removes the symbol to the left of the cursor in the input buffer. <pre><code>void WshShellIO_RemoveLeftSymbol (\n    WshShellIO_CommandLine_t * pCommandLine\n) \n</code></pre></p> <p>This function handles backspace-like behavior: * If the cursor is not at the beginning of the line, it removes the symbol to the left of the cursor, shifts the rest of the line left, and updates both the buffer and terminal display. * If the cursor is beyond the line length (unexpected), only moves the cursor one position left.</p> <p>Also updates the internal buffer length and uses ANSI escape sequences to visually update the terminal.</p> <p>Parameters:</p> <ul> <li><code>pCommandLine</code> Pointer to the interaction buffer. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__io_8c/#function-wshshellio_writetointerbuff","title":"function WshShellIO_WriteToInterBuff","text":"<p>Writes a character into the interaction buffer at the cursor position. <pre><code>void WshShellIO_WriteToInterBuff (\n    WshShellIO_CommandLine_t * pCommandLine,\n    WshShell_Char_t symbol\n) \n</code></pre></p> <p>Increments cursor and line length accordingly.</p> <p>Parameters:</p> <ul> <li><code>pCommandLine</code> Pointer to the interaction buffer. </li> <li><code>symbol</code> Character to write. </li> </ul> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_io.c</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__io_8c_source/","title":"File wsh_shell_io.c","text":"<p>File List &gt; src &gt; wsh_shell_io.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"wsh_shell_io.h\"\n\nvoid WshShellIO_ClearInterBuff(WshShellIO_CommandLine_t* pCommandLine) {\n    WSH_SHELL_ASSERT(pCommandLine);\n    if (!pCommandLine)\n        return;\n\n    WSH_SHELL_MEMSET((void*)pCommandLine-&gt;Buff, 0,\n                     sizeof(WshShell_Char_t) * WSH_SHELL_INTR_BUFF_LEN);\n    pCommandLine-&gt;Len       = 0;\n    pCommandLine-&gt;CursorPos = 0;\n}\n\nvoid WshShellIO_WriteToInterBuff(WshShellIO_CommandLine_t* pCommandLine, WshShell_Char_t symbol) {\n    WSH_SHELL_ASSERT(pCommandLine);\n    if (!pCommandLine)\n        return;\n\n    pCommandLine-&gt;Buff[pCommandLine-&gt;CursorPos] = symbol;\n    WshShellStr_IncrInterCnt(&amp;(pCommandLine-&gt;CursorPos), WSH_SHELL_INTR_BUFF_LEN);\n    WshShellStr_IncrInterCnt(&amp;(pCommandLine-&gt;Len), WSH_SHELL_INTR_BUFF_LEN);\n}\n\nvoid WshShellIO_PrintInterBuff(WshShellIO_CommandLine_t* pCommandLine) {\n    WSH_SHELL_ASSERT(pCommandLine);\n    if (!pCommandLine)\n        return;\n\n    WSH_SHELL_PRINT(pCommandLine-&gt;Buff);\n}\n\nvoid WshShellIO_RefreshConsoleFromInterBuff(WshShellIO_CommandLine_t* pCommandLine) {\n    WSH_SHELL_ASSERT(pCommandLine);\n    if (!pCommandLine)\n        return;\n\n    // Move cursor to the beginning\n    for (WshShell_Size_t cur = pCommandLine-&gt;CursorPos; cur &gt; 0; cur--)\n        WSH_SHELL_PRINT(\"%c\", WSH_SHELL_SYM_BACKSPACE);  //Move crs left 1 char\n\n    // Clear line to the right of cursor\n    WSH_SHELL_PRINT(WSH_SHELL_ESC_CLEAR_RIGHT_FROM_CURS);\n\n    // Update line length and cursor position\n    pCommandLine-&gt;Len       = WSH_SHELL_STRLEN(pCommandLine-&gt;Buff);\n    pCommandLine-&gt;CursorPos = pCommandLine-&gt;Len;\n\n    WshShellIO_PrintInterBuff(pCommandLine);\n}\n\nvoid WshShellIO_RemoveLeftSymbol(WshShellIO_CommandLine_t* pCommandLine) {\n    WSH_SHELL_ASSERT(pCommandLine);\n    if (!pCommandLine || pCommandLine-&gt;CursorPos == 0)\n        return;\n\n    WshShell_Size_t cursorPos = pCommandLine-&gt;CursorPos - 1;\n\n    if (pCommandLine-&gt;CursorPos &lt;= pCommandLine-&gt;Len) {\n        // Shift buffer left from pos\n        for (WshShell_Size_t pos = cursorPos; pos &lt; pCommandLine-&gt;Len; pos++) {\n            pCommandLine-&gt;Buff[pos] = pCommandLine-&gt;Buff[pos + 1];\n        }\n\n        WshShellStr_DecrInterCnt(&amp;pCommandLine-&gt;Len);\n        pCommandLine-&gt;CursorPos = cursorPos;\n\n        WSH_SHELL_PRINT(\"%c%s%s%s%s\", WSH_SHELL_SYM_BACKSPACE, WSH_SHELL_ESC_SAVE_CURSOR,\n                        WSH_SHELL_ESC_CLEAR_RIGHT_FROM_CURS, &amp;pCommandLine-&gt;Buff[cursorPos],\n                        WSH_SHELL_ESC_RESTORE_CURSOR);\n    } else {\n        // This should not happen, but safe fallback\n        pCommandLine-&gt;CursorPos = cursorPos;\n        WSH_SHELL_PRINT(\"%c\", WSH_SHELL_SYM_BACKSPACE);\n    }\n}\n\nstatic const WshShell_Char_t* WshShellIO_InsertStringTemplate =\n    WSH_SHELL_ESC_SAVE_CURSOR WSH_SHELL_ESC_CLEAR_RIGHT_FROM_CURS\n    \"%s\" WSH_SHELL_ESC_RESTORE_CURSOR WSH_SHELL_ESC_ARROW_RIGHT;\n\nvoid WshShellIO_InsertSymbol(WshShellIO_CommandLine_t* pCommandLine, WshShell_Char_t ch,\n                             WshShell_Bool_t starsOrChars) {\n    WSH_SHELL_ASSERT(pCommandLine);\n    if (!pCommandLine)\n        return;\n\n    WshShell_Bool_t insertInMiddle = (WshShell_Bool_t)(pCommandLine-&gt;CursorPos &lt; pCommandLine-&gt;Len);\n\n    // Shift characters right if inserting in the middle of the line\n    if (insertInMiddle) {\n        for (WshShell_Size_t pos = pCommandLine-&gt;Len; pos &gt; pCommandLine-&gt;CursorPos; pos--)\n            pCommandLine-&gt;Buff[pos] = pCommandLine-&gt;Buff[pos - 1];\n    }\n\n    WshShellIO_WriteToInterBuff(pCommandLine, ch);\n\n    WSH_SHELL_ASSERT(pCommandLine-&gt;CursorPos &gt;= 1);\n    WSH_SHELL_PRINT(WshShellIO_InsertStringTemplate,\n                    starsOrChars ? \"*\" : &amp;pCommandLine-&gt;Buff[pCommandLine-&gt;CursorPos - 1]);\n}\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/","title":"File wsh_shell_io.h","text":"<p>FileList &gt; src &gt; wsh_shell_io.h</p> <p>Go to the source code of this file</p> <p>Terminal input/output definitions and interaction buffer API for WshShell. More...</p> <ul> <li><code>#include \"wsh_shell_cfg.h\"</code></li> <li><code>#include \"wsh_shell_str.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#classes","title":"Classes","text":"Type Name struct WshShellIO_CommandLine_t Structure representing the current user input interaction state."},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#public-functions","title":"Public Functions","text":"Type Name void WshShellIO_ClearInterBuff (WshShellIO_CommandLine_t * pCommandLine) Clears the interaction buffer. void WshShellIO_InsertSymbol (WshShellIO_CommandLine_t * pCommandLine, WshShell_Char_t ch, WshShell_Bool_t starsOrChars) Inserts a symbol at the current cursor position in the input buffer. void WshShellIO_PrintInterBuff (WshShellIO_CommandLine_t * pCommandLine) Prints the current interaction buffer to the terminal. void WshShellIO_RefreshConsoleFromInterBuff (WshShellIO_CommandLine_t * pCommandLine) Refreshes the terminal display using the interaction buffer. void WshShellIO_RemoveLeftSymbol (WshShellIO_CommandLine_t * pCommandLine) Removes the symbol to the left of the cursor in the input buffer. void WshShellIO_WriteToInterBuff (WshShellIO_CommandLine_t * pCommandLine, WshShell_Char_t symbol) Writes a character into the interaction buffer at the cursor position."},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#macros","title":"Macros","text":"Type Name define WSH_SHELL_CHAR_CR <code>'\\r'</code> define WSH_SHELL_CHAR_LF <code>'\\n'</code> define WSH_SHELL_COLOR_BLACK <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[30m\"</code> define WSH_SHELL_COLOR_BLUE <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[34m\"</code> define WSH_SHELL_COLOR_CYAN <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[36m\"</code> define WSH_SHELL_COLOR_ERROR <code>WSH\\_SHELL\\_COLOR\\_RED</code> define WSH_SHELL_COLOR_GREEN <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[32m\"</code> define WSH_SHELL_COLOR_INFO <code>WSH\\_SHELL\\_COLOR\\_WHITE</code> define WSH_SHELL_COLOR_OK <code>WSH\\_SHELL\\_COLOR\\_GREEN</code> define WSH_SHELL_COLOR_PURPLE <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[35m\"</code> define WSH_SHELL_COLOR_RED <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[31m\"</code> define WSH_SHELL_COLOR_SYS <code>WSH\\_SHELL\\_COLOR\\_CYAN</code> define WSH_SHELL_COLOR_WARN <code>WSH\\_SHELL\\_COLOR\\_YELLOW</code> define WSH_SHELL_COLOR_WHITE <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[37m\"</code> define WSH_SHELL_COLOR_YELLOW <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[33m\"</code> define WSH_SHELL_ECS_CLR_SCREEN <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[1;1H\" WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR \"[2J\"</code> define WSH_SHELL_ECS_RESET_MODE_BOLD <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[22m\"</code> define WSH_SHELL_ECS_RESET_MODE_ITALIC <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[23m\"</code> define WSH_SHELL_ECS_SET_MODE_BOLD <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[1m\"</code> define WSH_SHELL_ECS_SET_MODE_ITALIC <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[3m\"</code> define WSH_SHELL_END_LINE <code>\"\\r\\n\"</code> define WSH_SHELL_ESC_ARROW_DOWN <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[B\"</code> define WSH_SHELL_ESC_ARROW_LEFT <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[D\"</code> define WSH_SHELL_ESC_ARROW_RIGHT <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[C\"</code> define WSH_SHELL_ESC_ARROW_UP <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[A\"</code> define WSH_SHELL_ESC_CLEAR_RIGHT_FROM_CURS <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[0K\"</code> define WSH_SHELL_ESC_RESET_STYLE <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"[0m\"</code> define WSH_SHELL_ESC_RESTORE_CURSOR <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"8\"</code> define WSH_SHELL_ESC_SAVE_CURSOR <code>[**WSH\\_SHELL\\_ESC\\_SEQ\\_START\\_STR**](wsh__shell__io_8h.md#define-wsh_shell_esc_seq_start_str) \"7\"</code> define WSH_SHELL_ESC_SEQ_START_CHAR <code>'\\033'</code> define WSH_SHELL_ESC_SEQ_START_STR <code>\"\\033\"</code> define WSH_SHELL_PRINT_ERR (_f_, ...)  define WSH_SHELL_PRINT_INFO (_f_, ...)  define WSH_SHELL_PRINT_SYS (_f_, ...)  define WSH_SHELL_PRINT_WARN (_f_, ...)  define WSH_SHELL_SYM_BACKSPACE <code>'\\b'</code> define WSH_SHELL_SYM_DELETE <code>0x7f</code> define WSH_SHELL_SYM_EXIT <code>0x04</code> define WSH_SHELL_SYM_SOUND <code>0x07</code> define WSH_SHELL_SYM_TAB <code>'\\t'</code>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#detailed-description","title":"Detailed Description","text":"<p>This header provides: * Common control characters (e.g. backspace, delete, tab). * ANSI escape sequences for terminal control (cursor movement, screen clearing, text style). * Colorized print macros for various log levels (system/info/warning/error). * PS1 and newline formatting helpers. * I/O buffer structure and utility functions for handling user input.</p> <p>These utilities support consistent terminal behavior and shell interaction flow.</p> <p>Author:</p> <p>Whoosh Embedded Team </p> <p>Copyright:</p> <p>Copyright (c) 2024 </p>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#function-wshshellio_clearinterbuff","title":"function WshShellIO_ClearInterBuff","text":"<p>Clears the interaction buffer. <pre><code>void WshShellIO_ClearInterBuff (\n    WshShellIO_CommandLine_t * pCommandLine\n) \n</code></pre></p> <p>Resets buffer contents, cursor position, and line length.</p> <p>Parameters:</p> <ul> <li><code>pCommandLine</code> Pointer to the interaction buffer. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#function-wshshellio_insertsymbol","title":"function WshShellIO_InsertSymbol","text":"<p>Inserts a symbol at the current cursor position in the input buffer. <pre><code>void WshShellIO_InsertSymbol (\n    WshShellIO_CommandLine_t * pCommandLine,\n    WshShell_Char_t ch,\n    WshShell_Bool_t starsOrChars\n) \n</code></pre></p> <p>This function handles character insertion into the interaction buffer: * If the cursor is in the middle of the line (not at the end), it shifts existing characters to the right to make space for the new symbol. * The character is then written into the buffer at the cursor position using <code>WshShellIO_WriteToInterBuff</code>. * The terminal is updated to reflect the insertion, printing either the actual symbol or an asterisk (<code>*</code>) if <code>starsOrChars</code> is true (used for password masking).</p> <p>Cursor position and buffer length are updated internally. Asserts that <code>pCommandLine</code> is valid and that <code>CursorPos &gt;= 1</code> before printing.</p> <p>Parameters:</p> <ul> <li><code>pCommandLine</code> Pointer to the interaction buffer. </li> <li><code>ch</code> The symbol to insert. </li> <li><code>starsOrChars</code> If true, prints <code>*</code> instead of the actual character. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#function-wshshellio_printinterbuff","title":"function WshShellIO_PrintInterBuff","text":"<p>Prints the current interaction buffer to the terminal. <pre><code>void WshShellIO_PrintInterBuff (\n    WshShellIO_CommandLine_t * pCommandLine\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pCommandLine</code> Pointer to the interaction buffer. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#function-wshshellio_refreshconsolefrominterbuff","title":"function WshShellIO_RefreshConsoleFromInterBuff","text":"<p>Refreshes the terminal display using the interaction buffer. <pre><code>void WshShellIO_RefreshConsoleFromInterBuff (\n    WshShellIO_CommandLine_t * pCommandLine\n) \n</code></pre></p> <p>Clears the current line and reprints buffer contents.</p> <p>Parameters:</p> <ul> <li><code>pCommandLine</code> Pointer to the interaction buffer. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#function-wshshellio_removeleftsymbol","title":"function WshShellIO_RemoveLeftSymbol","text":"<p>Removes the symbol to the left of the cursor in the input buffer. <pre><code>void WshShellIO_RemoveLeftSymbol (\n    WshShellIO_CommandLine_t * pCommandLine\n) \n</code></pre></p> <p>This function handles backspace-like behavior: * If the cursor is not at the beginning of the line, it removes the symbol to the left of the cursor, shifts the rest of the line left, and updates both the buffer and terminal display. * If the cursor is beyond the line length (unexpected), only moves the cursor one position left.</p> <p>Also updates the internal buffer length and uses ANSI escape sequences to visually update the terminal.</p> <p>Parameters:</p> <ul> <li><code>pCommandLine</code> Pointer to the interaction buffer. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#function-wshshellio_writetointerbuff","title":"function WshShellIO_WriteToInterBuff","text":"<p>Writes a character into the interaction buffer at the cursor position. <pre><code>void WshShellIO_WriteToInterBuff (\n    WshShellIO_CommandLine_t * pCommandLine,\n    WshShell_Char_t symbol\n) \n</code></pre></p> <p>Increments cursor and line length accordingly.</p> <p>Parameters:</p> <ul> <li><code>pCommandLine</code> Pointer to the interaction buffer. </li> <li><code>symbol</code> Character to write. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_char_cr","title":"define WSH_SHELL_CHAR_CR","text":"<pre><code>#define WSH_SHELL_CHAR_CR `'\\r'`\n</code></pre> <p>Carriage return </p>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_char_lf","title":"define WSH_SHELL_CHAR_LF","text":"<pre><code>#define WSH_SHELL_CHAR_LF `'\\n'`\n</code></pre> <p>Line feed </p>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_color_black","title":"define WSH_SHELL_COLOR_BLACK","text":"<pre><code>#define WSH_SHELL_COLOR_BLACK `WSH_SHELL_ESC_SEQ_START_STR \"[30m\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_color_blue","title":"define WSH_SHELL_COLOR_BLUE","text":"<pre><code>#define WSH_SHELL_COLOR_BLUE `WSH_SHELL_ESC_SEQ_START_STR \"[34m\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_color_cyan","title":"define WSH_SHELL_COLOR_CYAN","text":"<pre><code>#define WSH_SHELL_COLOR_CYAN `WSH_SHELL_ESC_SEQ_START_STR \"[36m\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_color_error","title":"define WSH_SHELL_COLOR_ERROR","text":"<pre><code>#define WSH_SHELL_COLOR_ERROR `WSH_SHELL_COLOR_RED`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_color_green","title":"define WSH_SHELL_COLOR_GREEN","text":"<pre><code>#define WSH_SHELL_COLOR_GREEN `WSH_SHELL_ESC_SEQ_START_STR \"[32m\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_color_info","title":"define WSH_SHELL_COLOR_INFO","text":"<pre><code>#define WSH_SHELL_COLOR_INFO `WSH_SHELL_COLOR_WHITE`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_color_ok","title":"define WSH_SHELL_COLOR_OK","text":"<pre><code>#define WSH_SHELL_COLOR_OK `WSH_SHELL_COLOR_GREEN`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_color_purple","title":"define WSH_SHELL_COLOR_PURPLE","text":"<pre><code>#define WSH_SHELL_COLOR_PURPLE `WSH_SHELL_ESC_SEQ_START_STR \"[35m\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_color_red","title":"define WSH_SHELL_COLOR_RED","text":"<pre><code>#define WSH_SHELL_COLOR_RED `WSH_SHELL_ESC_SEQ_START_STR \"[31m\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_color_sys","title":"define WSH_SHELL_COLOR_SYS","text":"<pre><code>#define WSH_SHELL_COLOR_SYS `WSH_SHELL_COLOR_CYAN`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_color_warn","title":"define WSH_SHELL_COLOR_WARN","text":"<pre><code>#define WSH_SHELL_COLOR_WARN `WSH_SHELL_COLOR_YELLOW`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_color_white","title":"define WSH_SHELL_COLOR_WHITE","text":"<pre><code>#define WSH_SHELL_COLOR_WHITE `WSH_SHELL_ESC_SEQ_START_STR \"[37m\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_color_yellow","title":"define WSH_SHELL_COLOR_YELLOW","text":"<pre><code>#define WSH_SHELL_COLOR_YELLOW `WSH_SHELL_ESC_SEQ_START_STR \"[33m\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_ecs_clr_screen","title":"define WSH_SHELL_ECS_CLR_SCREEN","text":"<pre><code>#define WSH_SHELL_ECS_CLR_SCREEN `WSH_SHELL_ESC_SEQ_START_STR \"[1;1H\" WSH_SHELL_ESC_SEQ_START_STR \"[2J\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_ecs_reset_mode_bold","title":"define WSH_SHELL_ECS_RESET_MODE_BOLD","text":"<pre><code>#define WSH_SHELL_ECS_RESET_MODE_BOLD `WSH_SHELL_ESC_SEQ_START_STR \"[22m\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_ecs_reset_mode_italic","title":"define WSH_SHELL_ECS_RESET_MODE_ITALIC","text":"<pre><code>#define WSH_SHELL_ECS_RESET_MODE_ITALIC `WSH_SHELL_ESC_SEQ_START_STR \"[23m\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_ecs_set_mode_bold","title":"define WSH_SHELL_ECS_SET_MODE_BOLD","text":"<pre><code>#define WSH_SHELL_ECS_SET_MODE_BOLD `WSH_SHELL_ESC_SEQ_START_STR \"[1m\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_ecs_set_mode_italic","title":"define WSH_SHELL_ECS_SET_MODE_ITALIC","text":"<pre><code>#define WSH_SHELL_ECS_SET_MODE_ITALIC `WSH_SHELL_ESC_SEQ_START_STR \"[3m\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_end_line","title":"define WSH_SHELL_END_LINE","text":"<pre><code>#define WSH_SHELL_END_LINE `\"\\r\\n\"`\n</code></pre> <p>End-of-line string </p>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_esc_arrow_down","title":"define WSH_SHELL_ESC_ARROW_DOWN","text":"<pre><code>#define WSH_SHELL_ESC_ARROW_DOWN `WSH_SHELL_ESC_SEQ_START_STR \"[B\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_esc_arrow_left","title":"define WSH_SHELL_ESC_ARROW_LEFT","text":"<pre><code>#define WSH_SHELL_ESC_ARROW_LEFT `WSH_SHELL_ESC_SEQ_START_STR \"[D\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_esc_arrow_right","title":"define WSH_SHELL_ESC_ARROW_RIGHT","text":"<pre><code>#define WSH_SHELL_ESC_ARROW_RIGHT `WSH_SHELL_ESC_SEQ_START_STR \"[C\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_esc_arrow_up","title":"define WSH_SHELL_ESC_ARROW_UP","text":"<pre><code>#define WSH_SHELL_ESC_ARROW_UP `WSH_SHELL_ESC_SEQ_START_STR \"[A\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_esc_clear_right_from_curs","title":"define WSH_SHELL_ESC_CLEAR_RIGHT_FROM_CURS","text":"<pre><code>#define WSH_SHELL_ESC_CLEAR_RIGHT_FROM_CURS `WSH_SHELL_ESC_SEQ_START_STR \"[0K\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_esc_reset_style","title":"define WSH_SHELL_ESC_RESET_STYLE","text":"<pre><code>#define WSH_SHELL_ESC_RESET_STYLE `WSH_SHELL_ESC_SEQ_START_STR \"[0m\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_esc_restore_cursor","title":"define WSH_SHELL_ESC_RESTORE_CURSOR","text":"<pre><code>#define WSH_SHELL_ESC_RESTORE_CURSOR `WSH_SHELL_ESC_SEQ_START_STR \"8\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_esc_save_cursor","title":"define WSH_SHELL_ESC_SAVE_CURSOR","text":"<pre><code>#define WSH_SHELL_ESC_SAVE_CURSOR `WSH_SHELL_ESC_SEQ_START_STR \"7\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_esc_seq_start_char","title":"define WSH_SHELL_ESC_SEQ_START_CHAR","text":"<pre><code>#define WSH_SHELL_ESC_SEQ_START_CHAR `'\\033'`\n</code></pre> <p>Escape character (0x1B) </p>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_esc_seq_start_str","title":"define WSH_SHELL_ESC_SEQ_START_STR","text":"<pre><code>#define WSH_SHELL_ESC_SEQ_START_STR `\"\\033\"`\n</code></pre> <p>Escape character as string </p>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_print_err","title":"define WSH_SHELL_PRINT_ERR","text":"<pre><code>#define WSH_SHELL_PRINT_ERR (\n    _f_,\n    ...\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_print_info","title":"define WSH_SHELL_PRINT_INFO","text":"<pre><code>#define WSH_SHELL_PRINT_INFO (\n    _f_,\n    ...\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_print_sys","title":"define WSH_SHELL_PRINT_SYS","text":"<pre><code>#define WSH_SHELL_PRINT_SYS (\n    _f_,\n    ...\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_print_warn","title":"define WSH_SHELL_PRINT_WARN","text":"<pre><code>#define WSH_SHELL_PRINT_WARN (\n    _f_,\n    ...\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_sym_backspace","title":"define WSH_SHELL_SYM_BACKSPACE","text":"<pre><code>#define WSH_SHELL_SYM_BACKSPACE `'\\b'`\n</code></pre> <p>Backspace character </p>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_sym_delete","title":"define WSH_SHELL_SYM_DELETE","text":"<pre><code>#define WSH_SHELL_SYM_DELETE `0x7f`\n</code></pre> <p>Delete (DEL) character </p>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_sym_exit","title":"define WSH_SHELL_SYM_EXIT","text":"<pre><code>#define WSH_SHELL_SYM_EXIT `0x04`\n</code></pre> <p>Ctrl + D (EOF signal) </p>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_sym_sound","title":"define WSH_SHELL_SYM_SOUND","text":"<pre><code>#define WSH_SHELL_SYM_SOUND `0x07`\n</code></pre> <p>Bell character (alert) </p>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h/#define-wsh_shell_sym_tab","title":"define WSH_SHELL_SYM_TAB","text":"<pre><code>#define WSH_SHELL_SYM_TAB `'\\t'`\n</code></pre> <p>Tab character </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_io.h</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__io_8h_source/","title":"File wsh_shell_io.h","text":"<p>File List &gt; src &gt; wsh_shell_io.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __WSH_SHELL_IO_H\n#define __WSH_SHELL_IO_H\n\n#include \"wsh_shell_cfg.h\"\n#include \"wsh_shell_str.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define WSH_SHELL_SYM_BACKSPACE '\\b' \n#define WSH_SHELL_SYM_DELETE    0x7f \n#define WSH_SHELL_SYM_TAB       '\\t' \n#define WSH_SHELL_SYM_EXIT      0x04 \n#define WSH_SHELL_SYM_SOUND     0x07 \n\n#define WSH_SHELL_CHAR_CR  '\\r'   \n#define WSH_SHELL_CHAR_LF  '\\n'   \n#define WSH_SHELL_END_LINE \"\\r\\n\" \n\n#define WSH_SHELL_ESC_SEQ_START_CHAR '\\033' \n#define WSH_SHELL_ESC_SEQ_START_STR  \"\\033\" \n\n#define WSH_SHELL_ESC_SAVE_CURSOR           WSH_SHELL_ESC_SEQ_START_STR \"7\"\n#define WSH_SHELL_ESC_RESTORE_CURSOR        WSH_SHELL_ESC_SEQ_START_STR \"8\"\n#define WSH_SHELL_ESC_CLEAR_RIGHT_FROM_CURS WSH_SHELL_ESC_SEQ_START_STR \"[0K\"\n#define WSH_SHELL_ESC_ARROW_RIGHT           WSH_SHELL_ESC_SEQ_START_STR \"[C\"\n#define WSH_SHELL_ESC_ARROW_LEFT            WSH_SHELL_ESC_SEQ_START_STR \"[D\"\n#define WSH_SHELL_ESC_ARROW_UP              WSH_SHELL_ESC_SEQ_START_STR \"[A\"\n#define WSH_SHELL_ESC_ARROW_DOWN            WSH_SHELL_ESC_SEQ_START_STR \"[B\"\n\n#define WSH_SHELL_ESC_RESET_STYLE WSH_SHELL_ESC_SEQ_START_STR \"[0m\"\n#define WSH_SHELL_ECS_CLR_SCREEN \\\n    WSH_SHELL_ESC_SEQ_START_STR \"[1;1H\" WSH_SHELL_ESC_SEQ_START_STR \"[2J\"\n\n#define WSH_SHELL_ECS_SET_MODE_BOLD     WSH_SHELL_ESC_SEQ_START_STR \"[1m\"\n#define WSH_SHELL_ECS_RESET_MODE_BOLD   WSH_SHELL_ESC_SEQ_START_STR \"[22m\"\n#define WSH_SHELL_ECS_SET_MODE_ITALIC   WSH_SHELL_ESC_SEQ_START_STR \"[3m\"\n#define WSH_SHELL_ECS_RESET_MODE_ITALIC WSH_SHELL_ESC_SEQ_START_STR \"[23m\"\n\n#define WSH_SHELL_COLOR_BLACK  WSH_SHELL_ESC_SEQ_START_STR \"[30m\"\n#define WSH_SHELL_COLOR_RED    WSH_SHELL_ESC_SEQ_START_STR \"[31m\"\n#define WSH_SHELL_COLOR_GREEN  WSH_SHELL_ESC_SEQ_START_STR \"[32m\"\n#define WSH_SHELL_COLOR_YELLOW WSH_SHELL_ESC_SEQ_START_STR \"[33m\"\n#define WSH_SHELL_COLOR_BLUE   WSH_SHELL_ESC_SEQ_START_STR \"[34m\"\n#define WSH_SHELL_COLOR_PURPLE WSH_SHELL_ESC_SEQ_START_STR \"[35m\"\n#define WSH_SHELL_COLOR_CYAN   WSH_SHELL_ESC_SEQ_START_STR \"[36m\"\n#define WSH_SHELL_COLOR_WHITE  WSH_SHELL_ESC_SEQ_START_STR \"[37m\"\n\n#define WSH_SHELL_COLOR_INFO  WSH_SHELL_COLOR_WHITE\n#define WSH_SHELL_COLOR_SYS   WSH_SHELL_COLOR_CYAN\n#define WSH_SHELL_COLOR_OK    WSH_SHELL_COLOR_GREEN\n#define WSH_SHELL_COLOR_WARN  WSH_SHELL_COLOR_YELLOW\n#define WSH_SHELL_COLOR_ERROR WSH_SHELL_COLOR_RED\n\n#if WSH_SHELL_PRINT_SYS_ENABLE\n    #define WSH_SHELL_PRINT_SYS(_f_, ...) \\\n        WSH_SHELL_PRINT(WSH_SHELL_COLOR_SYS _f_ WSH_SHELL_ESC_RESET_STYLE, ##__VA_ARGS__)\n#else\n    #define WSH_SHELL_PRINT_SYS(_f_, ...)\n#endif\n\n#if WSH_SHELL_PRINT_INFO_ENABLE\n    #define WSH_SHELL_PRINT_INFO(_f_, ...) \\\n        WSH_SHELL_PRINT(WSH_SHELL_COLOR_INFO _f_ WSH_SHELL_ESC_RESET_STYLE, ##__VA_ARGS__)\n#else\n    #define WSH_SHELL_PRINT_INFO(_f_, ...)\n#endif\n\n#if WSH_SHELL_PRINT_WARN_ENABLE\n    #define WSH_SHELL_PRINT_WARN(_f_, ...) \\\n        WSH_SHELL_PRINT(WSH_SHELL_COLOR_WARN _f_ WSH_SHELL_ESC_RESET_STYLE, ##__VA_ARGS__)\n#else\n    #define WSH_SHELL_PRINT_WARN(_f_, ...)\n#endif\n\n#if WSH_SHELL_PRINT_ERR_ENABLE\n    #define WSH_SHELL_PRINT_ERR(_f_, ...) \\\n        WSH_SHELL_PRINT(WSH_SHELL_COLOR_ERROR _f_ WSH_SHELL_ESC_RESET_STYLE, ##__VA_ARGS__)\n#else\n    #define WSH_SHELL_PRINT_ERR(_f_, ...)\n#endif\n\n\ntypedef struct {\n    WshShell_Char_t Buff[WSH_SHELL_INTR_BUFF_LEN]; \n    WshShell_Size_t Len;                           \n    WshShell_Size_t CursorPos;                     \n} WshShellIO_CommandLine_t;\n\nvoid WshShellIO_ClearInterBuff(WshShellIO_CommandLine_t* pCommandLine);\n\nvoid WshShellIO_WriteToInterBuff(WshShellIO_CommandLine_t* pCommandLine, WshShell_Char_t symbol);\n\nvoid WshShellIO_PrintInterBuff(WshShellIO_CommandLine_t* pCommandLine);\n\nvoid WshShellIO_RefreshConsoleFromInterBuff(WshShellIO_CommandLine_t* pCommandLine);\n\nvoid WshShellIO_RemoveLeftSymbol(WshShellIO_CommandLine_t* pCommandLine);\n\nvoid WshShellIO_InsertSymbol(WshShellIO_CommandLine_t* pCommandLine, WshShell_Char_t ch,\n                             WshShell_Bool_t starsOrChars);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __WSH_SHELL_IO_H */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/","title":"File wsh_shell_option.h","text":"<p>FileList &gt; src &gt; wsh_shell_option.h</p> <p>Go to the source code of this file</p> <p>Definition of shell command-line option object and creation macros. More...</p> <ul> <li><code>#include \"wsh_shell_types.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#classes","title":"Classes","text":"Type Name struct WshShellOption_Context_t Option usage context during parsing. struct WshShellOption_t Represents a shell command-line option."},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#public-types","title":"Public Types","text":"Type Name enum WSH_SHELL_OPTION_TYPE_t Enumeration of all option types used by the shell."},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const WshShell_Char_t * WshShell_OptionTypeNames   = <code>/* multi line expression */</code>Human-readable names of option types."},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#public-static-functions","title":"Public Static Functions","text":"Type Name const WshShell_Char_t * WshShell_OptTypeStr_Get (WSH_SHELL_OPTION_TYPE_t optType) Return the string name of an option type."},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#macros","title":"Macros","text":"Type Name define WSH_SHELL_OPTION_TYPES_TABLE () <code>/* multi line expression */</code>Internal macro: full list of option types. define WSH_SHELL_OPT_ACCESS_ANY <code>((WshShell\\_Size\\_t)(~0U))</code> define WSH_SHELL_OPT_ACCESS_EXECUTE <code>0x04</code> define WSH_SHELL_OPT_ACCESS_NONE <code>0x00</code> define WSH_SHELL_OPT_ACCESS_READ <code>0x01</code> define WSH_SHELL_OPT_ACCESS_WRITE <code>0x02</code> define WSH_SHELL_OPT_DESCR (descr) <code>\"\"</code> define WSH_SHELL_OPT_END () <code>WSH\\_SHELL\\_OPTION\\_END, WSH\\_SHELL\\_OPT\\_ACCESS\\_ANY, 0, NULL, NULL, NULL</code>Marks the end of an option array. define WSH_SHELL_OPT_FLOAT (acc, short, long, descr) <code>WSH\\_SHELL\\_OPTION\\_FLOAT, (acc), 1, (short), (long), WSH\\_SHELL\\_OPT\\_DESCR(descr)</code>Define a float argument option. define WSH_SHELL_OPT_HELP () <code>/* multi line expression */</code>Define a built-in help option (e.g. <code>\"--help\"</code> or<code>\"-h\"</code> ). define WSH_SHELL_OPT_INT (acc, short, long, descr) <code>WSH\\_SHELL\\_OPTION\\_INT, (acc), 1, (short), (long), WSH\\_SHELL\\_OPT\\_DESCR(descr)</code>Define an integer argument option. define WSH_SHELL_OPT_INTERACT () <code>/* multi line expression */</code>Define an option for entering interactive mode. define WSH_SHELL_OPT_MULTI_ARG (acc, argnum, short, long, descr) <code>WSH\\_SHELL\\_OPTION\\_MULTI\\_ARG, (acc), (argnum), (short), (long), WSH\\_SHELL\\_OPT\\_DESCR(descr)</code>Define an option that accepts multiple arguments. define WSH_SHELL_OPT_NO (acc) <code>WSH\\_SHELL\\_OPTION\\_NO, (acc), 0, NULL, NULL, NULL</code>Define a special option that matches the command name only (no flags). define WSH_SHELL_OPT_STR (acc, short, long, descr) <code>WSH\\_SHELL\\_OPTION\\_STR, (acc), 1, (short), (long), WSH\\_SHELL\\_OPT\\_DESCR(descr)</code>Define a string argument option. define WSH_SHELL_OPT_WAITS_INPUT (acc) <code>WSH\\_SHELL\\_OPTION\\_WAITS\\_INPUT, (acc), 0, NULL, NULL, NULL</code>Define an option that triggers when input is provided with no flags. define WSH_SHELL_OPT_WO_PARAM (acc, short, long, descr) <code>WSH\\_SHELL\\_OPTION\\_WO\\_PARAM, (acc), 0, (short), (long), WSH\\_SHELL\\_OPT\\_DESCR(descr)</code>Define an option that requires no arguments. define X_ENTRY (id, str) <code>id,</code> define X_ENTRY (id, str) <code>id,</code>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#detailed-description","title":"Detailed Description","text":"<p>This file provides structures and macros for defining and managing command-line options in the WSH shell framework.</p> <p>Author:</p> <p>Whoosh Embedded Team </p> <p>Copyright:</p> <p>Copyright (c) 2024 </p>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#enum-wsh_shell_option_type_t","title":"enum WSH_SHELL_OPTION_TYPE_t","text":"<p>Enumeration of all option types used by the shell. <pre><code>enum WSH_SHELL_OPTION_TYPE_t {\n    WSH_SHELL_OPTION_TYPES_TABLE =() WSH_SHELL_OPTION_ENUM_SIZE\n};\n</code></pre></p>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#variable-wshshell_optiontypenames","title":"variable WshShell_OptionTypeNames","text":"<p>Human-readable names of option types. <pre><code>const WshShell_Char_t* WshShell_OptionTypeNames[];\n</code></pre></p>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#function-wshshell_opttypestr_get","title":"function WshShell_OptTypeStr_Get","text":"<p>Return the string name of an option type. <pre><code>static inline const WshShell_Char_t * WshShell_OptTypeStr_Get (\n    WSH_SHELL_OPTION_TYPE_t optType\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>optType</code> The option type. </li> </ul> <p>Returns:</p> <p>Option type name as string. </p>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_option_types_table","title":"define WSH_SHELL_OPTION_TYPES_TABLE","text":"<p>Internal macro: full list of option types. <pre><code>#define WSH_SHELL_OPTION_TYPES_TABLE (\n\n) `/* multi line expression */`\n</code></pre></p>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_access_any","title":"define WSH_SHELL_OPT_ACCESS_ANY","text":"<pre><code>#define WSH_SHELL_OPT_ACCESS_ANY `((WshShell_Size_t)(~0U))`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_access_execute","title":"define WSH_SHELL_OPT_ACCESS_EXECUTE","text":"<pre><code>#define WSH_SHELL_OPT_ACCESS_EXECUTE `0x04`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_access_none","title":"define WSH_SHELL_OPT_ACCESS_NONE","text":"<pre><code>#define WSH_SHELL_OPT_ACCESS_NONE `0x00`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_access_read","title":"define WSH_SHELL_OPT_ACCESS_READ","text":"<pre><code>#define WSH_SHELL_OPT_ACCESS_READ `0x01`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_access_write","title":"define WSH_SHELL_OPT_ACCESS_WRITE","text":"<pre><code>#define WSH_SHELL_OPT_ACCESS_WRITE `0x02`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_descr","title":"define WSH_SHELL_OPT_DESCR","text":"<pre><code>#define WSH_SHELL_OPT_DESCR (\n    descr\n) `\"\"`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_end","title":"define WSH_SHELL_OPT_END","text":"<p>Marks the end of an option array. <pre><code>#define WSH_SHELL_OPT_END (\n\n) `WSH_SHELL_OPTION_END, WSH_SHELL_OPT_ACCESS_ANY, 0, NULL, NULL, NULL`\n</code></pre></p>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_float","title":"define WSH_SHELL_OPT_FLOAT","text":"<p>Define a float argument option. <pre><code>#define WSH_SHELL_OPT_FLOAT (\n    acc,\n    short,\n    long,\n    descr\n) `WSH_SHELL_OPTION_FLOAT, (acc), 1, (short), (long), WSH_SHELL_OPT_DESCR(descr)`\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>acc</code> Access rights mask. </li> <li><code>short</code> Short flag. </li> <li><code>long</code> Long flag. </li> <li><code>descr</code> Help description. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_help","title":"define WSH_SHELL_OPT_HELP","text":"<p>Define a built-in help option (e.g. <code>\"--help\"</code> or<code>\"-h\"</code> ). <pre><code>#define WSH_SHELL_OPT_HELP (\n\n) `/* multi line expression */`\n</code></pre></p>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_int","title":"define WSH_SHELL_OPT_INT","text":"<p>Define an integer argument option. <pre><code>#define WSH_SHELL_OPT_INT (\n    acc,\n    short,\n    long,\n    descr\n) `WSH_SHELL_OPTION_INT, (acc), 1, (short), (long), WSH_SHELL_OPT_DESCR(descr)`\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>acc</code> Access rights mask. </li> <li><code>short</code> Short flag. </li> <li><code>long</code> Long flag. </li> <li><code>descr</code> Help description. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_interact","title":"define WSH_SHELL_OPT_INTERACT","text":"<p>Define an option for entering interactive mode. <pre><code>#define WSH_SHELL_OPT_INTERACT (\n\n) `/* multi line expression */`\n</code></pre></p>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_multi_arg","title":"define WSH_SHELL_OPT_MULTI_ARG","text":"<p>Define an option that accepts multiple arguments. <pre><code>#define WSH_SHELL_OPT_MULTI_ARG (\n    acc,\n    argnum,\n    short,\n    long,\n    descr\n) `WSH_SHELL_OPTION_MULTI_ARG, (acc), (argnum), (short), (long), WSH_SHELL_OPT_DESCR(descr)`\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>acc</code> Access rights mask. </li> <li><code>argnum</code> Number of arguments. </li> <li><code>short</code> Short flag. </li> <li><code>long</code> Long flag. </li> <li><code>descr</code> Help description. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_no","title":"define WSH_SHELL_OPT_NO","text":"<p>Define a special option that matches the command name only (no flags). <pre><code>#define WSH_SHELL_OPT_NO (\n    acc\n) `WSH_SHELL_OPTION_NO, (acc), 0, NULL, NULL, NULL`\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>acc</code> Access rights mask. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_str","title":"define WSH_SHELL_OPT_STR","text":"<p>Define a string argument option. <pre><code>#define WSH_SHELL_OPT_STR (\n    acc,\n    short,\n    long,\n    descr\n) `WSH_SHELL_OPTION_STR, (acc), 1, (short), (long), WSH_SHELL_OPT_DESCR(descr)`\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>acc</code> Access rights mask. </li> <li><code>short</code> Short flag. </li> <li><code>long</code> Long flag. </li> <li><code>descr</code> Help description. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_waits_input","title":"define WSH_SHELL_OPT_WAITS_INPUT","text":"<p>Define an option that triggers when input is provided with no flags. <pre><code>#define WSH_SHELL_OPT_WAITS_INPUT (\n    acc\n) `WSH_SHELL_OPTION_WAITS_INPUT, (acc), 0, NULL, NULL, NULL`\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>acc</code> Access rights mask. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-wsh_shell_opt_wo_param","title":"define WSH_SHELL_OPT_WO_PARAM","text":"<p>Define an option that requires no arguments. <pre><code>#define WSH_SHELL_OPT_WO_PARAM (\n    acc,\n    short,\n    long,\n    descr\n) `WSH_SHELL_OPTION_WO_PARAM, (acc), 0, (short), (long), WSH_SHELL_OPT_DESCR(descr)`\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>acc</code> Access rights mask. </li> <li><code>short</code> Short flag (e.g. <code>\"-a\"</code>). </li> <li><code>long</code> Long flag (e.g. <code>\"--all\"</code>). </li> <li><code>descr</code> Help description. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-x_entry","title":"define X_ENTRY","text":"<pre><code>#define X_ENTRY (\n    id,\n    str\n) `id,`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h/#define-x_entry_1","title":"define X_ENTRY","text":"<pre><code>#define X_ENTRY (\n    id,\n    str\n) `id,`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_option.h</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__option_8h_source/","title":"File wsh_shell_option.h","text":"<p>File List &gt; src &gt; wsh_shell_option.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __WSH_SHELL_OPTIONS_H\n#define __WSH_SHELL_OPTIONS_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include \"wsh_shell_types.h\"\n\n#define WSH_SHELL_OPT_ACCESS_NONE    0x00\n#define WSH_SHELL_OPT_ACCESS_READ    0x01\n#define WSH_SHELL_OPT_ACCESS_WRITE   0x02\n#define WSH_SHELL_OPT_ACCESS_EXECUTE 0x04\n#define WSH_SHELL_OPT_ACCESS_ANY     ((WshShell_Size_t)(~0U))\n\n#if WSH_SHELL_PRINT_OPT_HELP_ENABLE\n    #define WSH_SHELL_OPT_DESCR(descr) descr\n#else\n    #define WSH_SHELL_OPT_DESCR(descr) \"\"\n#endif\n\n#define WSH_SHELL_OPT_NO(acc) WSH_SHELL_OPTION_NO, (acc), 0, NULL, NULL, NULL\n\n#define WSH_SHELL_OPT_WAITS_INPUT(acc) WSH_SHELL_OPTION_WAITS_INPUT, (acc), 0, NULL, NULL, NULL\n\n#define WSH_SHELL_OPT_HELP()                                            \\\n    WSH_SHELL_OPTION_HELP, WSH_SHELL_OPT_ACCESS_ANY, 0, \"-h\", \"--help\", \\\n        WSH_SHELL_OPT_DESCR(\"Show command help information\")\n\n#define WSH_SHELL_OPT_INTERACT()                                                   \\\n    WSH_SHELL_OPTION_INTERACT, WSH_SHELL_OPT_ACCESS_ANY, 0, \"-i\", \"--interactive\", \\\n        WSH_SHELL_OPT_DESCR(\"Run command in interactive mode\")\n\n#define WSH_SHELL_OPT_WO_PARAM(acc, short, long, descr) \\\n    WSH_SHELL_OPTION_WO_PARAM, (acc), 0, (short), (long), WSH_SHELL_OPT_DESCR(descr)\n\n#define WSH_SHELL_OPT_MULTI_ARG(acc, argnum, short, long, descr) \\\n    WSH_SHELL_OPTION_MULTI_ARG, (acc), (argnum), (short), (long), WSH_SHELL_OPT_DESCR(descr)\n\n#define WSH_SHELL_OPT_STR(acc, short, long, descr) \\\n    WSH_SHELL_OPTION_STR, (acc), 1, (short), (long), WSH_SHELL_OPT_DESCR(descr)\n\n#define WSH_SHELL_OPT_INT(acc, short, long, descr) \\\n    WSH_SHELL_OPTION_INT, (acc), 1, (short), (long), WSH_SHELL_OPT_DESCR(descr)\n\n#define WSH_SHELL_OPT_FLOAT(acc, short, long, descr) \\\n    WSH_SHELL_OPTION_FLOAT, (acc), 1, (short), (long), WSH_SHELL_OPT_DESCR(descr)\n\n#define WSH_SHELL_OPT_END() WSH_SHELL_OPTION_END, WSH_SHELL_OPT_ACCESS_ANY, 0, NULL, NULL, NULL\n\n#define WSH_SHELL_OPTION_TYPES_TABLE()                   \\\n    X_ENTRY(WSH_SHELL_OPTION_NO, \"NO\")                   \\\n    X_ENTRY(WSH_SHELL_OPTION_HELP, \"HELP\")               \\\n    X_ENTRY(WSH_SHELL_OPTION_INTERACT, \"INTERACT\")       \\\n    X_ENTRY(WSH_SHELL_OPTION_WO_PARAM, \"WO_PARAM\")       \\\n    X_ENTRY(WSH_SHELL_OPTION_MULTI_ARG, \"MULTI_ARG\")     \\\n    X_ENTRY(WSH_SHELL_OPTION_WAITS_INPUT, \"WAITS_INPUT\") \\\n    X_ENTRY(WSH_SHELL_OPTION_STR, \"STR\")                 \\\n    X_ENTRY(WSH_SHELL_OPTION_INT, \"INT\")                 \\\n    X_ENTRY(WSH_SHELL_OPTION_FLOAT, \"FLOAT\")             \\\n    X_ENTRY(WSH_SHELL_OPTION_END, \"END\")\n\ntypedef enum {\n#define X_ENTRY(id, str) id,\n    WSH_SHELL_OPTION_TYPES_TABLE() WSH_SHELL_OPTION_ENUM_SIZE\n#undef X_ENTRY\n} WSH_SHELL_OPTION_TYPE_t;\n\nstatic const WshShell_Char_t* WshShell_OptionTypeNames[] = {\n#define X_ENTRY(id, str) str,\n    WSH_SHELL_OPTION_TYPES_TABLE()\n#undef X_ENTRY\n};\n\nstatic inline const WshShell_Char_t* WshShell_OptTypeStr_Get(WSH_SHELL_OPTION_TYPE_t optType) {\n    if (optType &gt;= WSH_SHELL_OPTION_ENUM_SIZE)\n        optType = WSH_SHELL_OPTION_NO;\n\n    return WshShell_OptionTypeNames[optType];\n}\n\ntypedef struct {\n    WshShell_Size_t ID;               \n    WSH_SHELL_OPTION_TYPE_t Type;     \n    WshShell_Size_t Access;           \n    WshShell_Size_t ArgNum;           \n    const WshShell_Char_t* ShortName; \n    const WshShell_Char_t* LongName;  \n    const WshShell_Char_t* Descr;     \n} WshShellOption_t;\n\ntypedef struct {\n    const WshShellOption_t* Option; \n    WshShell_Size_t TokenPos;       \n} WshShellOption_Context_t;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __WSH_SHELL_OPTIONS_H */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8c/","title":"File wsh_shell_promptwait.c","text":"<p>FileList &gt; src &gt; wsh_shell_promptwait.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"wsh_shell_promptwait.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8c/#public-functions","title":"Public Functions","text":"Type Name void WshShellPromptWait_Attach (WshShellPromptWait_t * pWait, WshShellPromptWait_Handler_t handler, void * pCtx) Attach a one-time input handler. WshShell_Bool_t WshShellPromptWait_Enter (WshShell_Char_t symbol, WshShellPromptWait_t * pWait) User input handler for prompt-wait mode. void WshShellPromptWait_Flush (WshShellPromptWait_t * pWait) Flush the current prompt-wait mode. WSH_SHELL_RET_STATE_t WshShellPromptWait_Handle (WshShellPromptWait_t * pWait, WshShell_Char_t symbol) Handle a symbol when in prompt-wait mode. WshShell_Bool_t WshShellPromptWait_YesNo (WshShell_Char_t symbol, WshShellPromptWait_t * pWait)"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8c/#function-wshshellpromptwait_attach","title":"function WshShellPromptWait_Attach","text":"<p>Attach a one-time input handler. <pre><code>void WshShellPromptWait_Attach (\n    WshShellPromptWait_t * pWait,\n    WshShellPromptWait_Handler_t handler,\n    void * pCtx\n) \n</code></pre></p> <p>Replaces normal shell input handling with a temporary callback. The callback will receive the first character entered by the user, after which it should typically disable itself by calling <code>WshShellPromptWait_Flush()</code>.</p> <p>Parameters:</p> <ul> <li><code>pWait</code> Pointer to prompt-wait control object. </li> <li><code>handler</code> Callback function to invoke on user input. </li> <li><code>pCtx</code> Optional pointer to user context. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8c/#function-wshshellpromptwait_enter","title":"function WshShellPromptWait_Enter","text":"<p>User input handler for prompt-wait mode. <pre><code>WshShell_Bool_t WshShellPromptWait_Enter (\n    WshShell_Char_t symbol,\n    WshShellPromptWait_t * pWait\n) \n</code></pre></p> <p>Processes a character entered by the user while waiting for specific input (e.g., Enter key, Y/N confirmation, etc.).</p> <p>Parameters:</p> <ul> <li><code>symbol</code> The character entered by the user. </li> <li><code>pWait</code> Pointer to the prompt-wait control structure. </li> </ul> <p>Returns:</p> <p>WshShell_Bool_t * true if the input was handled and waiting can end; * false if waiting should continue. </p>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8c/#function-wshshellpromptwait_flush","title":"function WshShellPromptWait_Flush","text":"<p>Flush the current prompt-wait mode. <pre><code>void WshShellPromptWait_Flush (\n    WshShellPromptWait_t * pWait\n) \n</code></pre></p> <p>Resets the handler to NULL so that normal shell input is processed.</p> <p>Parameters:</p> <ul> <li><code>pWait</code> Pointer to prompt-wait control object. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8c/#function-wshshellpromptwait_handle","title":"function WshShellPromptWait_Handle","text":"<p>Handle a symbol when in prompt-wait mode. <pre><code>WSH_SHELL_RET_STATE_t WshShellPromptWait_Handle (\n    WshShellPromptWait_t * pWait,\n    WshShell_Char_t symbol\n) \n</code></pre></p> <p>If a handler is set, it is called with the given symbol and context.</p> <p>Parameters:</p> <ul> <li><code>pWait</code> Pointer to prompt-wait control object. </li> <li><code>symbol</code> Character entered by the user. </li> </ul> <p>Returns:</p> <p>WSH_SHELL_RET_STATE_ERR_PARAM if some problems with input params WSH_SHELL_RET_STATE_ERR_EMPTY if there are no handler attached WSH_SHELL_RET_STATE_ERR_BUSY if normal shell processing should continue WSH_SHELL_RET_STATE_SUCCESS if the symbol was handled by the prompt-wait mechanism </p>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8c/#function-wshshellpromptwait_yesno","title":"function WshShellPromptWait_YesNo","text":"<pre><code>WshShell_Bool_t WshShellPromptWait_YesNo (\n    WshShell_Char_t symbol,\n    WshShellPromptWait_t * pWait\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_promptwait.c</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8c_source/","title":"File wsh_shell_promptwait.c","text":"<p>File List &gt; src &gt; wsh_shell_promptwait.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"wsh_shell_promptwait.h\"\n\nvoid WshShellPromptWait_Attach(WshShellPromptWait_t* pWait, WshShellPromptWait_Handler_t handler,\n                               void* pCtx) {\n    WSH_SHELL_ASSERT(pWait &amp;&amp; handler);\n    if (!pWait || !handler)\n        return;\n\n    pWait-&gt;Handler = handler;\n    pWait-&gt;Ctx     = pCtx;\n}\n\nvoid WshShellPromptWait_Flush(WshShellPromptWait_t* pWait) {\n    WSH_SHELL_ASSERT(pWait);\n    if (!pWait)\n        return;\n\n    pWait-&gt;Handler = NULL;\n    pWait-&gt;Ctx     = NULL;\n}\n\nWSH_SHELL_RET_STATE_t WshShellPromptWait_Handle(WshShellPromptWait_t* pWait,\n                                                WshShell_Char_t symbol) {\n    WSH_SHELL_ASSERT(pWait);\n    if (!pWait)\n        return WSH_SHELL_RET_STATE_ERR_PARAM;\n\n    if (pWait-&gt;Handler) {\n        WshShell_Bool_t res = pWait-&gt;Handler(symbol, pWait);\n        if (!res)\n            WSH_SHELL_PRINT(\"%c\", WSH_SHELL_SYM_SOUND);\n\n        return res == true ? WSH_SHELL_RET_STATE_SUCCESS : WSH_SHELL_RET_STATE_ERR_BUSY;\n    }\n\n    return WSH_SHELL_RET_STATE_ERR_EMPTY;\n}\n\nWshShell_Bool_t WshShellPromptWait_Enter(WshShell_Char_t symbol, WshShellPromptWait_t* pWait) {\n    if (symbol == '\\r' || symbol == '\\n') {\n        WshShellPromptWait_Flush(pWait);\n        return true;\n    } else {\n        WSH_SHELL_PRINT_SYS(\"Press &lt;Enter&gt; to continue...\\r\\n\");\n        return false;\n    }\n}\n\nWshShell_Bool_t WshShellPromptWait_YesNo(WshShell_Char_t symbol, WshShellPromptWait_t* pWait) {\n    if (symbol == 'Y' || symbol == 'y') {\n        WSH_SHELL_PRINT_SYS(\"Yes selected\\r\\n\");\n    } else if (symbol == 'N' || symbol == 'n') {\n        WSH_SHELL_PRINT_SYS(\"No selected\\r\\n\");\n    } else {\n        WSH_SHELL_PRINT_SYS(\"Invalid input\\r\\n\");\n        return false;\n    }\n\n    return true;\n}\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8h/","title":"File wsh_shell_promptwait.h","text":"<p>FileList &gt; src &gt; wsh_shell_promptwait.h</p> <p>Go to the source code of this file</p> <p>One-time user input waiting mechanism for WshShell. More...</p> <ul> <li><code>#include \"wsh_shell_cfg.h\"</code></li> <li><code>#include \"wsh_shell_io.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8h/#classes","title":"Classes","text":"Type Name struct WshShellPromptWait Prompt-wait control structure."},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8h/#public-types","title":"Public Types","text":"Type Name typedef WshShell_Bool_t(* WshShellPromptWait_Handler_t Function pointer type for prompt-wait callbacks. typedef struct WshShellPromptWait WshShellPromptWait_t Prompt-wait control structure."},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8h/#public-functions","title":"Public Functions","text":"Type Name void WshShellPromptWait_Attach (WshShellPromptWait_t * pWait, WshShellPromptWait_Handler_t handler, void * pCtx) Attach a one-time input handler. WshShell_Bool_t WshShellPromptWait_Enter (WshShell_Char_t symbol, WshShellPromptWait_t * pWait) User input handler for prompt-wait mode. void WshShellPromptWait_Flush (WshShellPromptWait_t * pWait) Flush the current prompt-wait mode. WSH_SHELL_RET_STATE_t WshShellPromptWait_Handle (WshShellPromptWait_t * pWait, WshShell_Char_t symbol) Handle a symbol when in prompt-wait mode. WshShell_Bool_t WshShellPromptWait_YesNo (WshShell_Char_t symbol, WshShellPromptWait_t * pWait)"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8h/#detailed-description","title":"Detailed Description","text":"<p>This module allows the shell to temporarily override normal input handling to wait for a specific key press (e.g., &lt;Enter&gt;, Y/N confirmation, etc.).</p> <p>Once the input is received, the registered callback is executed, and normal shell behavior resumes.</p> <p>Author:</p> <p>Whoosh Embedded Team </p> <p>Copyright:</p> <p>Copyright (c) 2025 </p>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8h/#typedef-wshshellpromptwait_handler_t","title":"typedef WshShellPromptWait_Handler_t","text":"<p>Function pointer type for prompt-wait callbacks. <pre><code>typedef WshShell_Bool_t(* WshShellPromptWait_Handler_t) (WshShell_Char_t symbol, struct WshShellPromptWait *pWait);\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>symbol</code> The character that was entered by the user. </li> <li><code>pCtx</code> Optional user context passed to the handler. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8h/#typedef-wshshellpromptwait_t","title":"typedef WshShellPromptWait_t","text":"<p>Prompt-wait control structure. <pre><code>typedef struct WshShellPromptWait WshShellPromptWait_t;\n</code></pre></p> <p>Holds the active handler and optional context pointer. If Handler is NULL, no prompt-wait is active. </p>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8h/#function-wshshellpromptwait_attach","title":"function WshShellPromptWait_Attach","text":"<p>Attach a one-time input handler. <pre><code>void WshShellPromptWait_Attach (\n    WshShellPromptWait_t * pWait,\n    WshShellPromptWait_Handler_t handler,\n    void * pCtx\n) \n</code></pre></p> <p>Replaces normal shell input handling with a temporary callback. The callback will receive the first character entered by the user, after which it should typically disable itself by calling <code>WshShellPromptWait_Flush()</code>.</p> <p>Parameters:</p> <ul> <li><code>pWait</code> Pointer to prompt-wait control object. </li> <li><code>handler</code> Callback function to invoke on user input. </li> <li><code>pCtx</code> Optional pointer to user context. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8h/#function-wshshellpromptwait_enter","title":"function WshShellPromptWait_Enter","text":"<p>User input handler for prompt-wait mode. <pre><code>WshShell_Bool_t WshShellPromptWait_Enter (\n    WshShell_Char_t symbol,\n    WshShellPromptWait_t * pWait\n) \n</code></pre></p> <p>Processes a character entered by the user while waiting for specific input (e.g., Enter key, Y/N confirmation, etc.).</p> <p>Parameters:</p> <ul> <li><code>symbol</code> The character entered by the user. </li> <li><code>pWait</code> Pointer to the prompt-wait control structure. </li> </ul> <p>Returns:</p> <p>WshShell_Bool_t * true if the input was handled and waiting can end; * false if waiting should continue. </p>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8h/#function-wshshellpromptwait_flush","title":"function WshShellPromptWait_Flush","text":"<p>Flush the current prompt-wait mode. <pre><code>void WshShellPromptWait_Flush (\n    WshShellPromptWait_t * pWait\n) \n</code></pre></p> <p>Resets the handler to NULL so that normal shell input is processed.</p> <p>Parameters:</p> <ul> <li><code>pWait</code> Pointer to prompt-wait control object. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8h/#function-wshshellpromptwait_handle","title":"function WshShellPromptWait_Handle","text":"<p>Handle a symbol when in prompt-wait mode. <pre><code>WSH_SHELL_RET_STATE_t WshShellPromptWait_Handle (\n    WshShellPromptWait_t * pWait,\n    WshShell_Char_t symbol\n) \n</code></pre></p> <p>If a handler is set, it is called with the given symbol and context.</p> <p>Parameters:</p> <ul> <li><code>pWait</code> Pointer to prompt-wait control object. </li> <li><code>symbol</code> Character entered by the user. </li> </ul> <p>Returns:</p> <p>WSH_SHELL_RET_STATE_ERR_PARAM if some problems with input params WSH_SHELL_RET_STATE_ERR_EMPTY if there are no handler attached WSH_SHELL_RET_STATE_ERR_BUSY if normal shell processing should continue WSH_SHELL_RET_STATE_SUCCESS if the symbol was handled by the prompt-wait mechanism </p>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8h/#function-wshshellpromptwait_yesno","title":"function WshShellPromptWait_YesNo","text":"<pre><code>WshShell_Bool_t WshShellPromptWait_YesNo (\n    WshShell_Char_t symbol,\n    WshShellPromptWait_t * pWait\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_promptwait.h</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__promptwait_8h_source/","title":"File wsh_shell_promptwait.h","text":"<p>File List &gt; src &gt; wsh_shell_promptwait.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __WSH_SHELL_PROMPTWAIT_H\n#define __WSH_SHELL_PROMPTWAIT_H\n\n#include \"wsh_shell_cfg.h\"\n#include \"wsh_shell_io.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Forward declaration of command structure\nstruct WshShellPromptWait;\n\ntypedef WshShell_Bool_t (*WshShellPromptWait_Handler_t)(WshShell_Char_t symbol,\n                                                        struct WshShellPromptWait* pWait);\n\ntypedef struct WshShellPromptWait {\n    WshShellPromptWait_Handler_t Handler;\n    void* Ctx;\n} WshShellPromptWait_t;\n\nvoid WshShellPromptWait_Attach(WshShellPromptWait_t* pWait, WshShellPromptWait_Handler_t handler,\n                               void* pCtx);\n\nvoid WshShellPromptWait_Flush(WshShellPromptWait_t* pWait);\n\nWSH_SHELL_RET_STATE_t WshShellPromptWait_Handle(WshShellPromptWait_t* pWait,\n                                                WshShell_Char_t symbol);\n\nWshShell_Bool_t WshShellPromptWait_Enter(WshShell_Char_t symbol, WshShellPromptWait_t* pWait);\nWshShell_Bool_t WshShellPromptWait_YesNo(WshShell_Char_t symbol, WshShellPromptWait_t* pWait);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __WSH_SHELL_PROMPTWAIT_H */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__str_8c/","title":"File wsh_shell_str.c","text":"<p>FileList &gt; src &gt; wsh_shell_str.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"wsh_shell_str.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__str_8c/#public-functions","title":"Public Functions","text":"Type Name void WshShellStr_AccessBitsToStr (WshShell_Size_t access, WshShell_Char_t * pOutStr) Converts access permission bits to a human-readable string like \"rwx\". void WshShellStr_DecrInterCnt (WshShell_Size_t * pInterCnt) Decrease buffer counter. void WshShellStr_GeneratePS1 (WshShell_Char_t * pPS1, WshShellStr_PS1Data_t * pPS1Data) Applies the PS1 template and generates the final PS1 string. void WshShellStr_GroupBitsToStr (WshShell_Size_t group, WshShell_Char_t * pOutStr) Converts group bitmask into symbolic group string (e.g. \"*--*\", \"---*\", etc). void WshShellStr_IncrInterCnt (WshShell_Size_t * pInterCnt, WshShell_Size_t buffSize) Increase buffer counter. WshShell_Bool_t WshShellStr_IsPrintableAscii (WshShell_Char_t ch) Check whether the given character is a printable ASCII symbol. void WshShellStr_ParseToArgcArgv (WshShell_Char_t * pStr, WshShell_Size_t * pArgNum, const WshShell_Char_t * pArgBuff, WshShell_Size_t maxArgNum) Parse a string into space-separated tokens, handling quoted substrings as single tokens. WshShell_Char_t * WshShellStr_TrimString (WshShell_Char_t * pString, WshShell_Size_t len) Trim tabulation and spaces from beginning and end of a string."},{"location":"Wsh_Shell_API/wsh__shell__str_8c/#macros","title":"Macros","text":"Type Name define WSH_PS1_SPACE_LEFT (out, base) <code>((out) - (base) &amp;lt; (WSH\\_SHELL\\_PS1\\_MAX\\_LEN - 1))</code>"},{"location":"Wsh_Shell_API/wsh__shell__str_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__str_8c/#function-wshshellstr_accessbitstostr","title":"function WshShellStr_AccessBitsToStr","text":"<p>Converts access permission bits to a human-readable string like \"rwx\". <pre><code>void WshShellStr_AccessBitsToStr (\n    WshShell_Size_t access,\n    WshShell_Char_t * pOutStr\n) \n</code></pre></p> <p>This function translates access bit flags into a POSIX-style permission string. The result is written into the provided buffer.</p> <p>The output format is: * 'r<code>if</code>WSH_SHELL_OPT_ACCESS_READ<code>is set, otherwise</code>'-'<code>-</code>'w'<code>if</code>WSH_SHELL_OPT_ACCESS_WRITE<code>is set, otherwise</code>'-'<code>-</code>'x'<code>if</code>WSH_SHELL_OPT_ACCESS_EXECUTE<code>is set, otherwise</code>'-'<code>-</code>'A'<code>if</code>access == WSH_SHELL_OPT_ACCESS_ANY` (optional fourth character)</p> <p>Examples: * <code>0x00</code> \u2192 <code>\"---\"</code> * <code>0x03</code> \u2192 <code>\"rw-\"</code> * <code>0x07</code> \u2192 <code>\"rwx\"</code> * <code>0xFFFFFFFF</code>\u2192 <code>\"rwxA\"</code></p> <p>Parameters:</p> <ul> <li><code>access</code> Bitmask of access flags (e.g. WSH_SHELL_OPT_ACCESS_READ). </li> <li><code>pOutStr</code> Buffer to write result to. Must be at least 5 bytes long. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__str_8c/#function-wshshellstr_decrintercnt","title":"function WshShellStr_DecrInterCnt","text":"<p>Decrease buffer counter. <pre><code>void WshShellStr_DecrInterCnt (\n    WshShell_Size_t * pInterCnt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pInterCnt</code> Pointer to a counter. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__str_8c/#function-wshshellstr_generateps1","title":"function WshShellStr_GeneratePS1","text":"<p>Applies the PS1 template and generates the final PS1 string. <pre><code>void WshShellStr_GeneratePS1 (\n    WshShell_Char_t * pPS1,\n    WshShellStr_PS1Data_t * pPS1Data\n) \n</code></pre></p> <p>Expands a predefined PS1 template (<code>WSH_SHELL_PS1_TEMPLATE</code>) into a complete PS1 string, substituting special format specifiers with runtime values like username, device name, and ANSI escape sequences for styling (colors, bold, reset).</p> <p>Supported format specifiers in the template: * <code>u</code> \u2014 current username (from <code>pUser</code>) * <code>d</code> \u2014 current device name (from <code>pDevice</code>) * <code>cN</code> \u2014 ANSI color code from predefined color map (0 \u2264 N \u2264 9) * <code>b</code> \u2014 ANSI escape sequence for bold text * <code>r</code> \u2014 ANSI escape sequence to reset all styles * Any unknown <code>%</code> sequence is copied verbatim as <code>X</code>.</p> <p>The output is truncated if it would exceed <code>WSH_SHELL_PS1_MAX_LEN - 1</code>. The result is always null-terminated.</p> <p>Parameters:</p> <ul> <li><code>pPS1</code> Output buffer for the final PS1 string. Must be at least <code>WSH_SHELL_PS1_MAX_LEN</code> in size. </li> <li><code>pPS1Data</code> Pointer to the user name, divice name or other strings. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__str_8c/#function-wshshellstr_groupbitstostr","title":"function WshShellStr_GroupBitsToStr","text":"<p>Converts group bitmask into symbolic group string (e.g. \"*--*\", \"---*\", etc). <pre><code>void WshShellStr_GroupBitsToStr (\n    WshShell_Size_t group,\n    WshShell_Char_t * pOutStr\n) \n</code></pre></p> <p>Produces a fixed-length string of '*' and '-' characters from highest to lowest group index.</p> <p>Example for 4 groups: * WSH_SHELL_CMD_GROUP_ADMIN = bit 0 \u2192 rightmost char * WSH_SHELL_CMD_GROUP_MANUF = bit 3 \u2192 leftmost char</p> <p>Parameters:</p> <ul> <li><code>group</code> Bitmask of groups. </li> <li><code>pOutStr</code> Output buffer (must be at least WSH_SHELL_GROUP_STR_LEN). </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__str_8c/#function-wshshellstr_incrintercnt","title":"function WshShellStr_IncrInterCnt","text":"<p>Increase buffer counter. <pre><code>void WshShellStr_IncrInterCnt (\n    WshShell_Size_t * pInterCnt,\n    WshShell_Size_t buffSize\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pInterCnt</code> Pointer to a counter. </li> <li><code>buffSize</code> Size of a buffer. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__str_8c/#function-wshshellstr_isprintableascii","title":"function WshShellStr_IsPrintableAscii","text":"<p>Check whether the given character is a printable ASCII symbol. <pre><code>WshShell_Bool_t WshShellStr_IsPrintableAscii (\n    WshShell_Char_t ch\n) \n</code></pre></p> <p>This function checks if the character belongs to the range of printable ASCII characters (from 0x20 ' ' to 0x7E '~').</p> <p>Parameters:</p> <ul> <li><code>ch</code> Character to check.</li> </ul> <p>Returns:</p> <p>true if the character is printable ASCII; false otherwise. </p>"},{"location":"Wsh_Shell_API/wsh__shell__str_8c/#function-wshshellstr_parsetoargcargv","title":"function WshShellStr_ParseToArgcArgv","text":"<p>Parse a string into space-separated tokens, handling quoted substrings as single tokens. <pre><code>void WshShellStr_ParseToArgcArgv (\n    WshShell_Char_t * pStr,\n    WshShell_Size_t * pArgNum,\n    const WshShell_Char_t * pArgBuff,\n    WshShell_Size_t maxArgNum\n) \n</code></pre></p> <p>This function splits the input string <code>pStr</code> into tokens by replacing spaces with null terminators (<code>\\0</code>). Tokens are written as pointers to the beginning of each token into the <code>pArgBuff</code> array. Quoted substrings (enclosed in double quotes <code>\"</code>), if any, are treated as a single token. Quotes themselves are removed during parsing. \u0447 </p> <p>Note:</p> <p>This function modifies the input string in-place. Spaces and quotes are replaced with <code>\\0</code>. Escaped or nested quotes are not supported.</p> <p>Example: Input: <code>\"arg1 arg2 \\\"quoted string\" arg3\"&lt;/tt&gt;  Output: &lt;tt&gt;pArgBuff = { \"arg1\", \"arg2\", \"quoted string\", \"arg3\" }</code>, <code>*pArgNum = 4</code></p> <p>Parameters:</p> <ul> <li><code>pStr</code> Pointer to the null-terminated string to be parsed. Will be modified in-place. </li> <li><code>pArgNum</code> Pointer to a counter that will be set to the number of parsed tokens. </li> <li><code>pArgBuff</code> Array of string pointers (tokens). Must be large enough to hold all tokens. </li> <li><code>maxArgNum</code> Maximum number of tokens that can be stored in <code>pArgBuff</code>. Excess tokens are discarded. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__str_8c/#function-wshshellstr_trimstring","title":"function WshShellStr_TrimString","text":"<p>Trim tabulation and spaces from beginning and end of a string. <pre><code>WshShell_Char_t * WshShellStr_TrimString (\n    WshShell_Char_t * pString,\n    WshShell_Size_t len\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pString</code> Pointer to a string to be trimmed. </li> <li><code>len</code> Length of an input string.</li> </ul> <p>Returns:</p> <p>WshShell_Char_t*: Pointer to a trimmed string. </p>"},{"location":"Wsh_Shell_API/wsh__shell__str_8c/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__str_8c/#define-wsh_ps1_space_left","title":"define WSH_PS1_SPACE_LEFT","text":"<pre><code>#define WSH_PS1_SPACE_LEFT (\n    out,\n    base\n) `((out) - (base) &lt; (WSH_SHELL_PS1_MAX_LEN - 1))`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_str.c</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__str_8c_source/","title":"File wsh_shell_str.c","text":"<p>File List &gt; src &gt; wsh_shell_str.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"wsh_shell_str.h\"\n\n#define WSH_PS1_SPACE_LEFT(out, base) ((out) - (base) &lt; (WSH_SHELL_PS1_MAX_LEN - 1))\n\nWshShell_Bool_t WshShellStr_IsPrintableAscii(WshShell_Char_t ch) {\n    return (bool)(ch &gt;= ' ' &amp;&amp; ch &lt;= '~');  // ASCII printable range\n}\n\nWshShell_Char_t* WshShellStr_TrimString(WshShell_Char_t* pString, WshShell_Size_t len) {\n    WSH_SHELL_ASSERT(pString);\n    if (!pString)\n        return pString;\n\n    WshShell_Char_t* pStrBegin = pString;\n    while (((*pStrBegin == ' ') || (*pStrBegin == '\\t')) &amp;&amp; (pStrBegin &lt; (pString + len))) {\n        pStrBegin++;\n    }\n\n    WshShell_Char_t* pStrEnd = pString + len - 1;\n    while ((pStrEnd &gt;= pStrBegin) &amp;&amp; (*pStrEnd == ' ' || *pStrEnd == '\\t')) {\n        *pStrEnd = 0;\n        pStrEnd--;\n    }\n\n    return pStrBegin;\n}\n\nvoid WshShellStr_ParseToArgcArgv(WshShell_Char_t* pStr, WshShell_Size_t* pArgNum,\n                                 const WshShell_Char_t* pArgBuff[], WshShell_Size_t maxArgNum) {\n    WSH_SHELL_ASSERT(pStr &amp;&amp; pArgNum &amp;&amp; pArgBuff &amp;&amp; maxArgNum &gt; 0);\n    if (!pStr || !pArgNum || !pArgBuff || maxArgNum == 0)\n        return;\n\n    *pArgNum                 = 0;\n    WshShell_Bool_t inQuotes = false;\n    WshShell_Size_t len      = WSH_SHELL_STRLEN(pStr);\n\n    for (WshShell_Size_t idx = 0; idx &lt; len; idx++) {\n        if (pStr[idx] == '\\\"') {\n            inQuotes  = !inQuotes;\n            pStr[idx] = '\\0';\n        } else if (!inQuotes &amp;&amp; pStr[idx] == ' ') {\n            pStr[idx] = '\\0';\n        }\n    }\n\n    // Extract pointers to tokens\n    for (WshShell_Size_t idx = 0; idx &lt; len;) {\n        if (pStr[idx] != '\\0') {\n            if (*pArgNum &lt; maxArgNum) {\n                pArgBuff[(*pArgNum)++] = &amp;pStr[idx];\n            }\n\n            // Skip until next '\\0'\n            while (idx &lt; len &amp;&amp; pStr[idx] != '\\0')\n                idx++;\n        } else {\n            idx++;\n        }\n    }\n}\n\nvoid WshShellStr_IncrInterCnt(WshShell_Size_t* pInterCnt, WshShell_Size_t buffSize) {\n    WSH_SHELL_ASSERT(pInterCnt &amp;&amp; buffSize &gt; 0);\n    if (!pInterCnt || buffSize == 0)\n        return;\n\n    if (*pInterCnt &lt; buffSize - 1)\n        (*pInterCnt)++;\n}\n\nvoid WshShellStr_DecrInterCnt(WshShell_Size_t* pInterCnt) {\n    WSH_SHELL_ASSERT(pInterCnt);\n    if (!pInterCnt)\n        return;\n\n    if (*pInterCnt &gt; 0)\n        (*pInterCnt)--;\n}\n\nvoid WshShellStr_AccessBitsToStr(WshShell_Size_t access, WshShell_Char_t* pOutStr) {\n    WSH_SHELL_ASSERT(pOutStr);\n    if (!pOutStr)\n        return;\n\n    pOutStr[0] = (access &amp; WSH_SHELL_OPT_ACCESS_READ) ? 'r' : '-';\n    pOutStr[1] = (access &amp; WSH_SHELL_OPT_ACCESS_WRITE) ? 'w' : '-';\n    pOutStr[2] = (access &amp; WSH_SHELL_OPT_ACCESS_EXECUTE) ? 'x' : '-';\n    pOutStr[3] = (access == WSH_SHELL_OPT_ACCESS_ANY) ? 'A' : '\\0';\n    pOutStr[4] = '\\0';\n}\n\nvoid WshShellStr_GroupBitsToStr(WshShell_Size_t group, WshShell_Char_t* pOutStr) {\n    WSH_SHELL_ASSERT(pOutStr);\n    if (!pOutStr)\n        return;\n\n    for (WshShell_S32_t groupIdx = WSH_SHELL_CMD_GROUP_MAX_COUNT - 1; groupIdx &gt;= 0; --groupIdx) {\n        *pOutStr++ = (group == WSH_SHELL_CMD_GROUP_ALL || (group &amp; (1U &lt;&lt; groupIdx))) ? '*' : '-';\n    }\n    *pOutStr = '\\0';\n}\n\n#if WSH_SHELL_PS1_CUSTOM\n\nstatic const WshShell_Char_t* WshShellStr_ColorMap[] = {\n    WSH_SHELL_COLOR_BLACK,   // %c0\n    WSH_SHELL_COLOR_RED,     // %c1\n    WSH_SHELL_COLOR_GREEN,   // %c2\n    WSH_SHELL_COLOR_YELLOW,  // %c3\n    WSH_SHELL_COLOR_BLUE,    // %c4\n    WSH_SHELL_COLOR_PURPLE,  // %c5\n    WSH_SHELL_COLOR_CYAN,    // %c6\n    WSH_SHELL_COLOR_WHITE    // %c7\n};\n\nvoid WshShellStr_GeneratePS1(WshShell_Char_t* pPS1, WshShellStr_PS1Data_t* pPS1Data) {\n    WSH_SHELL_ASSERT(pPS1 &amp;&amp; pPS1Data-&gt;UserName &amp;&amp; pPS1Data-&gt;DevName);\n    if (!pPS1 || !pPS1Data-&gt;UserName || !pPS1Data-&gt;DevName)\n        return;\n\n    const WshShell_Size_t colorMapSize = WSH_SHELL_ARR_LEN(WshShellStr_ColorMap);\n    WshShell_Char_t* pOut              = pPS1;\n    const WshShell_Char_t* pcIn        = WSH_SHELL_PS1_TEMPLATE;\n    const WshShell_Char_t* pcCurrColor = \"\";\n\n    while (*pcIn &amp;&amp; WSH_PS1_SPACE_LEFT(pOut, pPS1)) {\n        if (*pcIn == '%') {\n            ++pcIn;\n            if (!*pcIn)\n                break;\n\n            if (*pcIn == 'u') {  // User name\n                const WshShell_Char_t* pcUser = pPS1Data-&gt;UserName;\n                while (*pcUser &amp;&amp; WSH_PS1_SPACE_LEFT(pOut, pPS1))\n                    *pOut++ = *pcUser++;\n            } else if (*pcIn == 'd') {  // Device name\n                const WshShell_Char_t* pcDev = pPS1Data-&gt;DevName;\n                while (*pcDev &amp;&amp; WSH_PS1_SPACE_LEFT(pOut, pPS1))\n                    *pOut++ = *pcDev++;\n            } else if (*pcIn == 'c') {  // Color choice\n                ++pcIn;\n                if (*pcIn &gt;= '0' &amp;&amp; *pcIn &lt;= '9') {  // Valid colors range\n                    WshShell_Size_t idx = *pcIn - '0';\n                    const WshShell_Char_t* pcColor =\n                        (idx &lt; colorMapSize) ? WshShellStr_ColorMap[idx] : \"\";\n\n                    pcCurrColor = pcColor;\n\n                    while (*pcColor &amp;&amp; WSH_PS1_SPACE_LEFT(pOut, pPS1))\n                        *pOut++ = *pcColor++;\n                }\n            } else if (*pcIn == 'r') {  // Reset style\n                const WshShell_Char_t* pcReset = WSH_SHELL_ESC_RESET_STYLE;\n                while (*pcReset &amp;&amp; WSH_PS1_SPACE_LEFT(pOut, pPS1))\n                    *pOut++ = *pcReset++;\n            } else if (*pcIn == 'b') {  // Bold style\n                const WshShell_Char_t* pcBold = WSH_SHELL_ECS_SET_MODE_BOLD;\n                while (*pcBold &amp;&amp; WSH_PS1_SPACE_LEFT(pOut, pPS1))\n                    *pOut++ = *pcBold++;\n            } else if (*pcIn == 'i') {  // Interactive command name\n                if (pPS1Data-&gt;InterCmdName &amp;&amp; *pPS1Data-&gt;InterCmdName) {\n                    if (WSH_PS1_SPACE_LEFT(pOut, pPS1))\n                        *pOut++ = ' ';\n\n                    const WshShell_Char_t* pcWhite = WSH_SHELL_COLOR_WHITE;\n                    while (*pcWhite &amp;&amp; WSH_PS1_SPACE_LEFT(pOut, pPS1))\n                        *pOut++ = *pcWhite++;\n\n                    if (WSH_PS1_SPACE_LEFT(pOut, pPS1))\n                        *pOut++ = '(';\n\n                    const WshShell_Char_t* pcColor = pcCurrColor;\n                    while (*pcColor &amp;&amp; WSH_PS1_SPACE_LEFT(pOut, pPS1))\n                        *pOut++ = *pcColor++;\n\n                    const WshShell_Char_t* pcInter = pPS1Data-&gt;InterCmdName;\n                    while (*pcInter &amp;&amp; WSH_PS1_SPACE_LEFT(pOut, pPS1))\n                        *pOut++ = *pcInter++;\n\n                    pcWhite = WSH_SHELL_COLOR_WHITE;\n                    while (*pcWhite &amp;&amp; WSH_PS1_SPACE_LEFT(pOut, pPS1))\n                        *pOut++ = *pcWhite++;\n\n                    if (WSH_PS1_SPACE_LEFT(pOut, pPS1))\n                        *pOut++ = ')';\n                }\n            } else {\n                if (WSH_PS1_SPACE_LEFT(pOut, pPS1))\n                    *pOut++ = '%';\n                if (WSH_PS1_SPACE_LEFT(pOut, pPS1))\n                    *pOut++ = *pcIn;\n            }\n        } else {\n            *pOut++ = *pcIn;\n        }\n        ++pcIn;\n    }\n\n    *pOut = '\\0';\n}\n\n#else /* WSH_SHELL_PS1_CUSTOM */\n\nvoid WshShellStr_GeneratePS1(WshShell_Char_t* pPS1, WshShellStr_PS1Data_t* pPS1Data) {\n    WSH_SHELL_ASSERT(pPS1 &amp;&amp; pPS1Data-&gt;UserName &amp;&amp; pPS1Data-&gt;DevName);\n    if (!pPS1 || !pPS1Data-&gt;UserName || !pPS1Data-&gt;DevName)\n        return;\n\n    const WshShell_Char_t* pcInterCmd = \"\";\n\n    if (pPS1Data-&gt;InterCmdName &amp;&amp; *pPS1Data-&gt;InterCmdName) {\n        static WshShell_Char_t interCmdBuff[2 * WSH_SHELL_CMD_NAME_LEN];\n        WSH_SHELL_SNPRINTF(interCmdBuff, sizeof(interCmdBuff),\n                           WSH_SHELL_COLOR_WHITE \" (\" WSH_SHELL_COLOR_GREEN\n                                                 \"%s\" WSH_SHELL_COLOR_WHITE \")\",\n                           pPS1Data-&gt;InterCmdName);\n        pcInterCmd = interCmdBuff;\n    }\n\n    WSH_SHELL_SNPRINTF(pPS1, WSH_SHELL_PS1_MAX_LEN,\n                       WSH_SHELL_ESC_RESET_STYLE WSH_SHELL_ECS_SET_MODE_BOLD WSH_SHELL_COLOR_CYAN\n                       \"%s\" WSH_SHELL_COLOR_WHITE \"@\" WSH_SHELL_COLOR_PURPLE \"%s\"\n                       \"%s\"  // pcInterCmd\n                       WSH_SHELL_COLOR_WHITE \" &gt; \" WSH_SHELL_ESC_RESET_STYLE,\n                       pPS1Data-&gt;UserName, pPS1Data-&gt;DevName, pcInterCmd);\n}\n\n#endif /* WSH_SHELL_PS1_CUSTOM */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__str_8h/","title":"File wsh_shell_str.h","text":"<p>FileList &gt; src &gt; wsh_shell_str.h</p> <p>Go to the source code of this file</p> <p>Common string operations for user input processing. More...</p> <ul> <li><code>#include \"wsh_shell_cfg.h\"</code></li> <li><code>#include \"wsh_shell_io.h\"</code></li> <li><code>#include \"wsh_shell_option.h\"</code></li> <li><code>#include \"wsh_shell_types.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__str_8h/#classes","title":"Classes","text":"Type Name struct WshShellStr_PS1Data_t"},{"location":"Wsh_Shell_API/wsh__shell__str_8h/#public-functions","title":"Public Functions","text":"Type Name void WshShellStr_AccessBitsToStr (WshShell_Size_t access, WshShell_Char_t * pOutStr) Converts access permission bits to a human-readable string like \"rwx\". void WshShellStr_DecrInterCnt (WshShell_Size_t * pInterCnt) Decrease buffer counter. void WshShellStr_GeneratePS1 (WshShell_Char_t * pPS1, WshShellStr_PS1Data_t * pPS1Data) Applies the PS1 template and generates the final PS1 string. void WshShellStr_GroupBitsToStr (WshShell_Size_t group, WshShell_Char_t * pOutStr) Converts group bitmask into symbolic group string (e.g. \"*--*\", \"---*\", etc). void WshShellStr_IncrInterCnt (WshShell_Size_t * pInterCnt, WshShell_Size_t buffSize) Increase buffer counter. WshShell_Bool_t WshShellStr_IsPrintableAscii (WshShell_Char_t ch) Check whether the given character is a printable ASCII symbol. void WshShellStr_ParseToArgcArgv (WshShell_Char_t * pStr, WshShell_Size_t * pArgNum, const WshShell_Char_t * pArgBuff, WshShell_Size_t maxArgNum) Parse a string into space-separated tokens, handling quoted substrings as single tokens. WshShell_Char_t * WshShellStr_TrimString (WshShell_Char_t * pString, WshShell_Size_t len) Trim tabulation and spaces from beginning and end of a string."},{"location":"Wsh_Shell_API/wsh__shell__str_8h/#macros","title":"Macros","text":"Type Name define WSH_SHELL_PRESS_ENTER_TO_LOG_IN_STR <code>\"Press &amp;lt;Enter&amp;gt; to log in...\"</code>"},{"location":"Wsh_Shell_API/wsh__shell__str_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>Whoosh Embedded Team </p> <p>Copyright:</p> <p>Copyright (c) 2024 </p>"},{"location":"Wsh_Shell_API/wsh__shell__str_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__str_8h/#function-wshshellstr_accessbitstostr","title":"function WshShellStr_AccessBitsToStr","text":"<p>Converts access permission bits to a human-readable string like \"rwx\". <pre><code>void WshShellStr_AccessBitsToStr (\n    WshShell_Size_t access,\n    WshShell_Char_t * pOutStr\n) \n</code></pre></p> <p>This function translates access bit flags into a POSIX-style permission string. The result is written into the provided buffer.</p> <p>The output format is: * 'r<code>if</code>WSH_SHELL_OPT_ACCESS_READ<code>is set, otherwise</code>'-'<code>-</code>'w'<code>if</code>WSH_SHELL_OPT_ACCESS_WRITE<code>is set, otherwise</code>'-'<code>-</code>'x'<code>if</code>WSH_SHELL_OPT_ACCESS_EXECUTE<code>is set, otherwise</code>'-'<code>-</code>'A'<code>if</code>access == WSH_SHELL_OPT_ACCESS_ANY` (optional fourth character)</p> <p>Examples: * <code>0x00</code> \u2192 <code>\"---\"</code> * <code>0x03</code> \u2192 <code>\"rw-\"</code> * <code>0x07</code> \u2192 <code>\"rwx\"</code> * <code>0xFFFFFFFF</code>\u2192 <code>\"rwxA\"</code></p> <p>Parameters:</p> <ul> <li><code>access</code> Bitmask of access flags (e.g. WSH_SHELL_OPT_ACCESS_READ). </li> <li><code>pOutStr</code> Buffer to write result to. Must be at least 5 bytes long. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__str_8h/#function-wshshellstr_decrintercnt","title":"function WshShellStr_DecrInterCnt","text":"<p>Decrease buffer counter. <pre><code>void WshShellStr_DecrInterCnt (\n    WshShell_Size_t * pInterCnt\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pInterCnt</code> Pointer to a counter. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__str_8h/#function-wshshellstr_generateps1","title":"function WshShellStr_GeneratePS1","text":"<p>Applies the PS1 template and generates the final PS1 string. <pre><code>void WshShellStr_GeneratePS1 (\n    WshShell_Char_t * pPS1,\n    WshShellStr_PS1Data_t * pPS1Data\n) \n</code></pre></p> <p>Expands a predefined PS1 template (<code>WSH_SHELL_PS1_TEMPLATE</code>) into a complete PS1 string, substituting special format specifiers with runtime values like username, device name, and ANSI escape sequences for styling (colors, bold, reset).</p> <p>Supported format specifiers in the template: * <code>u</code> \u2014 current username (from <code>pUser</code>) * <code>d</code> \u2014 current device name (from <code>pDevice</code>) * <code>cN</code> \u2014 ANSI color code from predefined color map (0 \u2264 N \u2264 9) * <code>b</code> \u2014 ANSI escape sequence for bold text * <code>r</code> \u2014 ANSI escape sequence to reset all styles * Any unknown <code>%</code> sequence is copied verbatim as <code>X</code>.</p> <p>The output is truncated if it would exceed <code>WSH_SHELL_PS1_MAX_LEN - 1</code>. The result is always null-terminated.</p> <p>Parameters:</p> <ul> <li><code>pPS1</code> Output buffer for the final PS1 string. Must be at least <code>WSH_SHELL_PS1_MAX_LEN</code> in size. </li> <li><code>pPS1Data</code> Pointer to the user name, divice name or other strings. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__str_8h/#function-wshshellstr_groupbitstostr","title":"function WshShellStr_GroupBitsToStr","text":"<p>Converts group bitmask into symbolic group string (e.g. \"*--*\", \"---*\", etc). <pre><code>void WshShellStr_GroupBitsToStr (\n    WshShell_Size_t group,\n    WshShell_Char_t * pOutStr\n) \n</code></pre></p> <p>Produces a fixed-length string of '*' and '-' characters from highest to lowest group index.</p> <p>Example for 4 groups: * WSH_SHELL_CMD_GROUP_ADMIN = bit 0 \u2192 rightmost char * WSH_SHELL_CMD_GROUP_MANUF = bit 3 \u2192 leftmost char</p> <p>Parameters:</p> <ul> <li><code>group</code> Bitmask of groups. </li> <li><code>pOutStr</code> Output buffer (must be at least WSH_SHELL_GROUP_STR_LEN). </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__str_8h/#function-wshshellstr_incrintercnt","title":"function WshShellStr_IncrInterCnt","text":"<p>Increase buffer counter. <pre><code>void WshShellStr_IncrInterCnt (\n    WshShell_Size_t * pInterCnt,\n    WshShell_Size_t buffSize\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pInterCnt</code> Pointer to a counter. </li> <li><code>buffSize</code> Size of a buffer. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__str_8h/#function-wshshellstr_isprintableascii","title":"function WshShellStr_IsPrintableAscii","text":"<p>Check whether the given character is a printable ASCII symbol. <pre><code>WshShell_Bool_t WshShellStr_IsPrintableAscii (\n    WshShell_Char_t ch\n) \n</code></pre></p> <p>This function checks if the character belongs to the range of printable ASCII characters (from 0x20 ' ' to 0x7E '~').</p> <p>Parameters:</p> <ul> <li><code>ch</code> Character to check.</li> </ul> <p>Returns:</p> <p>true if the character is printable ASCII; false otherwise. </p>"},{"location":"Wsh_Shell_API/wsh__shell__str_8h/#function-wshshellstr_parsetoargcargv","title":"function WshShellStr_ParseToArgcArgv","text":"<p>Parse a string into space-separated tokens, handling quoted substrings as single tokens. <pre><code>void WshShellStr_ParseToArgcArgv (\n    WshShell_Char_t * pStr,\n    WshShell_Size_t * pArgNum,\n    const WshShell_Char_t * pArgBuff,\n    WshShell_Size_t maxArgNum\n) \n</code></pre></p> <p>This function splits the input string <code>pStr</code> into tokens by replacing spaces with null terminators (<code>\\0</code>). Tokens are written as pointers to the beginning of each token into the <code>pArgBuff</code> array. Quoted substrings (enclosed in double quotes <code>\"</code>), if any, are treated as a single token. Quotes themselves are removed during parsing. \u0447 </p> <p>Note:</p> <p>This function modifies the input string in-place. Spaces and quotes are replaced with <code>\\0</code>. Escaped or nested quotes are not supported.</p> <p>Example: Input: <code>\"arg1 arg2 \\\"quoted string\" arg3\"&lt;/tt&gt;  Output: &lt;tt&gt;pArgBuff = { \"arg1\", \"arg2\", \"quoted string\", \"arg3\" }</code>, <code>*pArgNum = 4</code></p> <p>Parameters:</p> <ul> <li><code>pStr</code> Pointer to the null-terminated string to be parsed. Will be modified in-place. </li> <li><code>pArgNum</code> Pointer to a counter that will be set to the number of parsed tokens. </li> <li><code>pArgBuff</code> Array of string pointers (tokens). Must be large enough to hold all tokens. </li> <li><code>maxArgNum</code> Maximum number of tokens that can be stored in <code>pArgBuff</code>. Excess tokens are discarded. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__str_8h/#function-wshshellstr_trimstring","title":"function WshShellStr_TrimString","text":"<p>Trim tabulation and spaces from beginning and end of a string. <pre><code>WshShell_Char_t * WshShellStr_TrimString (\n    WshShell_Char_t * pString,\n    WshShell_Size_t len\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pString</code> Pointer to a string to be trimmed. </li> <li><code>len</code> Length of an input string.</li> </ul> <p>Returns:</p> <p>WshShell_Char_t*: Pointer to a trimmed string. </p>"},{"location":"Wsh_Shell_API/wsh__shell__str_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__str_8h/#define-wsh_shell_press_enter_to_log_in_str","title":"define WSH_SHELL_PRESS_ENTER_TO_LOG_IN_STR","text":"<pre><code>#define WSH_SHELL_PRESS_ENTER_TO_LOG_IN_STR `\"Press &lt;Enter&gt; to log in...\"`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_str.h</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__str_8h_source/","title":"File wsh_shell_str.h","text":"<p>File List &gt; src &gt; wsh_shell_str.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __WSH_SHELL_STR_H\n#define __WSH_SHELL_STR_H\n\n#include \"wsh_shell_cfg.h\"\n#include \"wsh_shell_io.h\"\n#include \"wsh_shell_option.h\"\n#include \"wsh_shell_types.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define WSH_SHELL_PRESS_ENTER_TO_LOG_IN_STR \"Press &lt;Enter&gt; to log in...\"\n\ntypedef struct {\n    const WshShell_Char_t* UserName;\n    const WshShell_Char_t* DevName;\n    WshShell_Char_t* InterCmdName;\n} WshShellStr_PS1Data_t;\n\nWshShell_Bool_t WshShellStr_IsPrintableAscii(WshShell_Char_t ch);\n\nWshShell_Char_t* WshShellStr_TrimString(WshShell_Char_t* pString, WshShell_Size_t len);\n\nvoid WshShellStr_ParseToArgcArgv(WshShell_Char_t* pStr, WshShell_Size_t* pArgNum,\n                                 const WshShell_Char_t* pArgBuff[], WshShell_Size_t maxArgNum);\n\nvoid WshShellStr_IncrInterCnt(WshShell_Size_t* pInterCnt, WshShell_Size_t buffSize);\n\nvoid WshShellStr_DecrInterCnt(WshShell_Size_t* pInterCnt);\n\nvoid WshShellStr_AccessBitsToStr(WshShell_Size_t access, WshShell_Char_t* pOutStr);\n\nvoid WshShellStr_GroupBitsToStr(WshShell_Size_t group, WshShell_Char_t* pOutStr);\n\nvoid WshShellStr_GeneratePS1(WshShell_Char_t* pPS1, WshShellStr_PS1Data_t* pPS1Data);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __WSH_SHELL_STR_H */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/","title":"File wsh_shell_types.h","text":"<p>FileList &gt; src &gt; wsh_shell_types.h</p> <p>Go to the source code of this file</p> <p>Basic type definitions and return state enumeration for WshShell. More...</p> <ul> <li><code>#include &lt;stdarg.h&gt;</code></li> <li><code>#include &lt;stdbool.h&gt;</code></li> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;stdio.h&gt;</code></li> <li><code>#include &lt;stdlib.h&gt;</code></li> <li><code>#include &lt;string.h&gt;</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#public-types","title":"Public Types","text":"Type Name enum WSH_SHELL_RET_STATE_t typedef bool WshShell_Bool_t typedef char WshShell_Char_t typedef int16_t WshShell_S16_t typedef int32_t WshShell_S32_t typedef int8_t WshShell_S8_t typedef size_t WshShell_Size_t typedef uint16_t WshShell_U16_t typedef uint32_t WshShell_U32_t typedef uint8_t WshShell_U8_t"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const WshShell_Char_t * RetStateBuff   = <code>/* multi line expression */</code>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#public-static-functions","title":"Public Static Functions","text":"Type Name const WshShell_Char_t * WshShell_GetRetStateStr (WSH_SHELL_RET_STATE_t retState)"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#macros","title":"Macros","text":"Type Name define WSH_SHELL_ARR_LEN (a) <code>(sizeof((a)) / sizeof((a[0])))</code> define WSH_SHELL_RET_STATE_TABLE () <code>/* multi line expression */</code> define X_ENTRY (en, str) <code>en,</code> define X_ENTRY (en, str) <code>en,</code>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#detailed-description","title":"Detailed Description","text":"<p>This header defines common typedefs for basic data types used throughout the WshShell project, improving code readability and portability. It also defines the enumeration for return states used by shell functions, along with utility functions to convert return codes to human-readable strings.</p> <p>The file includes: * Boolean, character, and integer typedefs with explicit sizes. * Macro for calculating array length. * Enumeration of return states for consistent error and status reporting. * Inline helper to get string representation of return states.</p> <p>Author:</p> <p>Whoosh Embedded Team </p> <p>Copyright:</p> <p>Copyright (c) 2024 </p>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#enum-wsh_shell_ret_state_t","title":"enum WSH_SHELL_RET_STATE_t","text":"<pre><code>enum WSH_SHELL_RET_STATE_t {\n    WSH_SHELL_RET_STATE_TABLE =() WSH_SHELL_RET_STATE_ENUM_SIZE\n};\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#typedef-wshshell_bool_t","title":"typedef WshShell_Bool_t","text":"<pre><code>typedef bool WshShell_Bool_t;\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#typedef-wshshell_char_t","title":"typedef WshShell_Char_t","text":"<pre><code>typedef char WshShell_Char_t;\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#typedef-wshshell_s16_t","title":"typedef WshShell_S16_t","text":"<pre><code>typedef int16_t WshShell_S16_t;\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#typedef-wshshell_s32_t","title":"typedef WshShell_S32_t","text":"<pre><code>typedef int32_t WshShell_S32_t;\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#typedef-wshshell_s8_t","title":"typedef WshShell_S8_t","text":"<pre><code>typedef int8_t WshShell_S8_t;\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#typedef-wshshell_size_t","title":"typedef WshShell_Size_t","text":"<pre><code>typedef size_t WshShell_Size_t;\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#typedef-wshshell_u16_t","title":"typedef WshShell_U16_t","text":"<pre><code>typedef uint16_t WshShell_U16_t;\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#typedef-wshshell_u32_t","title":"typedef WshShell_U32_t","text":"<pre><code>typedef uint32_t WshShell_U32_t;\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#typedef-wshshell_u8_t","title":"typedef WshShell_U8_t","text":"<pre><code>typedef uint8_t WshShell_U8_t;\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#variable-retstatebuff","title":"variable RetStateBuff","text":"<pre><code>const WshShell_Char_t* RetStateBuff[];\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#function-wshshell_getretstatestr","title":"function WshShell_GetRetStateStr","text":"<pre><code>static inline const WshShell_Char_t * WshShell_GetRetStateStr (\n    WSH_SHELL_RET_STATE_t retState\n) \n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#define-wsh_shell_arr_len","title":"define WSH_SHELL_ARR_LEN","text":"<pre><code>#define WSH_SHELL_ARR_LEN (\n    a\n) `(sizeof((a)) / sizeof((a[0])))`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#define-wsh_shell_ret_state_table","title":"define WSH_SHELL_RET_STATE_TABLE","text":"<pre><code>#define WSH_SHELL_RET_STATE_TABLE (\n\n) `/* multi line expression */`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#define-x_entry","title":"define X_ENTRY","text":"<pre><code>#define X_ENTRY (\n    en,\n    str\n) `en,`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h/#define-x_entry_1","title":"define X_ENTRY","text":"<pre><code>#define X_ENTRY (\n    en,\n    str\n) `en,`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_types.h</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__types_8h_source/","title":"File wsh_shell_types.h","text":"<p>File List &gt; src &gt; wsh_shell_types.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __WSH_SHELL_TYPES_H\n#define __WSH_SHELL_TYPES_H\n\n#include &lt;stdarg.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef bool WshShell_Bool_t;  // just for better readability\ntypedef char WshShell_Char_t;  // and common perception\ntypedef int8_t WshShell_S8_t;\ntypedef uint8_t WshShell_U8_t;\ntypedef int32_t WshShell_S32_t;\ntypedef uint32_t WshShell_U32_t;\ntypedef int16_t WshShell_S16_t;\ntypedef uint16_t WshShell_U16_t;\ntypedef size_t WshShell_Size_t;\n\n#define WSH_SHELL_ARR_LEN(a) (sizeof((a)) / sizeof((a[0])))\n\n#define WSH_SHELL_RET_STATE_TABLE()                           \\\n    X_ENTRY(WSH_SHELL_RET_STATE_UNDEF, \"UNDEF\")               \\\n    X_ENTRY(WSH_SHELL_RET_STATE_SUCCESS, \"SUCCESS\")           \\\n    X_ENTRY(WSH_SHELL_RET_STATE_WARNING, \"WARNING\")           \\\n    X_ENTRY(WSH_SHELL_RET_STATE_ERROR, \"ERROR\")               \\\n    X_ENTRY(WSH_SHELL_RET_STATE_ERR_EMPTY, \"ERR_EMPTY\")       \\\n    X_ENTRY(WSH_SHELL_RET_STATE_ERR_PARAM, \"ERR_PARAM\")       \\\n    X_ENTRY(WSH_SHELL_RET_STATE_ERR_BUSY, \"ERR_BUSY\")         \\\n    X_ENTRY(WSH_SHELL_RET_STATE_ERR_OVERFLOW, \"ERR_OVERFLOW\") \\\n    X_ENTRY(WSH_SHELL_RET_STATE_ERR_MEMORY, \"ERR_MEMORY\")     \\\n    X_ENTRY(WSH_SHELL_RET_STATE_ERR_TIMEOUT, \"ERR_TIMEOUT\")   \\\n    X_ENTRY(WSH_SHELL_RET_STATE_ERR_CRC, \"ERR_CRC\")\n\ntypedef enum {\n#define X_ENTRY(en, str) en,\n    WSH_SHELL_RET_STATE_TABLE() WSH_SHELL_RET_STATE_ENUM_SIZE\n#undef X_ENTRY\n} WSH_SHELL_RET_STATE_t;\n\nstatic const WshShell_Char_t* RetStateBuff[] = {\n#define X_ENTRY(en, str) str,\n    WSH_SHELL_RET_STATE_TABLE()\n#undef X_ENTRY\n};\n\nstatic inline const WshShell_Char_t* WshShell_GetRetStateStr(WSH_SHELL_RET_STATE_t retState) {\n    if (retState &gt;= WSH_SHELL_RET_STATE_ENUM_SIZE)\n        retState = WSH_SHELL_RET_STATE_UNDEF;\n\n    return RetStateBuff[retState];\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __WSH_SHELL_TYPES_H */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__user_8c/","title":"File wsh_shell_user.c","text":"<p>FileList &gt; src &gt; wsh_shell_user.c</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"wsh_shell_user.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__user_8c/#public-functions","title":"Public Functions","text":"Type Name WSH_SHELL_RET_STATE_t WshShellUser_Attach (WshShellUser_Table_t * pShellUsers, const WshShellUser_t * pcUserTable, WshShell_Size_t userNum) Initialize the shell user table. WshShell_Bool_t WshShellUser_CheckCredentials (WshShellUser_Table_t * pShellUsers, WshShell_Size_t UserID, const WshShell_Char_t * pcLogin, const WshShell_Char_t * pcPassword) Verify login credentials of a user. void WshShellUser_DeAttach (WshShellUser_Table_t * pShellUsers) Destroy the user table. const WshShellUser_t * WshShellUser_FindByCredentials (WshShellUser_Table_t * pShellUsers, const WshShell_Char_t * pcLogin, const WshShell_Char_t * pcPass) Finds a user by login and password credentials. const WshShellUser_t * WshShellUser_GetUserByIndex (WshShellUser_Table_t * pShellUsers, WshShell_Size_t idx) Retrieve a user by index. WshShell_Size_t WshShellUser_GetUsersNum (WshShellUser_Table_t * pShellUsers) Get the number of users registered in the shell."},{"location":"Wsh_Shell_API/wsh__shell__user_8c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__user_8c/#function-wshshelluser_attach","title":"function WshShellUser_Attach","text":"<p>Initialize the shell user table. <pre><code>WSH_SHELL_RET_STATE_t WshShellUser_Attach (\n    WshShellUser_Table_t * pShellUsers,\n    const WshShellUser_t * pcUserTable,\n    WshShell_Size_t userNum\n) \n</code></pre></p> <p>Registers a static user table for the shell instance.</p> <p>Parameters:</p> <ul> <li><code>pShellUsers</code> Pointer to the shell's user table. </li> <li><code>pcUserTable</code> Pointer to the static array of user records. </li> <li><code>userNum</code> Number of users in the array.</li> </ul> <p>Return value:</p> <ul> <li><code>WSH_SHELL_RET_STATE_SUCCESS</code> Initialization succeeded. </li> <li><code>WSH_SHELL_RET_STATE_ERR_PARAM</code> Invalid input arguments. </li> <li><code>WSH_SHELL_RET_STATE_ERR_BUSY</code> Table was already initialized. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__user_8c/#function-wshshelluser_checkcredentials","title":"function WshShellUser_CheckCredentials","text":"<p>Verify login credentials of a user. <pre><code>WshShell_Bool_t WshShellUser_CheckCredentials (\n    WshShellUser_Table_t * pShellUsers,\n    WshShell_Size_t UserID,\n    const WshShell_Char_t * pcLogin,\n    const WshShell_Char_t * pcPassword\n) \n</code></pre></p> <p>Validates login and password against the given user index.</p> <p>Parameters:</p> <ul> <li><code>pShellUsers</code> Pointer to the user table. </li> <li><code>UserID</code> Index of the user to validate. </li> <li><code>pcLogin</code> Pointer to the login string. </li> <li><code>pcPassword</code> Pointer to the password string.</li> </ul> <p>Return value:</p> <ul> <li><code>true</code> If credentials match. </li> <li><code>false</code> If mismatch or error. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__user_8c/#function-wshshelluser_deattach","title":"function WshShellUser_DeAttach","text":"<p>Destroy the user table. <pre><code>void WshShellUser_DeAttach (\n    WshShellUser_Table_t * pShellUsers\n) \n</code></pre></p> <p>Resets the user list and count to zero.</p> <p>Parameters:</p> <ul> <li><code>pShellUsers</code> Pointer to the user table to reset. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__user_8c/#function-wshshelluser_findbycredentials","title":"function WshShellUser_FindByCredentials","text":"<p>Finds a user by login and password credentials. <pre><code>const WshShellUser_t * WshShellUser_FindByCredentials (\n    WshShellUser_Table_t * pShellUsers,\n    const WshShell_Char_t * pcLogin,\n    const WshShell_Char_t * pcPass\n) \n</code></pre></p> <p>Searches the given user table for a user whose login and password match the provided credentials. Comparison is done using the <code>WshShellUser_CheckCredentials</code> function.</p> <p>Parameters:</p> <ul> <li><code>pShellUsers</code> Pointer to the user table. </li> <li><code>pcLogin</code> Pointer to the login string. </li> <li><code>pcPass</code> Pointer to the password string.</li> </ul> <p>Returns:</p> <p>Pointer to the matching user object if found; NULL otherwise.</p> <p>Note:</p> <p>Returns NULL if any input pointer is NULL or if the user table is empty. </p>"},{"location":"Wsh_Shell_API/wsh__shell__user_8c/#function-wshshelluser_getuserbyindex","title":"function WshShellUser_GetUserByIndex","text":"<p>Retrieve a user by index. <pre><code>const WshShellUser_t * WshShellUser_GetUserByIndex (\n    WshShellUser_Table_t * pShellUsers,\n    WshShell_Size_t idx\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShellUsers</code> Pointer to the user table. </li> <li><code>idx</code> Index of the user.</li> </ul> <p>Returns:</p> <p>Pointer to the user object, or NULL if invalid. </p>"},{"location":"Wsh_Shell_API/wsh__shell__user_8c/#function-wshshelluser_getusersnum","title":"function WshShellUser_GetUsersNum","text":"<p>Get the number of users registered in the shell. <pre><code>WshShell_Size_t WshShellUser_GetUsersNum (\n    WshShellUser_Table_t * pShellUsers\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShellUsers</code> Pointer to the user table.</li> </ul> <p>Returns:</p> <p>Number of users, or 0 if uninitialized or NULL. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_user.c</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__user_8c_source/","title":"File wsh_shell_user.c","text":"<p>File List &gt; src &gt; wsh_shell_user.c</p> <p>Go to the documentation of this file</p> <pre><code>#include \"wsh_shell_user.h\"\n\nWSH_SHELL_RET_STATE_t WshShellUser_Attach(WshShellUser_Table_t* pShellUsers,\n                                          const WshShellUser_t* pcUserTable,\n                                          WshShell_Size_t userNum) {\n    WSH_SHELL_ASSERT(pShellUsers &amp;&amp; pcUserTable &amp;&amp; userNum &gt; 0);\n    if (!pShellUsers || !pcUserTable || userNum == 0)\n        return WSH_SHELL_RET_STATE_ERR_PARAM;\n\n    if (pShellUsers-&gt;List != NULL)\n        return WSH_SHELL_RET_STATE_ERR_BUSY;  // Already inited\n\n    pShellUsers-&gt;List = pcUserTable;\n    pShellUsers-&gt;Num  = userNum;\n\n    return WSH_SHELL_RET_STATE_SUCCESS;\n}\n\nvoid WshShellUser_DeAttach(WshShellUser_Table_t* pShellUsers) {\n    WSH_SHELL_ASSERT(pShellUsers);\n\n    if (pShellUsers)\n        *pShellUsers = (WshShellUser_Table_t){0};\n}\n\nWshShell_Size_t WshShellUser_GetUsersNum(WshShellUser_Table_t* pShellUsers) {\n    WSH_SHELL_ASSERT(pShellUsers);\n    if (!pShellUsers || !pShellUsers-&gt;List)\n        return 0;\n\n    return pShellUsers-&gt;Num;\n}\n\nconst WshShellUser_t* WshShellUser_GetUserByIndex(WshShellUser_Table_t* pShellUsers,\n                                                  WshShell_Size_t idx) {\n    WSH_SHELL_ASSERT(pShellUsers);\n    if (!pShellUsers || !pShellUsers-&gt;List)\n        return NULL;\n\n    WSH_SHELL_ASSERT(idx &lt; pShellUsers-&gt;Num);\n\n    return idx &lt; pShellUsers-&gt;Num ? &amp;pShellUsers-&gt;List[idx] : NULL;\n}\n\nWshShell_Bool_t WshShellUser_CheckCredentials(WshShellUser_Table_t* pShellUsers,\n                                              WshShell_Size_t UserID,\n                                              const WshShell_Char_t* pcLogin,\n                                              const WshShell_Char_t* pcPassword) {\n    WSH_SHELL_ASSERT(pShellUsers &amp;&amp; pcLogin &amp;&amp; pcPassword);\n    if (!pShellUsers || !pShellUsers-&gt;List || !pcLogin || !pcPassword)\n        return false;\n\n    WSH_SHELL_ASSERT(UserID &lt; pShellUsers-&gt;Num);\n\n    if (UserID &gt;= pShellUsers-&gt;Num)\n        return false;\n\n    if (WSH_SHELL_STRNLEN(pcLogin, WSH_SHELL_LOGIN_LEN + 1) &gt; WSH_SHELL_LOGIN_LEN ||\n        WSH_SHELL_STRNLEN(pcPassword, WSH_SHELL_PASS_LEN + 1) &gt; WSH_SHELL_PASS_LEN)\n        return false;\n\n    const WshShellUser_t* pUser = &amp;pShellUsers-&gt;List[UserID];\n    return WSH_SHELL_STRNCMP(pUser-&gt;Login, pcLogin, WSH_SHELL_LOGIN_LEN) == 0 &amp;&amp;\n           WSH_SHELL_STRNCMP(pUser-&gt;Pass, pcPassword, WSH_SHELL_PASS_LEN) == 0;\n}\n\nconst WshShellUser_t* WshShellUser_FindByCredentials(WshShellUser_Table_t* pShellUsers,\n                                                     const WshShell_Char_t* pcLogin,\n                                                     const WshShell_Char_t* pcPass) {\n    WSH_SHELL_ASSERT(pShellUsers &amp;&amp; pcLogin &amp;&amp; pcPass);\n    if (!pShellUsers || !pShellUsers-&gt;List || !pcLogin || !pcPass)\n        return NULL;\n\n    for (WshShell_Size_t usr = 0; usr &lt; WshShellUser_GetUsersNum(pShellUsers); usr++) {\n        if (WshShellUser_CheckCredentials(pShellUsers, usr, pcLogin, pcPass))\n            return WshShellUser_GetUserByIndex(pShellUsers, usr);\n    }\n\n    return NULL;\n}\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__user_8h/","title":"File wsh_shell_user.h","text":"<p>FileList &gt; src &gt; wsh_shell_user.h</p> <p>Go to the source code of this file</p> <p>Shell user management API. More...</p> <ul> <li><code>#include \"wsh_shell_cfg.h\"</code></li> <li><code>#include \"wsh_shell_types.h\"</code></li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__user_8h/#classes","title":"Classes","text":"Type Name struct WshShellUser_Table_t Table of registered shell users. struct WshShellUser_t User object definition."},{"location":"Wsh_Shell_API/wsh__shell__user_8h/#public-functions","title":"Public Functions","text":"Type Name WSH_SHELL_RET_STATE_t WshShellUser_Attach (WshShellUser_Table_t * pShellUsers, const WshShellUser_t * pcUserTable, WshShell_Size_t userNum) Initialize the shell user table. WshShell_Bool_t WshShellUser_CheckCredentials (WshShellUser_Table_t * pShellUsers, WshShell_Size_t UserID, const WshShell_Char_t * pcLogin, const WshShell_Char_t * pcPassword) Verify login credentials of a user. void WshShellUser_DeAttach (WshShellUser_Table_t * pShellUsers) Destroy the user table. const WshShellUser_t * WshShellUser_FindByCredentials (WshShellUser_Table_t * pShellUsers, const WshShell_Char_t * pcLogin, const WshShell_Char_t * pcPass) Finds a user by login and password credentials. const WshShellUser_t * WshShellUser_GetUserByIndex (WshShellUser_Table_t * pShellUsers, WshShell_Size_t idx) Retrieve a user by index. WshShell_Size_t WshShellUser_GetUsersNum (WshShellUser_Table_t * pShellUsers) Get the number of users registered in the shell."},{"location":"Wsh_Shell_API/wsh__shell__user_8h/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>Whoosh Embedded Team </p> <p>Copyright:</p> <p>Copyright (c) 2025 </p>"},{"location":"Wsh_Shell_API/wsh__shell__user_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__user_8h/#function-wshshelluser_attach","title":"function WshShellUser_Attach","text":"<p>Initialize the shell user table. <pre><code>WSH_SHELL_RET_STATE_t WshShellUser_Attach (\n    WshShellUser_Table_t * pShellUsers,\n    const WshShellUser_t * pcUserTable,\n    WshShell_Size_t userNum\n) \n</code></pre></p> <p>Registers a static user table for the shell instance.</p> <p>Parameters:</p> <ul> <li><code>pShellUsers</code> Pointer to the shell's user table. </li> <li><code>pcUserTable</code> Pointer to the static array of user records. </li> <li><code>userNum</code> Number of users in the array.</li> </ul> <p>Return value:</p> <ul> <li><code>WSH_SHELL_RET_STATE_SUCCESS</code> Initialization succeeded. </li> <li><code>WSH_SHELL_RET_STATE_ERR_PARAM</code> Invalid input arguments. </li> <li><code>WSH_SHELL_RET_STATE_ERR_BUSY</code> Table was already initialized. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__user_8h/#function-wshshelluser_checkcredentials","title":"function WshShellUser_CheckCredentials","text":"<p>Verify login credentials of a user. <pre><code>WshShell_Bool_t WshShellUser_CheckCredentials (\n    WshShellUser_Table_t * pShellUsers,\n    WshShell_Size_t UserID,\n    const WshShell_Char_t * pcLogin,\n    const WshShell_Char_t * pcPassword\n) \n</code></pre></p> <p>Validates login and password against the given user index.</p> <p>Parameters:</p> <ul> <li><code>pShellUsers</code> Pointer to the user table. </li> <li><code>UserID</code> Index of the user to validate. </li> <li><code>pcLogin</code> Pointer to the login string. </li> <li><code>pcPassword</code> Pointer to the password string.</li> </ul> <p>Return value:</p> <ul> <li><code>true</code> If credentials match. </li> <li><code>false</code> If mismatch or error. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__user_8h/#function-wshshelluser_deattach","title":"function WshShellUser_DeAttach","text":"<p>Destroy the user table. <pre><code>void WshShellUser_DeAttach (\n    WshShellUser_Table_t * pShellUsers\n) \n</code></pre></p> <p>Resets the user list and count to zero.</p> <p>Parameters:</p> <ul> <li><code>pShellUsers</code> Pointer to the user table to reset. </li> </ul>"},{"location":"Wsh_Shell_API/wsh__shell__user_8h/#function-wshshelluser_findbycredentials","title":"function WshShellUser_FindByCredentials","text":"<p>Finds a user by login and password credentials. <pre><code>const WshShellUser_t * WshShellUser_FindByCredentials (\n    WshShellUser_Table_t * pShellUsers,\n    const WshShell_Char_t * pcLogin,\n    const WshShell_Char_t * pcPass\n) \n</code></pre></p> <p>Searches the given user table for a user whose login and password match the provided credentials. Comparison is done using the <code>WshShellUser_CheckCredentials</code> function.</p> <p>Parameters:</p> <ul> <li><code>pShellUsers</code> Pointer to the user table. </li> <li><code>pcLogin</code> Pointer to the login string. </li> <li><code>pcPass</code> Pointer to the password string.</li> </ul> <p>Returns:</p> <p>Pointer to the matching user object if found; NULL otherwise.</p> <p>Note:</p> <p>Returns NULL if any input pointer is NULL or if the user table is empty. </p>"},{"location":"Wsh_Shell_API/wsh__shell__user_8h/#function-wshshelluser_getuserbyindex","title":"function WshShellUser_GetUserByIndex","text":"<p>Retrieve a user by index. <pre><code>const WshShellUser_t * WshShellUser_GetUserByIndex (\n    WshShellUser_Table_t * pShellUsers,\n    WshShell_Size_t idx\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShellUsers</code> Pointer to the user table. </li> <li><code>idx</code> Index of the user.</li> </ul> <p>Returns:</p> <p>Pointer to the user object, or NULL if invalid. </p>"},{"location":"Wsh_Shell_API/wsh__shell__user_8h/#function-wshshelluser_getusersnum","title":"function WshShellUser_GetUsersNum","text":"<p>Get the number of users registered in the shell. <pre><code>WshShell_Size_t WshShellUser_GetUsersNum (\n    WshShellUser_Table_t * pShellUsers\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>pShellUsers</code> Pointer to the user table.</li> </ul> <p>Returns:</p> <p>Number of users, or 0 if uninitialized or NULL. </p> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_user.h</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__user_8h_source/","title":"File wsh_shell_user.h","text":"<p>File List &gt; src &gt; wsh_shell_user.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __WSH_SHELL_USER_H\n#define __WSH_SHELL_USER_H\n\n#include \"wsh_shell_cfg.h\"\n#include \"wsh_shell_types.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n    const WshShell_Char_t* Login; \n    const WshShell_Char_t* Pass;  \n    WshShell_Size_t Groups;       \n    WshShell_Size_t Rights;       \n} WshShellUser_t;\n\ntypedef struct {\n    const WshShellUser_t* List; \n    WshShell_Size_t Num;        \n} WshShellUser_Table_t;\n\nWSH_SHELL_RET_STATE_t WshShellUser_Attach(WshShellUser_Table_t* pShellUsers,\n                                          const WshShellUser_t* pcUserTable,\n                                          WshShell_Size_t userNum);\n\nvoid WshShellUser_DeAttach(WshShellUser_Table_t* pShellUsers);\n\nWshShell_Size_t WshShellUser_GetUsersNum(WshShellUser_Table_t* pShellUsers);\n\nconst WshShellUser_t* WshShellUser_GetUserByIndex(WshShellUser_Table_t* pShellUsers,\n                                                  WshShell_Size_t idx);\n\nWshShell_Bool_t WshShellUser_CheckCredentials(WshShellUser_Table_t* pShellUsers,\n                                              WshShell_Size_t UserID,\n                                              const WshShell_Char_t* pcLogin,\n                                              const WshShell_Char_t* pcPassword);\n\nconst WshShellUser_t* WshShellUser_FindByCredentials(WshShellUser_Table_t* pShellUsers,\n                                                     const WshShell_Char_t* pcLogin,\n                                                     const WshShell_Char_t* pcPass);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __WSH_SHELL_USER_H */\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__version_8h/","title":"File wsh_shell_version.h","text":"<p>FileList &gt; src &gt; wsh_shell_version.h</p> <p>Go to the source code of this file</p>"},{"location":"Wsh_Shell_API/wsh__shell__version_8h/#macros","title":"Macros","text":"Type Name define WSH_SHELL_VERSION_MAJOR <code>2</code> define WSH_SHELL_VERSION_MINOR <code>1</code> define WSH_SHELL_VERSION_STR <code>\\_WSH\\_SHELL\\_STR(WSH\\_SHELL\\_VERSION\\_MAJOR) \".\" \\_WSH\\_SHELL\\_STR(WSH\\_SHELL\\_VERSION\\_MINOR)</code> define _WSH_SHELL_STR (x) <code>\\_WSH\\_SHELL\\_STR\\_HELPER(x)</code> define _WSH_SHELL_STR_HELPER (x) <code>#x</code>"},{"location":"Wsh_Shell_API/wsh__shell__version_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"Wsh_Shell_API/wsh__shell__version_8h/#define-wsh_shell_version_major","title":"define WSH_SHELL_VERSION_MAJOR","text":"<pre><code>#define WSH_SHELL_VERSION_MAJOR `2`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__version_8h/#define-wsh_shell_version_minor","title":"define WSH_SHELL_VERSION_MINOR","text":"<pre><code>#define WSH_SHELL_VERSION_MINOR `1`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__version_8h/#define-wsh_shell_version_str","title":"define WSH_SHELL_VERSION_STR","text":"<pre><code>#define WSH_SHELL_VERSION_STR `_WSH_SHELL_STR(WSH_SHELL_VERSION_MAJOR) \".\" _WSH_SHELL_STR(WSH_SHELL_VERSION_MINOR)`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__version_8h/#define-_wsh_shell_str","title":"define _WSH_SHELL_STR","text":"<pre><code>#define _WSH_SHELL_STR (\n    x\n) `_WSH_SHELL_STR_HELPER(x)`\n</code></pre>"},{"location":"Wsh_Shell_API/wsh__shell__version_8h/#define-_wsh_shell_str_helper","title":"define _WSH_SHELL_STR_HELPER","text":"<pre><code>#define _WSH_SHELL_STR_HELPER (\n    x\n) `#x`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/wsh_shell_version.h</code></p>"},{"location":"Wsh_Shell_API/wsh__shell__version_8h_source/","title":"File wsh_shell_version.h","text":"<p>File List &gt; src &gt; wsh_shell_version.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef __WSH_SHELL_VERSION_H\n#define __WSH_SHELL_VERSION_H\n\n#define WSH_SHELL_VERSION_MAJOR 2\n#define WSH_SHELL_VERSION_MINOR 1\n\n#define _WSH_SHELL_STR_HELPER(x) #x\n#define _WSH_SHELL_STR(x)        _WSH_SHELL_STR_HELPER(x)\n#define WSH_SHELL_VERSION_STR \\\n    _WSH_SHELL_STR(WSH_SHELL_VERSION_MAJOR) \".\" _WSH_SHELL_STR(WSH_SHELL_VERSION_MINOR)\n\n#endif /* __WSH_SHELL_VERSION_H */\n</code></pre>"},{"location":"Wsh_Shell_API/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"Wsh_Shell_API/classes/","title":"Class Index","text":""},{"location":"Wsh_Shell_API/classes/#w","title":"w","text":"<ul> <li>WshShell_AuthContext_t</li> <li>WshShell_ExtCallbacks_t</li> <li>WshShell_Interact_t</li> <li>WshShell_t</li> <li>WshShellCmd</li> <li>WshShellCmd_Table_t</li> <li>WshShellEsc_Action_t</li> <li>WshShellEsc_Storage_t</li> <li>WshShellHistory_Data_t</li> <li>WshShellHistory_IO_t</li> <li>WshShellHistory_t</li> <li>WshShellIO_CommandLine_t</li> <li>WshShellOption_Context_t</li> <li>WshShellOption_t</li> <li>WshShellPromptWait</li> <li>WshShellStr_PS1Data_t</li> <li>WshShellUser_t</li> <li>WshShellUser_Table_t</li> </ul>"},{"location":"Wsh_Shell_API/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>struct WshShellCmd Descriptor for a shell command. </li> <li>struct WshShellCmd_Table_t Table of shell commands. </li> <li>struct WshShellEsc_Action_t Escape sequence to handler mapping. </li> <li>struct WshShellEsc_Storage_t Escape sequence input state tracker. </li> <li>struct WshShellHistory_Data_t Internal structure for storing command history buffer. </li> <li>struct WshShellHistory_IO_t Structure holding function pointers for history persistence I/O. </li> <li>struct WshShellHistory_t Shell history structure with integrity check. </li> <li>struct WshShellIO_CommandLine_t Structure representing the current user input interaction state. </li> <li>struct WshShellOption_Context_t Option usage context during parsing. </li> <li>struct WshShellOption_t Represents a shell command-line option. </li> <li>struct WshShellPromptWait Prompt-wait control structure. </li> <li>struct WshShellStr_PS1Data_t </li> <li>struct WshShellUser_Table_t Table of registered shell users. </li> <li>struct WshShellUser_t User object definition. </li> <li>struct WshShell_AuthContext_t Temporary authentication context for login input handling. </li> <li>struct WshShell_ExtCallbacks_t Optional external callbacks invoked on user session changes. </li> <li>struct WshShell_Interact_t Interactive command registration structure. </li> <li>struct WshShell_t Main shell structure containing state, configuration, user context, and subsystems. </li> </ul>"},{"location":"Wsh_Shell_API/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"Wsh_Shell_API/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"Wsh_Shell_API/class_members/","title":"Class Members","text":""},{"location":"Wsh_Shell_API/class_members/#a","title":"a","text":"<ul> <li>Access (WshShellOption_t)</li> <li>ArgNum (WshShellOption_t)</li> <li>Auth (WshShell_ExtCallbacks_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#b","title":"b","text":"<ul> <li>Buff (WshShellEsc_Storage_t, WshShellIO_CommandLine_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#c","title":"c","text":"<ul> <li>Cnt (WshShellEsc_Storage_t)</li> <li>CursorPos (WshShellIO_CommandLine_t)</li> <li>Ctx (WshShellPromptWait)</li> <li>CmdName (WshShell_Interact_t)</li> <li>CommandLine (WshShell_t)</li> <li>Commands (WshShell_t)</li> <li>CurrUser (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#d","title":"d","text":"<ul> <li>Descr (WshShellCmd, WshShellOption_t)</li> <li>Data (WshShellHistory_t)</li> <li>DevName (WshShellStr_PS1Data_t)</li> <li>DeAuth (WshShell_ExtCallbacks_t)</li> <li>DeviceName (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#e","title":"e","text":"<ul> <li>EscStorage (WshShell_t)</li> <li>ExtCallbacks (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#g","title":"g","text":"<ul> <li>Groups (WshShellCmd, WshShellUser_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#h","title":"h","text":"<ul> <li>Handler (WshShellCmd, WshShellEsc_Action_t, WshShellPromptWait, WshShell_Interact_t)</li> <li>HeadIdx (WshShellHistory_Data_t)</li> <li>Hash (WshShellHistory_t)</li> <li>HistoryIO (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#i","title":"i","text":"<ul> <li>ID (WshShellOption_t)</li> <li>InterCmdName (WshShellStr_PS1Data_t)</li> <li>Interact (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#l","title":"l","text":"<ul> <li>List (WshShellCmd_Table_t, WshShellUser_Table_t)</li> <li>LastSavedCmdIdx (WshShellHistory_Data_t)</li> <li>LimitIsReached (WshShellHistory_Data_t)</li> <li>Len (WshShellIO_CommandLine_t)</li> <li>LongName (WshShellOption_t)</li> <li>Login (WshShellUser_t, WshShell_AuthContext_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#n","title":"n","text":"<ul> <li>Name (WshShellCmd)</li> <li>Num (WshShellCmd_Table_t, WshShellUser_Table_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#o","title":"o","text":"<ul> <li>OptNum (WshShellCmd)</li> <li>Options (WshShellCmd)</li> <li>Option (WshShellOption_Context_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#p","title":"p","text":"<ul> <li>PrevDir (WshShellHistory_Data_t)</li> <li>Pass (WshShellUser_t, WshShell_AuthContext_t)</li> <li>PS1 (WshShell_t)</li> <li>PrevSym (WshShell_t)</li> <li>PromptWait (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#r","title":"r","text":"<ul> <li>Read (WshShellHistory_IO_t)</li> <li>Rights (WshShellUser_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#s","title":"s","text":"<ul> <li>Sequence (WshShellEsc_Action_t)</li> <li>StorageBuff (WshShellHistory_Data_t)</li> <li>ShortName (WshShellOption_t)</li> <li>SymbolIn (WshShell_ExtCallbacks_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#t","title":"t","text":"<ul> <li>TailIdx (WshShellHistory_Data_t)</li> <li>TokenPos (WshShellOption_Context_t)</li> <li>Type (WshShellOption_t)</li> <li>TmpAuth (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#u","title":"u","text":"<ul> <li>UserName (WshShellStr_PS1Data_t)</li> <li>Users (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#v","title":"v","text":"<ul> <li>Version (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_members/#w","title":"w","text":"<ul> <li>Write (WshShellHistory_IO_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_functions/","title":"Class Member Functions","text":"<p>Nothing related to Class Member Functions found.</p>"},{"location":"Wsh_Shell_API/class_member_variables/","title":"Class Member Variables","text":""},{"location":"Wsh_Shell_API/class_member_variables/#a","title":"a","text":"<ul> <li>Access (WshShellOption_t)</li> <li>ArgNum (WshShellOption_t)</li> <li>Auth (WshShell_ExtCallbacks_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#b","title":"b","text":"<ul> <li>Buff (WshShellEsc_Storage_t, WshShellIO_CommandLine_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#c","title":"c","text":"<ul> <li>Cnt (WshShellEsc_Storage_t)</li> <li>CursorPos (WshShellIO_CommandLine_t)</li> <li>Ctx (WshShellPromptWait)</li> <li>CmdName (WshShell_Interact_t)</li> <li>CommandLine (WshShell_t)</li> <li>Commands (WshShell_t)</li> <li>CurrUser (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#d","title":"d","text":"<ul> <li>Descr (WshShellCmd, WshShellOption_t)</li> <li>Data (WshShellHistory_t)</li> <li>DevName (WshShellStr_PS1Data_t)</li> <li>DeAuth (WshShell_ExtCallbacks_t)</li> <li>DeviceName (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#e","title":"e","text":"<ul> <li>EscStorage (WshShell_t)</li> <li>ExtCallbacks (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#g","title":"g","text":"<ul> <li>Groups (WshShellCmd, WshShellUser_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#h","title":"h","text":"<ul> <li>Handler (WshShellCmd, WshShellEsc_Action_t, WshShellPromptWait, WshShell_Interact_t)</li> <li>HeadIdx (WshShellHistory_Data_t)</li> <li>Hash (WshShellHistory_t)</li> <li>HistoryIO (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#i","title":"i","text":"<ul> <li>ID (WshShellOption_t)</li> <li>InterCmdName (WshShellStr_PS1Data_t)</li> <li>Interact (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#l","title":"l","text":"<ul> <li>List (WshShellCmd_Table_t, WshShellUser_Table_t)</li> <li>LastSavedCmdIdx (WshShellHistory_Data_t)</li> <li>LimitIsReached (WshShellHistory_Data_t)</li> <li>Len (WshShellIO_CommandLine_t)</li> <li>LongName (WshShellOption_t)</li> <li>Login (WshShellUser_t, WshShell_AuthContext_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#n","title":"n","text":"<ul> <li>Name (WshShellCmd)</li> <li>Num (WshShellCmd_Table_t, WshShellUser_Table_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#o","title":"o","text":"<ul> <li>OptNum (WshShellCmd)</li> <li>Options (WshShellCmd)</li> <li>Option (WshShellOption_Context_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#p","title":"p","text":"<ul> <li>PrevDir (WshShellHistory_Data_t)</li> <li>Pass (WshShellUser_t, WshShell_AuthContext_t)</li> <li>PS1 (WshShell_t)</li> <li>PrevSym (WshShell_t)</li> <li>PromptWait (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#r","title":"r","text":"<ul> <li>Read (WshShellHistory_IO_t)</li> <li>Rights (WshShellUser_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#s","title":"s","text":"<ul> <li>Sequence (WshShellEsc_Action_t)</li> <li>StorageBuff (WshShellHistory_Data_t)</li> <li>ShortName (WshShellOption_t)</li> <li>SymbolIn (WshShell_ExtCallbacks_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#t","title":"t","text":"<ul> <li>TailIdx (WshShellHistory_Data_t)</li> <li>TokenPos (WshShellOption_Context_t)</li> <li>Type (WshShellOption_t)</li> <li>TmpAuth (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#u","title":"u","text":"<ul> <li>UserName (WshShellStr_PS1Data_t)</li> <li>Users (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#v","title":"v","text":"<ul> <li>Version (WshShell_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_variables/#w","title":"w","text":"<ul> <li>Write (WshShellHistory_IO_t)</li> </ul>"},{"location":"Wsh_Shell_API/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"Wsh_Shell_API/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"Wsh_Shell_API/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"Wsh_Shell_API/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"Wsh_Shell_API/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"Wsh_Shell_API/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"Wsh_Shell_API/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"Wsh_Shell_API/functions/","title":"Functions","text":""},{"location":"Wsh_Shell_API/functions/#s","title":"s","text":"<ul> <li>shell_cmd_def__interactive (wsh_shell_cmd_def.c)</li> </ul>"},{"location":"Wsh_Shell_API/functions/#w","title":"w","text":"<ul> <li>WshShell_Auth (wsh_shell.c, wsh_shell.h)</li> <li>WshShell_AuthHandler (wsh_shell.c)</li> <li>WshShell_DeAuth (wsh_shell.c, wsh_shell.h)</li> <li>WshShell_Init (wsh_shell.c, wsh_shell.h)</li> <li>WshShell_InsertChar (wsh_shell.c, wsh_shell.h)</li> <li>WshShell_InvitationPrint (wsh_shell.c)</li> <li>WshShell_IsAuth (wsh_shell.c, wsh_shell.h)</li> <li>WshShell_StringHandler (wsh_shell.c)</li> <li>WshShell_Stub_ExtClbk (wsh_shell.c)</li> <li>WshShell_SymbolHandler (wsh_shell.c)</li> <li>WshShellAutocomplete_Try (wsh_shell_autocomplete.c, wsh_shell_autocomplete.h)</li> <li>WshShellRetState_TranslateToProject (wsh_shell_cfg_def.h)</li> <li>WshShellCmd_Attach (wsh_shell_cmd.c, wsh_shell_cmd.h)</li> <li>WshShellCmd_DeAttach (wsh_shell_cmd.c, wsh_shell_cmd.h)</li> <li>WshShellCmd_FindOpt (wsh_shell_cmd.c)</li> <li>WshShellCmd_GetCmdByIndex (wsh_shell_cmd.c, wsh_shell_cmd.h)</li> <li>WshShellCmd_GetCmdNum (wsh_shell_cmd.c, wsh_shell_cmd.h)</li> <li>WshShellCmd_GetOptValue (wsh_shell_cmd.c, wsh_shell_cmd.h)</li> <li>WshShellCmd_ParseOpt (wsh_shell_cmd.c, wsh_shell_cmd.h)</li> <li>WshShellCmd_PrintInfo (wsh_shell_cmd.c, wsh_shell_cmd.h)</li> <li>WshShellCmd_SearchCmd (wsh_shell_cmd.c, wsh_shell_cmd.h)</li> <li>WshShellCmdDef (wsh_shell_cmd_def.c)</li> <li>WshShellDefCmd_GetPtr (wsh_shell_cmd_def.c, wsh_shell_cmd_def.h)</li> <li>WshShellEsc_ArrowDown (wsh_shell_esc.c)</li> <li>WshShellEsc_ArrowLeft (wsh_shell_esc.c)</li> <li>WshShellEsc_ArrowRight (wsh_shell_esc.c)</li> <li>WshShellEsc_ArrowUp (wsh_shell_esc.c)</li> <li>WshShellEsc_ClearStorage (wsh_shell_esc.c)</li> <li>WshShellEsc_Handler (wsh_shell_esc.c, wsh_shell_esc.h)</li> <li>WshShellEsc_IsSeqStarted (wsh_shell_esc.c, wsh_shell_esc.h)</li> <li>WshShellEsc_StartSeq (wsh_shell_esc.c, wsh_shell_esc.h)</li> <li>WshShellHistory_Flush (wsh_shell_history.c, wsh_shell_history.h)</li> <li>WshShellHistory_GetNextCmd (wsh_shell_history.c, wsh_shell_history.h)</li> <li>WshShellHistory_GetPrevCmd (wsh_shell_history.c, wsh_shell_history.h)</li> <li>WshShellHistory_GetTokenByIndex (wsh_shell_history.c, wsh_shell_history.h)</li> <li>WshShellHistory_GetTokenNum (wsh_shell_history.c, wsh_shell_history.h)</li> <li>WshShellHistory_Init (wsh_shell_history.c, wsh_shell_history.h)</li> <li>WshShellHistory_SaveCmd (wsh_shell_history.c, wsh_shell_history.h)</li> <li>WshShellInteract_AppendLineBreak (wsh_shell_interact.c, wsh_shell_interact.h)</li> <li>WshShellInteract_Attach (wsh_shell_interact.c, wsh_shell_interact.h)</li> <li>WshShellInteract_Flush (wsh_shell_interact.c, wsh_shell_interact.h)</li> <li>WshShellIO_ClearInterBuff (wsh_shell_io.c, wsh_shell_io.h)</li> <li>WshShellIO_InsertSymbol (wsh_shell_io.c, wsh_shell_io.h)</li> <li>WshShellIO_PrintInterBuff (wsh_shell_io.c, wsh_shell_io.h)</li> <li>WshShellIO_RefreshConsoleFromInterBuff (wsh_shell_io.c, wsh_shell_io.h)</li> <li>WshShellIO_RemoveLeftSymbol (wsh_shell_io.c, wsh_shell_io.h)</li> <li>WshShellIO_WriteToInterBuff (wsh_shell_io.c, wsh_shell_io.h)</li> <li>WshShell_OptTypeStr_Get (wsh_shell_option.h)</li> <li>WshShellPromptWait_Attach (wsh_shell_promptwait.c, wsh_shell_promptwait.h)</li> <li>WshShellPromptWait_Enter (wsh_shell_promptwait.c, wsh_shell_promptwait.h)</li> <li>WshShellPromptWait_Flush (wsh_shell_promptwait.c, wsh_shell_promptwait.h)</li> <li>WshShellPromptWait_Handle (wsh_shell_promptwait.c, wsh_shell_promptwait.h)</li> <li>WshShellPromptWait_YesNo (wsh_shell_promptwait.c, wsh_shell_promptwait.h)</li> <li>WshShellStr_AccessBitsToStr (wsh_shell_str.c, wsh_shell_str.h)</li> <li>WshShellStr_DecrInterCnt (wsh_shell_str.c, wsh_shell_str.h)</li> <li>WshShellStr_GeneratePS1 (wsh_shell_str.c, wsh_shell_str.h)</li> <li>WshShellStr_GroupBitsToStr (wsh_shell_str.c, wsh_shell_str.h)</li> <li>WshShellStr_IncrInterCnt (wsh_shell_str.c, wsh_shell_str.h)</li> <li>WshShellStr_IsPrintableAscii (wsh_shell_str.c, wsh_shell_str.h)</li> <li>WshShellStr_ParseToArgcArgv (wsh_shell_str.c, wsh_shell_str.h)</li> <li>WshShellStr_TrimString (wsh_shell_str.c, wsh_shell_str.h)</li> <li>WshShell_GetRetStateStr (wsh_shell_types.h)</li> <li>WshShellUser_Attach (wsh_shell_user.c, wsh_shell_user.h)</li> <li>WshShellUser_CheckCredentials (wsh_shell_user.c, wsh_shell_user.h)</li> <li>WshShellUser_DeAttach (wsh_shell_user.c, wsh_shell_user.h)</li> <li>WshShellUser_FindByCredentials (wsh_shell_user.c, wsh_shell_user.h)</li> <li>WshShellUser_GetUserByIndex (wsh_shell_user.c, wsh_shell_user.h)</li> <li>WshShellUser_GetUsersNum (wsh_shell_user.c, wsh_shell_user.h)</li> </ul>"},{"location":"Wsh_Shell_API/macros/","title":"Macros","text":""},{"location":"Wsh_Shell_API/macros/#r","title":"r","text":"<ul> <li>RET_STATE_MAP_TABLE (wsh_shell_cfg_def.h)</li> </ul>"},{"location":"Wsh_Shell_API/macros/#s","title":"s","text":"<ul> <li>SHELL_SAVE_PREV_AND_RETURN (wsh_shell.c)</li> </ul>"},{"location":"Wsh_Shell_API/macros/#w","title":"w","text":"<ul> <li>WSH_SHELL_INTER_CMD_EXISTS (wsh_shell.c)</li> <li>WSH_SHELL_TMP_LOGIN_IS_EMPTY (wsh_shell.c)</li> <li>WSH_SHELL_TMP_PASS_IS_EMPTY (wsh_shell.c)</li> <li>WSH_SHELL_USER_IS_AUTH (wsh_shell.c)</li> <li>WSH_SHELL_ASSERT (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_AUTOCOMPLETE (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_AUTOCOMPLETE_PAD_LEN (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_AUTOCOMPLETE_PAD_SYM (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_CMD_ARGS_MAX_NUM (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_CMD_GROUP_ADMIN (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_CMD_GROUP_ALL (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_CMD_GROUP_MAX_COUNT (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_CMD_GROUP_NONE (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_CMD_GROUP_READER (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_CMD_NAME_LEN (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_CMD_OPTIONS_MAX_NUM (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_DEV_NAME_LEN (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_ESC_BUFF_LEN (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_HEADER (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_HISTORY (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_HISTORY_BUFF_SIZE (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_INTERACTIVE_MODE (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_INTR_BUFF_LEN (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_LOGIN_LEN (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_MEMCMP (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_MEMCPY (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_MEMSET (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_OPTION_LONG_NAME_LEN (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_OPTION_SHORT_NAME_LEN (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_PASS_LEN (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_PRINT (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_PRINT_ERR_ENABLE (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_PRINT_INFO_ENABLE (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_PRINT_OPT_HELP_ENABLE (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_PRINT_SYS_ENABLE (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_PRINT_WARN_ENABLE (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_PS1_CUSTOM (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_PS1_MAX_LEN (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_PS1_TEMPLATE (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_SNPRINTF (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_STRCMP (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_STRCPY (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_STRLEN (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_STRNCMP (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_STRNCPY (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_STRNLEN (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_STRTOF (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_STRTOL (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_USER_ACCESS_ADMIN (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_USER_ACCESS_READER (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_USER_GROUP_ADMIN (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_USER_GROUP_READER (wsh_shell_cfg_def.h)</li> <li>WSH_SHELL_CMD_DEF_OPT_TABLE (wsh_shell_cmd_def.c)</li> <li>WSH_SHELL_CHAR_CR (wsh_shell_io.h)</li> <li>WSH_SHELL_CHAR_LF (wsh_shell_io.h)</li> <li>WSH_SHELL_COLOR_BLACK (wsh_shell_io.h)</li> <li>WSH_SHELL_COLOR_BLUE (wsh_shell_io.h)</li> <li>WSH_SHELL_COLOR_CYAN (wsh_shell_io.h)</li> <li>WSH_SHELL_COLOR_ERROR (wsh_shell_io.h)</li> <li>WSH_SHELL_COLOR_GREEN (wsh_shell_io.h)</li> <li>WSH_SHELL_COLOR_INFO (wsh_shell_io.h)</li> <li>WSH_SHELL_COLOR_OK (wsh_shell_io.h)</li> <li>WSH_SHELL_COLOR_PURPLE (wsh_shell_io.h)</li> <li>WSH_SHELL_COLOR_RED (wsh_shell_io.h)</li> <li>WSH_SHELL_COLOR_SYS (wsh_shell_io.h)</li> <li>WSH_SHELL_COLOR_WARN (wsh_shell_io.h)</li> <li>WSH_SHELL_COLOR_WHITE (wsh_shell_io.h)</li> <li>WSH_SHELL_COLOR_YELLOW (wsh_shell_io.h)</li> <li>WSH_SHELL_ECS_CLR_SCREEN (wsh_shell_io.h)</li> <li>WSH_SHELL_ECS_RESET_MODE_BOLD (wsh_shell_io.h)</li> <li>WSH_SHELL_ECS_RESET_MODE_ITALIC (wsh_shell_io.h)</li> <li>WSH_SHELL_ECS_SET_MODE_BOLD (wsh_shell_io.h)</li> <li>WSH_SHELL_ECS_SET_MODE_ITALIC (wsh_shell_io.h)</li> <li>WSH_SHELL_END_LINE (wsh_shell_io.h)</li> <li>WSH_SHELL_ESC_ARROW_DOWN (wsh_shell_io.h)</li> <li>WSH_SHELL_ESC_ARROW_LEFT (wsh_shell_io.h)</li> <li>WSH_SHELL_ESC_ARROW_RIGHT (wsh_shell_io.h)</li> <li>WSH_SHELL_ESC_ARROW_UP (wsh_shell_io.h)</li> <li>WSH_SHELL_ESC_CLEAR_RIGHT_FROM_CURS (wsh_shell_io.h)</li> <li>WSH_SHELL_ESC_RESET_STYLE (wsh_shell_io.h)</li> <li>WSH_SHELL_ESC_RESTORE_CURSOR (wsh_shell_io.h)</li> <li>WSH_SHELL_ESC_SAVE_CURSOR (wsh_shell_io.h)</li> <li>WSH_SHELL_ESC_SEQ_START_CHAR (wsh_shell_io.h)</li> <li>WSH_SHELL_ESC_SEQ_START_STR (wsh_shell_io.h)</li> <li>WSH_SHELL_PRINT_ERR (wsh_shell_io.h)</li> <li>WSH_SHELL_PRINT_INFO (wsh_shell_io.h)</li> <li>WSH_SHELL_PRINT_SYS (wsh_shell_io.h)</li> <li>WSH_SHELL_PRINT_WARN (wsh_shell_io.h)</li> <li>WSH_SHELL_SYM_BACKSPACE (wsh_shell_io.h)</li> <li>WSH_SHELL_SYM_DELETE (wsh_shell_io.h)</li> <li>WSH_SHELL_SYM_EXIT (wsh_shell_io.h)</li> <li>WSH_SHELL_SYM_SOUND (wsh_shell_io.h)</li> <li>WSH_SHELL_SYM_TAB (wsh_shell_io.h)</li> <li>WSH_SHELL_OPTION_TYPES_TABLE (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_ACCESS_ANY (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_ACCESS_EXECUTE (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_ACCESS_NONE (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_ACCESS_READ (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_ACCESS_WRITE (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_DESCR (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_END (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_FLOAT (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_HELP (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_INT (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_INTERACT (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_MULTI_ARG (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_NO (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_STR (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_WAITS_INPUT (wsh_shell_option.h)</li> <li>WSH_SHELL_OPT_WO_PARAM (wsh_shell_option.h)</li> <li>WSH_PS1_SPACE_LEFT (wsh_shell_str.c)</li> <li>WSH_SHELL_PRESS_ENTER_TO_LOG_IN_STR (wsh_shell_str.h)</li> <li>WSH_SHELL_ARR_LEN (wsh_shell_types.h)</li> <li>WSH_SHELL_RET_STATE_TABLE (wsh_shell_types.h)</li> <li>WSH_SHELL_VERSION_MAJOR (wsh_shell_version.h)</li> <li>WSH_SHELL_VERSION_MINOR (wsh_shell_version.h)</li> <li>WSH_SHELL_VERSION_STR (wsh_shell_version.h)</li> </ul>"},{"location":"Wsh_Shell_API/macros/#x","title":"x","text":"<ul> <li>X_MAP_ENTRY (wsh_shell_cfg_def.h)</li> <li>X_CMD_ENTRY (wsh_shell_cmd_def.c)</li> <li>X_ENTRY (wsh_shell_option.h, wsh_shell_types.h)</li> </ul>"},{"location":"Wsh_Shell_API/macros/#_","title":"_","text":"<ul> <li>_WSH_SHELL_STR (wsh_shell_version.h)</li> <li>_WSH_SHELL_STR_HELPER (wsh_shell_version.h)</li> </ul>"},{"location":"Wsh_Shell_API/variables/","title":"Variables","text":""},{"location":"Wsh_Shell_API/variables/#o","title":"o","text":"<ul> <li>OptArr (wsh_shell_cmd_def.c)</li> </ul>"},{"location":"Wsh_Shell_API/variables/#r","title":"r","text":"<ul> <li>RetStateBuff (wsh_shell_types.h)</li> </ul>"},{"location":"Wsh_Shell_API/variables/#w","title":"w","text":"<ul> <li>WshShell_ExtClbk_t (wsh_shell.h)</li> <li>WshShellCmdHandler_t (wsh_shell_cmd.h)</li> <li>WshShellCmd_t (wsh_shell_cmd.h)</li> <li>WSH_SHELL_DEF_OPT_t (wsh_shell_cmd_def.c)</li> <li>WshShellDefCmd (wsh_shell_cmd_def.c)</li> <li>WshShellEsc_SeqHandlers (wsh_shell_esc.c)</li> <li>WshShellEsc_Hadler_t (wsh_shell_esc.h)</li> <li>WSH_SHELL_HIST_CMD_DIR_t (wsh_shell_history.h)</li> <li>WshShellHistory_ReadHandler_t (wsh_shell_history.h)</li> <li>WshShellHistory_WriteHandler_t (wsh_shell_history.h)</li> <li>WshShellInteractive_CmdHandler_t (wsh_shell_interact.h)</li> <li>WshShellIO_InsertStringTemplate (wsh_shell_io.c)</li> <li>WSH_SHELL_OPTION_TYPE_t (wsh_shell_option.h)</li> <li>WshShell_OptionTypeNames (wsh_shell_option.h)</li> <li>WshShellPromptWait_Handler_t (wsh_shell_promptwait.h)</li> <li>WshShellPromptWait_t (wsh_shell_promptwait.h)</li> <li>WSH_SHELL_RET_STATE_t (wsh_shell_types.h)</li> <li>WshShell_Bool_t (wsh_shell_types.h)</li> <li>WshShell_Char_t (wsh_shell_types.h)</li> <li>WshShell_S16_t (wsh_shell_types.h)</li> <li>WshShell_S32_t (wsh_shell_types.h)</li> <li>WshShell_S8_t (wsh_shell_types.h)</li> <li>WshShell_Size_t (wsh_shell_types.h)</li> <li>WshShell_U16_t (wsh_shell_types.h)</li> <li>WshShell_U32_t (wsh_shell_types.h)</li> <li>WshShell_U8_t (wsh_shell_types.h)</li> </ul>"},{"location":"Wsh_Shell_API/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}